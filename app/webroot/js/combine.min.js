/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
        navigator = window.navigator,
        location = window.location;
    var jQuery = (function() {
    
    // Define a local copy of jQuery
    var jQuery = function( selector, context ) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init( selector, context, rootjQuery );
        },
    
        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,
    
        // Map over the $ in case of overwrite
        _$ = window.$,
    
        // A central reference to the root jQuery(document)
        rootjQuery,
    
        // A simple way to check for HTML strings or ID strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
    
        // Check if a string has a non-whitespace character in it
        rnotwhite = /\S/,
    
        // Used for trimming whitespace
        trimLeft = /^\s+/,
        trimRight = /\s+$/,
    
        // Match a standalone tag
        rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
    
        // JSON RegExp
        rvalidchars = /^[\],:{}\s]*$/,
        rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
        rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
        rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
    
        // Useragent RegExp
        rwebkit = /(webkit)[ \/]([\w.]+)/,
        ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
        rmsie = /(msie) ([\w.]+)/,
        rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,
    
        // Matches dashed string for camelizing
        rdashAlpha = /-([a-z]|[0-9])/ig,
        rmsPrefix = /^-ms-/,
    
        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function( all, letter ) {
            return ( letter + "" ).toUpperCase();
        },
    
        // Keep a UserAgent string for use with jQuery.browser
        userAgent = navigator.userAgent,
    
        // For matching the engine and version of the browser
        browserMatch,
    
        // The deferred used on DOM ready
        readyList,
    
        // The ready event handler
        DOMContentLoaded,
    
        // Save a reference to some core methods
        toString = Object.prototype.toString,
        hasOwn = Object.prototype.hasOwnProperty,
        push = Array.prototype.push,
        slice = Array.prototype.slice,
        trim = String.prototype.trim,
        indexOf = Array.prototype.indexOf,
    
        // [[Class]] -> type pairs
        class2type = {};
    
    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,
        init: function( selector, context, rootjQuery ) {
            var match, elem, ret, doc;
    
            // Handle $(""), $(null), or $(undefined)
            if ( !selector ) {
                return this;
            }
    
            // Handle $(DOMElement)
            if ( selector.nodeType ) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }
    
            // The body element only exists once, optimize finding it
            if ( selector === "body" && !context && document.body ) {
                this.context = document;
                this[0] = document.body;
                this.selector = selector;
                this.length = 1;
                return this;
            }
    
            // Handle HTML strings
            if ( typeof selector === "string" ) {
                // Are we dealing with HTML string or an ID?
                if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [ null, selector, null ];
    
                } else {
                    match = quickExpr.exec( selector );
                }
    
                // Verify a match, and that no context was specified for #id
                if ( match && (match[1] || !context) ) {
    
                    // HANDLE: $(html) -> $(array)
                    if ( match[1] ) {
                        context = context instanceof jQuery ? context[0] : context;
                        doc = ( context ? context.ownerDocument || context : document );
    
                        // If a single string is passed in and it's a single tag
                        // just do a createElement and skip the rest
                        ret = rsingleTag.exec( selector );
    
                        if ( ret ) {
                            if ( jQuery.isPlainObject( context ) ) {
                                selector = [ document.createElement( ret[1] ) ];
                                jQuery.fn.attr.call( selector, context, true );
    
                            } else {
                                selector = [ doc.createElement( ret[1] ) ];
                            }
    
                        } else {
                            ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
                            selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
                        }
    
                        return jQuery.merge( this, selector );
    
                    // HANDLE: $("#id")
                    } else {
                        elem = document.getElementById( match[2] );
    
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if ( elem && elem.parentNode ) {
                            // Handle the case where IE and Opera return items
                            // by name instead of ID
                            if ( elem.id !== match[2] ) {
                                return rootjQuery.find( selector );
                            }
    
                            // Otherwise, we inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }
    
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
    
                // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                    return ( context || rootjQuery ).find( selector );
    
                // HANDLE: $(expr, context)
                // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor( context ).find( selector );
                }
    
            // HANDLE: $(function)
            // Shortcut for document ready
            } else if ( jQuery.isFunction( selector ) ) {
                return rootjQuery.ready( selector );
            }
    
            if ( selector.selector !== undefined ) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
    
            return jQuery.makeArray( selector, this );
        },
    
        // Start with an empty selector
        selector: "",
    
        // The current version of jQuery being used
        jquery: "1.7.2",
    
        // The default length of a jQuery object is 0
        length: 0,
    
        // The number of elements contained in the matched element set
        size: function() {
            return this.length;
        },
    
        toArray: function() {
            return slice.call( this, 0 );
        },
    
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {
            return num == null ?
    
                // Return a 'clean' array
                this.toArray() :
    
                // Return just the object
                ( num < 0 ? this[ this.length + num ] : this[ num ] );
        },
    
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems, name, selector ) {
            // Build a new jQuery matched element set
            var ret = this.constructor();
    
            if ( jQuery.isArray( elems ) ) {
                push.apply( ret, elems );
    
            } else {
                jQuery.merge( ret, elems );
            }
    
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
    
            ret.context = this.context;
    
            if ( name === "find" ) {
                ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
            } else if ( name ) {
                ret.selector = this.selector + "." + name + "(" + selector + ")";
            }
    
            // Return the newly-formed element set
            return ret;
        },
    
        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function( callback, args ) {
            return jQuery.each( this, callback, args );
        },
    
        ready: function( fn ) {
            // Attach the listeners
            jQuery.bindReady();
    
            // Add the callback
            readyList.add( fn );
    
            return this;
        },
    
        eq: function( i ) {
            i = +i;
            return i === -1 ?
                this.slice( i ) :
                this.slice( i, i + 1 );
        },
    
        first: function() {
            return this.eq( 0 );
        },
    
        last: function() {
            return this.eq( -1 );
        },
    
        slice: function() {
            return this.pushStack( slice.apply( this, arguments ),
                "slice", slice.call(arguments).join(",") );
        },
    
        map: function( callback ) {
            return this.pushStack( jQuery.map(this, function( elem, i ) {
                return callback.call( elem, i, elem );
            }));
        },
    
        end: function() {
            return this.prevObject || this.constructor(null);
        },
    
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    
    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;
    
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;
    
        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
        }
    
        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }
    
        // extend jQuery itself if only one argument is passed
        if ( length === i ) {
            target = this;
            --i;
        }
    
        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];
    
                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }
    
                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
    
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
    
                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );
    
                    // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }
    
        // Return the modified object
        return target;
    };
    
    jQuery.extend({
        noConflict: function( deep ) {
            if ( window.$ === jQuery ) {
                window.$ = _$;
            }
    
            if ( deep && window.jQuery === jQuery ) {
                window.jQuery = _jQuery;
            }
    
            return jQuery;
        },
    
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
    
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
    
        // Hold (or release) the ready event
        holdReady: function( hold ) {
            if ( hold ) {
                jQuery.readyWait++;
            } else {
                jQuery.ready( true );
            }
        },
    
        // Handle when the DOM is ready
        ready: function( wait ) {
            // Either a released hold or an DOMready/load event and not yet ready
            if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if ( !document.body ) {
                    return setTimeout( jQuery.ready, 1 );
                }
    
                // Remember that the DOM is ready
                jQuery.isReady = true;
    
                // If a normal DOM Ready event fired, decrement, and wait if need be
                if ( wait !== true && --jQuery.readyWait > 0 ) {
                    return;
                }
    
                // If there are functions bound, to execute
                readyList.fireWith( document, [ jQuery ] );
    
                // Trigger any bound ready events
                if ( jQuery.fn.trigger ) {
                    jQuery( document ).trigger( "ready" ).off( "ready" );
                }
            }
        },
    
        bindReady: function() {
            if ( readyList ) {
                return;
            }
    
            readyList = jQuery.Callbacks( "once memory" );
    
            // Catch cases where $(document).ready() is called after the
            // browser event has already occurred.
            if ( document.readyState === "complete" ) {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                return setTimeout( jQuery.ready, 1 );
            }
    
            // Mozilla, Opera and webkit nightlies currently support this event
            if ( document.addEventListener ) {
                // Use the handy event callback
                document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
    
                // A fallback to window.onload, that will always work
                window.addEventListener( "load", jQuery.ready, false );
    
            // If IE event model is used
            } else if ( document.attachEvent ) {
                // ensure firing before onload,
                // maybe late but safe also for iframes
                document.attachEvent( "onreadystatechange", DOMContentLoaded );
    
                // A fallback to window.onload, that will always work
                window.attachEvent( "onload", jQuery.ready );
    
                // If IE and not a frame
                // continually check to see if the document is ready
                var toplevel = false;
    
                try {
                    toplevel = window.frameElement == null;
                } catch(e) {}
    
                if ( document.documentElement.doScroll && toplevel ) {
                    doScrollCheck();
                }
            }
        },
    
        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function( obj ) {
            return jQuery.type(obj) === "function";
        },
    
        isArray: Array.isArray || function( obj ) {
            return jQuery.type(obj) === "array";
        },
    
        isWindow: function( obj ) {
            return obj != null && obj == obj.window;
        },
    
        isNumeric: function( obj ) {
            return !isNaN( parseFloat(obj) ) && isFinite( obj );
        },
    
        type: function( obj ) {
            return obj == null ?
                String( obj ) :
                class2type[ toString.call(obj) ] || "object";
        },
    
        isPlainObject: function( obj ) {
            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
            }
    
            try {
                // Not own constructor property must be Object
                if ( obj.constructor &&
                    !hasOwn.call(obj, "constructor") &&
                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                    return false;
                }
            } catch ( e ) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
            }
    
            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.
    
            var key;
            for ( key in obj ) {}
    
            return key === undefined || hasOwn.call( obj, key );
        },
    
        isEmptyObject: function( obj ) {
            for ( var name in obj ) {
                return false;
            }
            return true;
        },
    
        error: function( msg ) {
            throw new Error( msg );
        },
    
        parseJSON: function( data ) {
            if ( typeof data !== "string" || !data ) {
                return null;
            }
    
            // Make sure leading/trailing whitespace is removed (IE can't handle it)
            data = jQuery.trim( data );
    
            // Attempt to parse using the native JSON parser first
            if ( window.JSON && window.JSON.parse ) {
                return window.JSON.parse( data );
            }
    
            // Make sure the incoming data is actual JSON
            // Logic borrowed from http://json.org/json2.js
            if ( rvalidchars.test( data.replace( rvalidescape, "@" )
                .replace( rvalidtokens, "]" )
                .replace( rvalidbraces, "")) ) {
    
                return ( new Function( "return " + data ) )();
    
            }
            jQuery.error( "Invalid JSON: " + data );
        },
    
        // Cross-browser xml parsing
        parseXML: function( data ) {
            if ( typeof data !== "string" || !data ) {
                return null;
            }
            var xml, tmp;
            try {
                if ( window.DOMParser ) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString( data , "text/xml" );
                } else { // IE
                    xml = new ActiveXObject( "Microsoft.XMLDOM" );
                    xml.async = "false";
                    xml.loadXML( data );
                }
            } catch( e ) {
                xml = undefined;
            }
            if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
                jQuery.error( "Invalid XML: " + data );
            }
            return xml;
        },
    
        noop: function() {},
    
        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function( data ) {
            if ( data && rnotwhite.test( data ) ) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                ( window.execScript || function( data ) {
                    window[ "eval" ].call( window, data );
                } )( data );
            }
        },
    
        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function( string ) {
            return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
        },
    
        nodeName: function( elem, name ) {
            return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
        },
    
        // args is for internal usage only
        each: function( object, callback, args ) {
            var name, i = 0,
                length = object.length,
                isObj = length === undefined || jQuery.isFunction( object );
    
            if ( args ) {
                if ( isObj ) {
                    for ( name in object ) {
                        if ( callback.apply( object[ name ], args ) === false ) {
                            break;
                        }
                    }
                } else {
                    for ( ; i < length; ) {
                        if ( callback.apply( object[ i++ ], args ) === false ) {
                            break;
                        }
                    }
                }
    
            // A special, fast, case for the most common use of each
            } else {
                if ( isObj ) {
                    for ( name in object ) {
                        if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
                            break;
                        }
                    }
                } else {
                    for ( ; i < length; ) {
                        if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
                            break;
                        }
                    }
                }
            }
    
            return object;
        },
    
        // Use native String.trim function wherever possible
        trim: trim ?
            function( text ) {
                return text == null ?
                    "" :
                    trim.call( text );
            } :
    
            // Otherwise use our own trimming functionality
            function( text ) {
                return text == null ?
                    "" :
                    text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
            },
    
        // results is for internal usage only
        makeArray: function( array, results ) {
            var ret = results || [];
    
            if ( array != null ) {
                // The window, strings (and functions) also have 'length'
                // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                var type = jQuery.type( array );
    
                if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
                    push.call( ret, array );
                } else {
                    jQuery.merge( ret, array );
                }
            }
    
            return ret;
        },
    
        inArray: function( elem, array, i ) {
            var len;
    
            if ( array ) {
                if ( indexOf ) {
                    return indexOf.call( array, elem, i );
                }
    
                len = array.length;
                i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
    
                for ( ; i < len; i++ ) {
                    // Skip accessing in sparse arrays
                    if ( i in array && array[ i ] === elem ) {
                        return i;
                    }
                }
            }
    
            return -1;
        },
    
        merge: function( first, second ) {
            var i = first.length,
                j = 0;
    
            if ( typeof second.length === "number" ) {
                for ( var l = second.length; j < l; j++ ) {
                    first[ i++ ] = second[ j ];
                }
    
            } else {
                while ( second[j] !== undefined ) {
                    first[ i++ ] = second[ j++ ];
                }
            }
    
            first.length = i;
    
            return first;
        },
    
        grep: function( elems, callback, inv ) {
            var ret = [], retVal;
            inv = !!inv;
    
            // Go through the array, only saving the items
            // that pass the validator function
            for ( var i = 0, length = elems.length; i < length; i++ ) {
                retVal = !!callback( elems[ i ], i );
                if ( inv !== retVal ) {
                    ret.push( elems[ i ] );
                }
            }
    
            return ret;
        },
    
        // arg is for internal usage only
        map: function( elems, callback, arg ) {
            var value, key, ret = [],
                i = 0,
                length = elems.length,
                // jquery objects are treated as arrays
                isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
    
            // Go through the array, translating each of the items to their
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback( elems[ i ], i, arg );
    
                    if ( value != null ) {
                        ret[ ret.length ] = value;
                    }
                }
    
            // Go through every key on the object,
            } else {
                for ( key in elems ) {
                    value = callback( elems[ key ], key, arg );
    
                    if ( value != null ) {
                        ret[ ret.length ] = value;
                    }
                }
            }
    
            // Flatten any nested arrays
            return ret.concat.apply( [], ret );
        },
    
        // A global GUID counter for objects
        guid: 1,
    
        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function( fn, context ) {
            if ( typeof context === "string" ) {
                var tmp = fn[ context ];
                context = fn;
                fn = tmp;
            }
    
            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if ( !jQuery.isFunction( fn ) ) {
                return undefined;
            }
    
            // Simulated bind
            var args = slice.call( arguments, 2 ),
                proxy = function() {
                    return fn.apply( context, args.concat( slice.call( arguments ) ) );
                };
    
            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
    
            return proxy;
        },
    
        // Mutifunctional method to get and set values to a collection
        // The value/s can optionally be executed if it's a function
        access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
            var exec,
                bulk = key == null,
                i = 0,
                length = elems.length;
    
            // Sets many values
            if ( key && typeof key === "object" ) {
                for ( i in key ) {
                    jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
                }
                chainable = 1;
    
            // Sets one value
            } else if ( value !== undefined ) {
                // Optionally, function values get executed if exec is true
                exec = pass === undefined && jQuery.isFunction( value );
    
                if ( bulk ) {
                    // Bulk operations only iterate when executing function values
                    if ( exec ) {
                        exec = fn;
                        fn = function( elem, key, value ) {
                            return exec.call( jQuery( elem ), value );
                        };
    
                    // Otherwise they run against the entire set
                    } else {
                        fn.call( elems, value );
                        fn = null;
                    }
                }
    
                if ( fn ) {
                    for (; i < length; i++ ) {
                        fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
                    }
                }
    
                chainable = 1;
            }
    
            return chainable ?
                elems :
    
                // Gets
                bulk ?
                    fn.call( elems ) :
                    length ? fn( elems[0], key ) : emptyGet;
        },
    
        now: function() {
            return ( new Date() ).getTime();
        },
    
        // Use of jQuery.browser is frowned upon.
        // More details: http://docs.jquery.com/Utilities/jQuery.browser
        uaMatch: function( ua ) {
            ua = ua.toLowerCase();
    
            var match = rwebkit.exec( ua ) ||
                ropera.exec( ua ) ||
                rmsie.exec( ua ) ||
                ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
                [];
    
            return { browser: match[1] || "", version: match[2] || "0" };
        },
    
        sub: function() {
            function jQuerySub( selector, context ) {
                return new jQuerySub.fn.init( selector, context );
            }
            jQuery.extend( true, jQuerySub, this );
            jQuerySub.superclass = this;
            jQuerySub.fn = jQuerySub.prototype = this();
            jQuerySub.fn.constructor = jQuerySub;
            jQuerySub.sub = this.sub;
            jQuerySub.fn.init = function init( selector, context ) {
                if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
                    context = jQuerySub( context );
                }
    
                return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
            };
            jQuerySub.fn.init.prototype = jQuerySub.fn;
            var rootjQuerySub = jQuerySub(document);
            return jQuerySub;
        },
    
        browser: {}
    });
    
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
        class2type[ "[object " + name + "]" ] = name.toLowerCase();
    });
    
    browserMatch = jQuery.uaMatch( userAgent );
    if ( browserMatch.browser ) {
        jQuery.browser[ browserMatch.browser ] = true;
        jQuery.browser.version = browserMatch.version;
    }
    
    // Deprecated, use jQuery.browser.webkit instead
    if ( jQuery.browser.webkit ) {
        jQuery.browser.safari = true;
    }
    
    // IE doesn't match non-breaking spaces with \s
    if ( rnotwhite.test( "\xA0" ) ) {
        trimLeft = /^[\s\xA0]+/;
        trimRight = /[\s\xA0]+$/;
    }
    
    // All jQuery objects should point back to these
    rootjQuery = jQuery(document);
    
    // Cleanup functions for the document ready method
    if ( document.addEventListener ) {
        DOMContentLoaded = function() {
            document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            jQuery.ready();
        };
    
    } else if ( document.attachEvent ) {
        DOMContentLoaded = function() {
            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if ( document.readyState === "complete" ) {
                document.detachEvent( "onreadystatechange", DOMContentLoaded );
                jQuery.ready();
            }
        };
    }
    
    // The DOM ready check for Internet Explorer
    function doScrollCheck() {
        if ( jQuery.isReady ) {
            return;
        }
    
        try {
            // If IE is used, use the trick by Diego Perini
            // http://javascript.nwbox.com/IEContentLoaded/
            document.documentElement.doScroll("left");
        } catch(e) {
            setTimeout( doScrollCheck, 1 );
            return;
        }
    
        // and execute any waiting functions
        jQuery.ready();
    }
    
    return jQuery;
    
    })();
    
    
    // String to Object flags format cache
    var flagsCache = {};
    
    // Convert String-formatted flags into Object-formatted ones and store in cache
    function createFlags( flags ) {
        var object = flagsCache[ flags ] = {},
            i, length;
        flags = flags.split( /\s+/ );
        for ( i = 0, length = flags.length; i < length; i++ ) {
            object[ flags[i] ] = true;
        }
        return object;
    }
    
    /*
     * Create a callback list using the following parameters:
     *
     *	flags:	an optional list of space-separated flags that will change how
     *			the callback list behaves
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible flags:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function( flags ) {
    
        // Convert flags from String-formatted to Object-formatted
        // (we check in cache first)
        flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};
    
        var // Actual callback list
            list = [],
            // Stack of fire calls for repeatable lists
            stack = [],
            // Last fire value (for non-forgettable lists)
            memory,
            // Flag to know if list was already fired
            fired,
            // Flag to know if list is currently firing
            firing,
            // First callback to fire (used internally by add and fireWith)
            firingStart,
            // End of the loop when firing
            firingLength,
            // Index of currently firing callback (modified by remove if needed)
            firingIndex,
            // Add one or several callbacks to the list
            add = function( args ) {
                var i,
                    length,
                    elem,
                    type,
                    actual;
                for ( i = 0, length = args.length; i < length; i++ ) {
                    elem = args[ i ];
                    type = jQuery.type( elem );
                    if ( type === "array" ) {
                        // Inspect recursively
                        add( elem );
                    } else if ( type === "function" ) {
                        // Add if not in unique mode and callback is not in
                        if ( !flags.unique || !self.has( elem ) ) {
                            list.push( elem );
                        }
                    }
                }
            },
            // Fire callbacks
            fire = function( context, args ) {
                args = args || [];
                memory = !flags.memory || [ context, args ];
                fired = true;
                firing = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                    if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
                        memory = true; // Mark as halted
                        break;
                    }
                }
                firing = false;
                if ( list ) {
                    if ( !flags.once ) {
                        if ( stack && stack.length ) {
                            memory = stack.shift();
                            self.fireWith( memory[ 0 ], memory[ 1 ] );
                        }
                    } else if ( memory === true ) {
                        self.disable();
                    } else {
                        list = [];
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if ( list ) {
                        var length = list.length;
                        add( arguments );
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if ( firing ) {
                            firingLength = list.length;
                        // With memory, if we're not firing then
                        // we should call right away, unless previous
                        // firing was halted (stopOnFalse)
                        } else if ( memory && memory !== true ) {
                            firingStart = length;
                            fire( memory[ 0 ], memory[ 1 ] );
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function() {
                    if ( list ) {
                        var args = arguments,
                            argIndex = 0,
                            argLength = args.length;
                        for ( ; argIndex < argLength ; argIndex++ ) {
                            for ( var i = 0; i < list.length; i++ ) {
                                if ( args[ argIndex ] === list[ i ] ) {
                                    // Handle firingIndex and firingLength
                                    if ( firing ) {
                                        if ( i <= firingLength ) {
                                            firingLength--;
                                            if ( i <= firingIndex ) {
                                                firingIndex--;
                                            }
                                        }
                                    }
                                    // Remove the element
                                    list.splice( i--, 1 );
                                    // If we have some unicity property then
                                    // we only need to do this once
                                    if ( flags.unique ) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    return this;
                },
                // Control if a given callback is in the list
                has: function( fn ) {
                    if ( list ) {
                        var i = 0,
                            length = list.length;
                        for ( ; i < length; i++ ) {
                            if ( fn === list[ i ] ) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                // Remove all callbacks from the list
                empty: function() {
                    list = [];
                    return this;
                },
                // Have the list do nothing anymore
                disable: function() {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function() {
                    return !list;
                },
                // Lock the list in its current state
                lock: function() {
                    stack = undefined;
                    if ( !memory || memory === true ) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function() {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                    if ( stack ) {
                        if ( firing ) {
                            if ( !flags.once ) {
                                stack.push( [ context, args ] );
                            }
                        } else if ( !( flags.once && memory ) ) {
                            fire( context, args );
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith( this, arguments );
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };
    
        return self;
    };
    
    
    
    
    var // Static reference to slice
        sliceDeferred = [].slice;
    
    jQuery.extend({
    
        Deferred: function( func ) {
            var doneList = jQuery.Callbacks( "once memory" ),
                failList = jQuery.Callbacks( "once memory" ),
                progressList = jQuery.Callbacks( "memory" ),
                state = "pending",
                lists = {
                    resolve: doneList,
                    reject: failList,
                    notify: progressList
                },
                promise = {
                    done: doneList.add,
                    fail: failList.add,
                    progress: progressList.add,
    
                    state: function() {
                        return state;
                    },
    
                    // Deprecated
                    isResolved: doneList.fired,
                    isRejected: failList.fired,
    
                    then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
                        deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
                        return this;
                    },
                    always: function() {
                        deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
                        return this;
                    },
                    pipe: function( fnDone, fnFail, fnProgress ) {
                        return jQuery.Deferred(function( newDefer ) {
                            jQuery.each( {
                                done: [ fnDone, "resolve" ],
                                fail: [ fnFail, "reject" ],
                                progress: [ fnProgress, "notify" ]
                            }, function( handler, data ) {
                                var fn = data[ 0 ],
                                    action = data[ 1 ],
                                    returned;
                                if ( jQuery.isFunction( fn ) ) {
                                    deferred[ handler ](function() {
                                        returned = fn.apply( this, arguments );
                                        if ( returned && jQuery.isFunction( returned.promise ) ) {
                                            returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
                                        } else {
                                            newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                                        }
                                    });
                                } else {
                                    deferred[ handler ]( newDefer[ action ] );
                                }
                            });
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function( obj ) {
                        if ( obj == null ) {
                            obj = promise;
                        } else {
                            for ( var key in promise ) {
                                obj[ key ] = promise[ key ];
                            }
                        }
                        return obj;
                    }
                },
                deferred = promise.promise({}),
                key;
    
            for ( key in lists ) {
                deferred[ key ] = lists[ key ].fire;
                deferred[ key + "With" ] = lists[ key ].fireWith;
            }
    
            // Handle state
            deferred.done( function() {
                state = "resolved";
            }, failList.disable, progressList.lock ).fail( function() {
                state = "rejected";
            }, doneList.disable, progressList.lock );
    
            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }
    
            // All done!
            return deferred;
        },
    
        // Deferred helper
        when: function( firstParam ) {
            var args = sliceDeferred.call( arguments, 0 ),
                i = 0,
                length = args.length,
                pValues = new Array( length ),
                count = length,
                pCount = length,
                deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
                    firstParam :
                    jQuery.Deferred(),
                promise = deferred.promise();
            function resolveFunc( i ) {
                return function( value ) {
                    args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
                    if ( !( --count ) ) {
                        deferred.resolveWith( deferred, args );
                    }
                };
            }
            function progressFunc( i ) {
                return function( value ) {
                    pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
                    deferred.notifyWith( promise, pValues );
                };
            }
            if ( length > 1 ) {
                for ( ; i < length; i++ ) {
                    if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
                        args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
                    } else {
                        --count;
                    }
                }
                if ( !count ) {
                    deferred.resolveWith( deferred, args );
                }
            } else if ( deferred !== firstParam ) {
                deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
            }
            return promise;
        }
    });
    
    
    
    
    jQuery.support = (function() {
    
        var support,
            all,
            a,
            select,
            opt,
            input,
            fragment,
            tds,
            events,
            eventName,
            i,
            isSupported,
            div = document.createElement( "div" ),
            documentElement = document.documentElement;
    
        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
    
        all = div.getElementsByTagName( "*" );
        a = div.getElementsByTagName( "a" )[ 0 ];
    
        // Can't get basic test support
        if ( !all || !all.length || !a ) {
            return {};
        }
    
        // First batch of supports tests
        select = document.createElement( "select" );
        opt = select.appendChild( document.createElement("option") );
        input = div.getElementsByTagName( "input" )[ 0 ];
    
        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: ( div.firstChild.nodeType === 3 ),
    
            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,
    
            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,
    
            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test( a.getAttribute("style") ),
    
            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: ( a.getAttribute("href") === "/a" ),
    
            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55/.test( a.style.opacity ),
    
            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,
    
            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: ( input.value === "on" ),
    
            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,
    
            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",
    
            // Tests for enctype support on a form(#6743)
            enctype: !!document.createElement("form").enctype,
    
            // Makes sure cloning an html5 element does not cause problems
            // Where outerHTML is undefined, this still works
            html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
    
            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true,
            pixelMargin: true
        };
    
        // jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
        jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");
    
        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode( true ).checked;
    
        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;
    
        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }
    
        if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
            div.attachEvent( "onclick", function() {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode( true ).fireEvent( "onclick" );
        }
    
        // Check if a radio maintains its value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";
    
        input.setAttribute("checked", "checked");
    
        // #11217 - WebKit loses check when the name is after the checked attribute
        input.setAttribute( "name", "t" );
    
        div.appendChild( input );
        fragment = document.createDocumentFragment();
        fragment.appendChild( div.lastChild );
    
        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
    
        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;
    
        fragment.removeChild( input );
        fragment.appendChild( div );
    
        // Technique from Juriy Zaytsev
        // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if ( div.attachEvent ) {
            for ( i in {
                submit: 1,
                change: 1,
                focusin: 1
            }) {
                eventName = "on" + i;
                isSupported = ( eventName in div );
                if ( !isSupported ) {
                    div.setAttribute( eventName, "return;" );
                    isSupported = ( typeof div[ eventName ] === "function" );
                }
                support[ i + "Bubbles" ] = isSupported;
            }
        }
    
        fragment.removeChild( div );
    
        // Null elements to avoid leaks in IE
        fragment = select = opt = div = input = null;
    
        // Run tests that need a body at doc ready
        jQuery(function() {
            var container, outer, inner, table, td, offsetSupport,
                marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
                paddingMarginBorderVisibility, paddingMarginBorder,
                body = document.getElementsByTagName("body")[0];
    
            if ( !body ) {
                // Return for frameset docs that don't have a body
                return;
            }
    
            conMarginTop = 1;
            paddingMarginBorder = "padding:0;margin:0;border:";
            positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
            paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
            style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
            html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
                "<table " + style + "' cellpadding='0' cellspacing='0'>" +
                "<tr><td></td></tr></table>";
    
            container = document.createElement("div");
            container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
            body.insertBefore( container, body.firstChild );
    
            // Construct the test element
            div = document.createElement("div");
            container.appendChild( div );
    
            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            // (only IE 8 fails this test)
            div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName( "td" );
            isSupported = ( tds[ 0 ].offsetHeight === 0 );
    
            tds[ 0 ].style.display = "";
            tds[ 1 ].style.display = "none";
    
            // Check if empty table cells still have offsetWidth/Height
            // (IE <= 8 fail this test)
            support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
    
            // Check if div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container. For more
            // info see bug #3333
            // Fails in WebKit before Feb 2011 nightlies
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            if ( window.getComputedStyle ) {
                div.innerHTML = "";
                marginDiv = document.createElement( "div" );
                marginDiv.style.width = "0";
                marginDiv.style.marginRight = "0";
                div.style.width = "2px";
                div.appendChild( marginDiv );
                support.reliableMarginRight =
                    ( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
            }
    
            if ( typeof div.style.zoom !== "undefined" ) {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.innerHTML = "";
                div.style.width = div.style.padding = "1px";
                div.style.border = 0;
                div.style.overflow = "hidden";
                div.style.display = "inline";
                div.style.zoom = 1;
                support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );
    
                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "block";
                div.style.overflow = "visible";
                div.innerHTML = "<div style='width:5px;'></div>";
                support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
            }
    
            div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
            div.innerHTML = html;
    
            outer = div.firstChild;
            inner = outer.firstChild;
            td = outer.nextSibling.firstChild.firstChild;
    
            offsetSupport = {
                doesNotAddBorder: ( inner.offsetTop !== 5 ),
                doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
            };
    
            inner.style.position = "fixed";
            inner.style.top = "20px";
    
            // safari subtracts parent border width here which is 5px
            offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
            inner.style.position = inner.style.top = "";
    
            outer.style.overflow = "hidden";
            outer.style.position = "relative";
    
            offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
            offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );
    
            if ( window.getComputedStyle ) {
                div.style.marginTop = "1%";
                support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
            }
    
            if ( typeof container.style.zoom !== "undefined" ) {
                container.style.zoom = 1;
            }
    
            body.removeChild( container );
            marginDiv = div = container = null;
    
            jQuery.extend( support, offsetSupport );
        });
    
        return support;
    })();
    
    
    
    
    var rbrace = /^(?:\{.*\}|\[.*\])$/,
        rmultiDash = /([A-Z])/g;
    
    jQuery.extend({
        cache: {},
    
        // Please use with caution
        uuid: 0,
    
        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
    
        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },
    
        hasData: function( elem ) {
            elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
            return !!elem && !isEmptyDataObject( elem );
        },
    
        data: function( elem, name, data, pvt /* Internal Use Only */ ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }
    
            var privateCache, thisCache, ret,
                internalKey = jQuery.expando,
                getByName = typeof name === "string",
    
                // We have to handle DOM nodes and JS objects differently because IE6-7
                // can't GC object references properly across the DOM-JS boundary
                isNode = elem.nodeType,
    
                // Only DOM nodes need the global jQuery cache; JS object data is
                // attached directly to the object so GC can occur automatically
                cache = isNode ? jQuery.cache : elem,
    
                // Only defining an ID for JS objects if its cache already exists allows
                // the code to shortcut on the same path as a DOM node with no cache
                id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
                isEvents = name === "events";
    
            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
                return;
            }
    
            if ( !id ) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if ( isNode ) {
                    elem[ internalKey ] = id = ++jQuery.uuid;
                } else {
                    id = internalKey;
                }
            }
    
            if ( !cache[ id ] ) {
                cache[ id ] = {};
    
                // Avoids exposing jQuery metadata on plain JS objects when the object
                // is serialized using JSON.stringify
                if ( !isNode ) {
                    cache[ id ].toJSON = jQuery.noop;
                }
            }
    
            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if ( typeof name === "object" || typeof name === "function" ) {
                if ( pvt ) {
                    cache[ id ] = jQuery.extend( cache[ id ], name );
                } else {
                    cache[ id ].data = jQuery.extend( cache[ id ].data, name );
                }
            }
    
            privateCache = thisCache = cache[ id ];
    
            // jQuery data() is stored in a separate object inside the object's internal data
            // cache in order to avoid key collisions between internal data and user-defined
            // data.
            if ( !pvt ) {
                if ( !thisCache.data ) {
                    thisCache.data = {};
                }
    
                thisCache = thisCache.data;
            }
    
            if ( data !== undefined ) {
                thisCache[ jQuery.camelCase( name ) ] = data;
            }
    
            // Users should not attempt to inspect the internal events object using jQuery.data,
            // it is undocumented and subject to change. But does anyone listen? No.
            if ( isEvents && !thisCache[ name ] ) {
                return privateCache.events;
            }
    
            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            if ( getByName ) {
    
                // First Try to find as-is property data
                ret = thisCache[ name ];
    
                // Test for null|undefined property data
                if ( ret == null ) {
    
                    // Try to find the camelCased property
                    ret = thisCache[ jQuery.camelCase( name ) ];
                }
            } else {
                ret = thisCache;
            }
    
            return ret;
        },
    
        removeData: function( elem, name, pvt /* Internal Use Only */ ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }
    
            var thisCache, i, l,
    
                // Reference to internal data cache key
                internalKey = jQuery.expando,
    
                isNode = elem.nodeType,
    
                // See jQuery.data for more information
                cache = isNode ? jQuery.cache : elem,
    
                // See jQuery.data for more information
                id = isNode ? elem[ internalKey ] : internalKey;
    
            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if ( !cache[ id ] ) {
                return;
            }
    
            if ( name ) {
    
                thisCache = pvt ? cache[ id ] : cache[ id ].data;
    
                if ( thisCache ) {
    
                    // Support array or space separated string names for data keys
                    if ( !jQuery.isArray( name ) ) {
    
                        // try the string as a key before any manipulation
                        if ( name in thisCache ) {
                            name = [ name ];
                        } else {
    
                            // split the camel cased version by spaces unless a key with the spaces exists
                            name = jQuery.camelCase( name );
                            if ( name in thisCache ) {
                                name = [ name ];
                            } else {
                                name = name.split( " " );
                            }
                        }
                    }
    
                    for ( i = 0, l = name.length; i < l; i++ ) {
                        delete thisCache[ name[i] ];
                    }
    
                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
                        return;
                    }
                }
            }
    
            // See jQuery.data for more information
            if ( !pvt ) {
                delete cache[ id ].data;
    
                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if ( !isEmptyDataObject(cache[ id ]) ) {
                    return;
                }
            }
    
            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            // Ensure that `cache` is not a window object #10080
            if ( jQuery.support.deleteExpando || !cache.setInterval ) {
                delete cache[ id ];
            } else {
                cache[ id ] = null;
            }
    
            // We destroyed the cache and need to eliminate the expando on the node to avoid
            // false lookups in the cache for entries that no longer exist
            if ( isNode ) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if ( jQuery.support.deleteExpando ) {
                    delete elem[ internalKey ];
                } else if ( elem.removeAttribute ) {
                    elem.removeAttribute( internalKey );
                } else {
                    elem[ internalKey ] = null;
                }
            }
        },
    
        // For internal use only.
        _data: function( elem, name, data ) {
            return jQuery.data( elem, name, data, true );
        },
    
        // A method for determining if a DOM node can handle the data expando
        acceptData: function( elem ) {
            if ( elem.nodeName ) {
                var match = jQuery.noData[ elem.nodeName.toLowerCase() ];
    
                if ( match ) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }
    
            return true;
        }
    });
    
    jQuery.fn.extend({
        data: function( key, value ) {
            var parts, part, attr, name, l,
                elem = this[0],
                i = 0,
                data = null;
    
            // Gets all values
            if ( key === undefined ) {
                if ( this.length ) {
                    data = jQuery.data( elem );
    
                    if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                        attr = elem.attributes;
                        for ( l = attr.length; i < l; i++ ) {
                            name = attr[i].name;
    
                            if ( name.indexOf( "data-" ) === 0 ) {
                                name = jQuery.camelCase( name.substring(5) );
    
                                dataAttr( elem, name, data[ name ] );
                            }
                        }
                        jQuery._data( elem, "parsedAttrs", true );
                    }
                }
    
                return data;
            }
    
            // Sets multiple values
            if ( typeof key === "object" ) {
                return this.each(function() {
                    jQuery.data( this, key );
                });
            }
    
            parts = key.split( ".", 2 );
            parts[1] = parts[1] ? "." + parts[1] : "";
            part = parts[1] + "!";
    
            return jQuery.access( this, function( value ) {
    
                if ( value === undefined ) {
                    data = this.triggerHandler( "getData" + part, [ parts[0] ] );
    
                    // Try to fetch any internally stored data first
                    if ( data === undefined && elem ) {
                        data = jQuery.data( elem, key );
                        data = dataAttr( elem, key, data );
                    }
    
                    return data === undefined && parts[1] ?
                        this.data( parts[0] ) :
                        data;
                }
    
                parts[1] = value;
                this.each(function() {
                    var self = jQuery( this );
    
                    self.triggerHandler( "setData" + part, parts );
                    jQuery.data( this, key, value );
                    self.triggerHandler( "changeData" + part, parts );
                });
            }, null, value, arguments.length > 1, null, false );
        },
    
        removeData: function( key ) {
            return this.each(function() {
                jQuery.removeData( this, key );
            });
        }
    });
    
    function dataAttr( elem, key, data ) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {
    
            var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
    
            data = elem.getAttribute( name );
    
            if ( typeof data === "string" ) {
                try {
                    data = data === "true" ? true :
                    data === "false" ? false :
                    data === "null" ? null :
                    jQuery.isNumeric( data ) ? +data :
                        rbrace.test( data ) ? jQuery.parseJSON( data ) :
                        data;
                } catch( e ) {}
    
                // Make sure we set the data so it isn't changed later
                jQuery.data( elem, key, data );
    
            } else {
                data = undefined;
            }
        }
    
        return data;
    }
    
    // checks a cache object for emptiness
    function isEmptyDataObject( obj ) {
        for ( var name in obj ) {
    
            // if the public data object is empty, the private is still empty
            if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
                continue;
            }
            if ( name !== "toJSON" ) {
                return false;
            }
        }
    
        return true;
    }
    
    
    
    
    function handleQueueMarkDefer( elem, type, src ) {
        var deferDataKey = type + "defer",
            queueDataKey = type + "queue",
            markDataKey = type + "mark",
            defer = jQuery._data( elem, deferDataKey );
        if ( defer &&
            ( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
            ( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout( function() {
                if ( !jQuery._data( elem, queueDataKey ) &&
                    !jQuery._data( elem, markDataKey ) ) {
                    jQuery.removeData( elem, deferDataKey, true );
                    defer.fire();
                }
            }, 0 );
        }
    }
    
    jQuery.extend({
    
        _mark: function( elem, type ) {
            if ( elem ) {
                type = ( type || "fx" ) + "mark";
                jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
            }
        },
    
        _unmark: function( force, elem, type ) {
            if ( force !== true ) {
                type = elem;
                elem = force;
                force = false;
            }
            if ( elem ) {
                type = type || "fx";
                var key = type + "mark",
                    count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
                if ( count ) {
                    jQuery._data( elem, key, count );
                } else {
                    jQuery.removeData( elem, key, true );
                    handleQueueMarkDefer( elem, type, "mark" );
                }
            }
        },
    
        queue: function( elem, type, data ) {
            var q;
            if ( elem ) {
                type = ( type || "fx" ) + "queue";
                q = jQuery._data( elem, type );
    
                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !q || jQuery.isArray(data) ) {
                        q = jQuery._data( elem, type, jQuery.makeArray(data) );
                    } else {
                        q.push( data );
                    }
                }
                return q || [];
            }
        },
    
        dequeue: function( elem, type ) {
            type = type || "fx";
    
            var queue = jQuery.queue( elem, type ),
                fn = queue.shift(),
                hooks = {};
    
            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
            }
    
            if ( fn ) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift( "inprogress" );
                }
    
                jQuery._data( elem, type + ".run", hooks );
                fn.call( elem, function() {
                    jQuery.dequeue( elem, type );
                }, hooks );
            }
    
            if ( !queue.length ) {
                jQuery.removeData( elem, type + "queue " + type + ".run", true );
                handleQueueMarkDefer( elem, type, "queue" );
            }
        }
    });
    
    jQuery.fn.extend({
        queue: function( type, data ) {
            var setter = 2;
    
            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
                setter--;
            }
    
            if ( arguments.length < setter ) {
                return jQuery.queue( this[0], type );
            }
    
            return data === undefined ?
                this :
                this.each(function() {
                    var queue = jQuery.queue( this, type, data );
    
                    if ( type === "fx" && queue[0] !== "inprogress" ) {
                        jQuery.dequeue( this, type );
                    }
                });
        },
        dequeue: function( type ) {
            return this.each(function() {
                jQuery.dequeue( this, type );
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function( time, type ) {
            time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
            type = type || "fx";
    
            return this.queue( type, function( next, hooks ) {
                var timeout = setTimeout( next, time );
                hooks.stop = function() {
                    clearTimeout( timeout );
                };
            });
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, object ) {
            if ( typeof type !== "string" ) {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
                elements = this,
                i = elements.length,
                count = 1,
                deferDataKey = type + "defer",
                queueDataKey = type + "queue",
                markDataKey = type + "mark",
                tmp;
            function resolve() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            }
            while( i-- ) {
                if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
                        ( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
                            jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
                        jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
                    count++;
                    tmp.add( resolve );
                }
            }
            resolve();
            return defer.promise( object );
        }
    });
    
    
    
    
    var rclass = /[\n\t\r]/g,
        rspace = /\s+/,
        rreturn = /\r/g,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea)?$/i,
        rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
        getSetAttribute = jQuery.support.getSetAttribute,
        nodeHook, boolHook, fixSpecified;
    
    jQuery.fn.extend({
        attr: function( name, value ) {
            return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
        },
    
        removeAttr: function( name ) {
            return this.each(function() {
                jQuery.removeAttr( this, name );
            });
        },
    
        prop: function( name, value ) {
            return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
        },
    
        removeProp: function( name ) {
            name = jQuery.propFix[ name ] || name;
            return this.each(function() {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[ name ] = undefined;
                    delete this[ name ];
                } catch( e ) {}
            });
        },
    
        addClass: function( value ) {
            var classNames, i, l, elem,
                setClass, c, cl;
    
            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).addClass( value.call(this, j, this.className) );
                });
            }
    
            if ( value && typeof value === "string" ) {
                classNames = value.split( rspace );
    
                for ( i = 0, l = this.length; i < l; i++ ) {
                    elem = this[ i ];
    
                    if ( elem.nodeType === 1 ) {
                        if ( !elem.className && classNames.length === 1 ) {
                            elem.className = value;
    
                        } else {
                            setClass = " " + elem.className + " ";
    
                            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
                                if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
                                    setClass += classNames[ c ] + " ";
                                }
                            }
                            elem.className = jQuery.trim( setClass );
                        }
                    }
                }
            }
    
            return this;
        },
    
        removeClass: function( value ) {
            var classNames, i, l, elem, className, c, cl;
    
            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).removeClass( value.call(this, j, this.className) );
                });
            }
    
            if ( (value && typeof value === "string") || value === undefined ) {
                classNames = ( value || "" ).split( rspace );
    
                for ( i = 0, l = this.length; i < l; i++ ) {
                    elem = this[ i ];
    
                    if ( elem.nodeType === 1 && elem.className ) {
                        if ( value ) {
                            className = (" " + elem.className + " ").replace( rclass, " " );
                            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
                                className = className.replace(" " + classNames[ c ] + " ", " ");
                            }
                            elem.className = jQuery.trim( className );
    
                        } else {
                            elem.className = "";
                        }
                    }
                }
            }
    
            return this;
        },
    
        toggleClass: function( value, stateVal ) {
            var type = typeof value,
                isBool = typeof stateVal === "boolean";
    
            if ( jQuery.isFunction( value ) ) {
                return this.each(function( i ) {
                    jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                });
            }
    
            return this.each(function() {
                if ( type === "string" ) {
                    // toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery( this ),
                        state = stateVal,
                        classNames = value.split( rspace );
    
                    while ( (className = classNames[ i++ ]) ) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass( className );
                        self[ state ? "addClass" : "removeClass" ]( className );
                    }
    
                } else if ( type === "undefined" || type === "boolean" ) {
                    if ( this.className ) {
                        // store className if set
                        jQuery._data( this, "__className__", this.className );
                    }
    
                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
                }
            });
        },
    
        hasClass: function( selector ) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for ( ; i < l; i++ ) {
                if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
                    return true;
                }
            }
    
            return false;
        },
    
        val: function( value ) {
            var hooks, ret, isFunction,
                elem = this[0];
    
            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
    
                    if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                        return ret;
                    }
    
                    ret = elem.value;
    
                    return typeof ret === "string" ?
                        // handle most common string cases
                        ret.replace(rreturn, "") :
                        // handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }
    
                return;
            }
    
            isFunction = jQuery.isFunction( value );
    
            return this.each(function( i ) {
                var self = jQuery(this), val;
    
                if ( this.nodeType !== 1 ) {
                    return;
                }
    
                if ( isFunction ) {
                    val = value.call( this, i, self.val() );
                } else {
                    val = value;
                }
    
                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";
                } else if ( typeof val === "number" ) {
                    val += "";
                } else if ( jQuery.isArray( val ) ) {
                    val = jQuery.map(val, function ( value ) {
                        return value == null ? "" : value + "";
                    });
                }
    
                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
    
                // If set returns undefined, fall back to normal setting
                if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            });
        }
    });
    
    jQuery.extend({
        valHooks: {
            option: {
                get: function( elem ) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function( elem ) {
                    var value, i, max, option,
                        index = elem.selectedIndex,
                        values = [],
                        options = elem.options,
                        one = elem.type === "select-one";
    
                    // Nothing was selected
                    if ( index < 0 ) {
                        return null;
                    }
    
                    // Loop through all the selected options
                    i = one ? index : 0;
                    max = one ? index + 1 : options.length;
                    for ( ; i < max; i++ ) {
                        option = options[ i ];
    
                        // Don't return options that are disabled or in a disabled optgroup
                        if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                                (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {
    
                            // Get the specific value for the option
                            value = jQuery( option ).val();
    
                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }
    
                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }
    
                    // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                    if ( one && !values.length && options.length ) {
                        return jQuery( options[ index ] ).val();
                    }
    
                    return values;
                },
    
                set: function( elem, value ) {
                    var values = jQuery.makeArray( value );
    
                    jQuery(elem).find("option").each(function() {
                        this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
                    });
    
                    if ( !values.length ) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },
    
        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },
    
        attr: function( elem, name, value, pass ) {
            var ret, hooks, notxml,
                nType = elem.nodeType;
    
            // don't get/set attributes on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }
    
            if ( pass && name in jQuery.attrFn ) {
                return jQuery( elem )[ name ]( value );
            }
    
            // Fallback to prop when attributes are not supported
            if ( typeof elem.getAttribute === "undefined" ) {
                return jQuery.prop( elem, name, value );
            }
    
            notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
    
            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if ( notxml ) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
            }
    
            if ( value !== undefined ) {
    
                if ( value === null ) {
                    jQuery.removeAttr( elem, name );
                    return;
    
                } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;
    
                } else {
                    elem.setAttribute( name, "" + value );
                    return value;
                }
    
            } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
                return ret;
    
            } else {
    
                ret = elem.getAttribute( name );
    
                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
                    undefined :
                    ret;
            }
        },
    
        removeAttr: function( elem, value ) {
            var propName, attrNames, name, l, isBool,
                i = 0;
    
            if ( value && elem.nodeType === 1 ) {
                attrNames = value.toLowerCase().split( rspace );
                l = attrNames.length;
    
                for ( ; i < l; i++ ) {
                    name = attrNames[ i ];
    
                    if ( name ) {
                        propName = jQuery.propFix[ name ] || name;
                        isBool = rboolean.test( name );
    
                        // See #9699 for explanation of this approach (setting first, then removal)
                        // Do not do this for boolean attributes (see #10870)
                        if ( !isBool ) {
                            jQuery.attr( elem, name, "" );
                        }
                        elem.removeAttribute( getSetAttribute ? name : propName );
    
                        // Set corresponding property to false for boolean attributes
                        if ( isBool && propName in elem ) {
                            elem[ propName ] = false;
                        }
                    }
                }
            }
        },
    
        attrHooks: {
            type: {
                set: function( elem, value ) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
                        jQuery.error( "type property can't be changed" );
                    } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            // Use the value property for back compat
            // Use the nodeHook for button elements in IE6/7 (#1954)
            value: {
                get: function( elem, name ) {
                    if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                        return nodeHook.get( elem, name );
                    }
                    return name in elem ?
                        elem.value :
                        null;
                },
                set: function( elem, value, name ) {
                    if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                        return nodeHook.set( elem, value, name );
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },
    
        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },
    
        prop: function( elem, name, value ) {
            var ret, hooks, notxml,
                nType = elem.nodeType;
    
            // don't get/set properties on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }
    
            notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
    
            if ( notxml ) {
                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }
    
            if ( value !== undefined ) {
                if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;
    
                } else {
                    return ( elem[ name ] = value );
                }
    
            } else {
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                    return ret;
    
                } else {
                    return elem[ name ];
                }
            }
        },
    
        propHooks: {
            tabIndex: {
                get: function( elem ) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabindex");
    
                    return attributeNode && attributeNode.specified ?
                        parseInt( attributeNode.value, 10 ) :
                        rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                            0 :
                            undefined;
                }
            }
        }
    });
    
    // Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
    jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;
    
    // Hook for boolean attributes
    boolHook = {
        get: function( elem, name ) {
            // Align boolean attributes with corresponding properties
            // Fall back to attribute presence where some booleans are not supported
            var attrNode,
                property = jQuery.prop( elem, name );
            return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
                name.toLowerCase() :
                undefined;
        },
        set: function( elem, value, name ) {
            var propName;
            if ( value === false ) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[ name ] || name;
                if ( propName in elem ) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[ propName ] = true;
                }
    
                elem.setAttribute( name, name.toLowerCase() );
            }
            return name;
        }
    };
    
    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if ( !getSetAttribute ) {
    
        fixSpecified = {
            name: true,
            id: true,
            coords: true
        };
    
        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = jQuery.valHooks.button = {
            get: function( elem, name ) {
                var ret;
                ret = elem.getAttributeNode( name );
                return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
                    ret.nodeValue :
                    undefined;
            },
            set: function( elem, value, name ) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode( name );
                if ( !ret ) {
                    ret = document.createAttribute( name );
                    elem.setAttributeNode( ret );
                }
                return ( ret.nodeValue = value + "" );
            }
        };
    
        // Apply the nodeHook to tabindex
        jQuery.attrHooks.tabindex.set = nodeHook.set;
    
        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each([ "width", "height" ], function( i, name ) {
            jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                set: function( elem, value ) {
                    if ( value === "" ) {
                        elem.setAttribute( name, "auto" );
                        return value;
                    }
                }
            });
        });
    
        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            get: nodeHook.get,
            set: function( elem, value, name ) {
                if ( value === "" ) {
                    value = "false";
                }
                nodeHook.set( elem, value, name );
            }
        };
    }
    
    
    // Some attributes require a special call on IE
    if ( !jQuery.support.hrefNormalized ) {
        jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
            jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                get: function( elem ) {
                    var ret = elem.getAttribute( name, 2 );
                    return ret === null ? undefined : ret;
                }
            });
        });
    }
    
    if ( !jQuery.support.style ) {
        jQuery.attrHooks.style = {
            get: function( elem ) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function( elem, value ) {
                return ( elem.style.cssText = "" + value );
            }
        };
    }
    
    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if ( !jQuery.support.optSelected ) {
        jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
            get: function( elem ) {
                var parent = elem.parentNode;
    
                if ( parent ) {
                    parent.selectedIndex;
    
                    // Make sure that it also works with optgroups, see #5701
                    if ( parent.parentNode ) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        });
    }
    
    // IE6/7 call enctype encoding
    if ( !jQuery.support.enctype ) {
        jQuery.propFix.enctype = "encoding";
    }
    
    // Radios and checkboxes getter/setter
    if ( !jQuery.support.checkOn ) {
        jQuery.each([ "radio", "checkbox" ], function() {
            jQuery.valHooks[ this ] = {
                get: function( elem ) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
            set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                    return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
                }
            }
        });
    });
    
    
    
    
    var rformElems = /^(?:textarea|input|select)$/i,
        rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
        rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
        quickParse = function( selector ) {
            var quick = rquickIs.exec( selector );
            if ( quick ) {
                //   0  1    2   3
                // [ _, tag, id, class ]
                quick[1] = ( quick[1] || "" ).toLowerCase();
                quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
            }
            return quick;
        },
        quickIs = function( elem, m ) {
            var attrs = elem.attributes || {};
            return (
                (!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
                (!m[2] || (attrs.id || {}).value === m[2]) &&
                (!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
            );
        },
        hoverHack = function( events ) {
            return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
        };
    
    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {
    
        add: function( elem, types, handler, data, selector ) {
    
            var elemData, eventHandle, events,
                t, tns, type, namespaces, handleObj,
                handleObjIn, quick, handlers, special;
    
            // Don't attach events to noData or text/comment nodes (allow plain objects tho)
            if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
                return;
            }
    
            // Caller can pass in an object of custom data in lieu of the handler
            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
    
            // Make sure that the handler has a unique ID, used to find/remove it later
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }
    
            // Init the element's event structure and main handler, if this is the first
            events = elemData.events;
            if ( !events ) {
                elemData.events = events = {};
            }
            eventHandle = elemData.handle;
            if ( !eventHandle ) {
                elemData.handle = eventHandle = function( e ) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
                        jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                        undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }
    
            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = jQuery.trim( hoverHack(types) ).split( " " );
            for ( t = 0; t < types.length; t++ ) {
    
                tns = rtypenamespace.exec( types[t] ) || [];
                type = tns[1];
                namespaces = ( tns[2] || "" ).split( "." ).sort();
    
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};
    
                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;
    
                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};
    
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: tns[1],
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    quick: selector && quickParse( selector ),
                    namespace: namespaces.join(".")
                }, handleObjIn );
    
                // Init the event handler queue if we're the first
                handlers = events[ type ];
                if ( !handlers ) {
                    handlers = events[ type ] = [];
                    handlers.delegateCount = 0;
    
                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                        // Bind the global event handler to the element
                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle, false );
    
                        } else if ( elem.attachEvent ) {
                            elem.attachEvent( "on" + type, eventHandle );
                        }
                    }
                }
    
                if ( special.add ) {
                    special.add.call( elem, handleObj );
    
                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
    
                // Add to the element's handler list, delegates in front
                if ( selector ) {
                    handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                    handlers.push( handleObj );
                }
    
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
            }
    
            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },
    
        global: {},
    
        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {
    
            var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
                t, tns, type, origType, namespaces, origCount,
                j, events, special, handle, eventType, handleObj;
    
            if ( !elemData || !(events = elemData.events) ) {
                return;
            }
    
            // Once for each type.namespace in types; type may be omitted
            types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
            for ( t = 0; t < types.length; t++ ) {
                tns = rtypenamespace.exec( types[t] ) || [];
                type = origType = tns[1];
                namespaces = tns[2];
    
                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                    for ( type in events ) {
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                    }
                    continue;
                }
    
                special = jQuery.event.special[ type ] || {};
                type = ( selector? special.delegateType : special.bindType ) || type;
                eventType = events[ type ] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
    
                // Remove matching events
                for ( j = 0; j < eventType.length; j++ ) {
                    handleObj = eventType[ j ];
    
                    if ( ( mappedTypes || origType === handleObj.origType ) &&
                         ( !handler || handler.guid === handleObj.guid ) &&
                         ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
                         ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                        eventType.splice( j--, 1 );
    
                        if ( handleObj.selector ) {
                            eventType.delegateCount--;
                        }
                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }
                }
    
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( eventType.length === 0 && origCount !== eventType.length ) {
                    if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
                        jQuery.removeEvent( elem, type, elemData.handle );
                    }
    
                    delete events[ type ];
                }
            }
    
            // Remove the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                handle = elemData.handle;
                if ( handle ) {
                    handle.elem = null;
                }
    
                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery.removeData( elem, [ "events", "handle" ], true );
            }
        },
    
        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },
    
        trigger: function( event, data, elem, onlyHandlers ) {
            // Don't do events on text and comment nodes
            if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
                return;
            }
    
            // Event object or event type
            var type = event.type || event,
                namespaces = [],
                cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;
    
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
            }
    
            if ( type.indexOf( "!" ) >= 0 ) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }
    
            if ( type.indexOf( "." ) >= 0 ) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
    
            if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }
    
            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
                // jQuery.Event object
                event[ jQuery.expando ] ? event :
                // Object literal
                new jQuery.Event( type, event ) :
                // Just the event type (string)
                new jQuery.Event( type );
    
            event.type = type;
            event.isTrigger = true;
            event.exclusive = exclusive;
            event.namespace = namespaces.join( "." );
            event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
            ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";
    
            // Handle a global trigger
            if ( !elem ) {
    
                // TODO: Stop taunting the data cache; remove global events and always attach to document
                cache = jQuery.cache;
                for ( i in cache ) {
                    if ( cache[ i ].events && cache[ i ].events[ type ] ) {
                        jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
                    }
                }
                return;
            }
    
            // Clean up the event in case it is being reused
            event.result = undefined;
            if ( !event.target ) {
                event.target = elem;
            }
    
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray( data ) : [];
            data.unshift( event );
    
            // Allow special events to draw outside the lines
            special = jQuery.event.special[ type ] || {};
            if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
                return;
            }
    
            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            eventPath = [[ elem, special.bindType || type ]];
            if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
    
                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
                old = null;
                for ( ; cur; cur = cur.parentNode ) {
                    eventPath.push([ cur, bubbleType ]);
                    old = cur;
                }
    
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( old && old === elem.ownerDocument ) {
                    eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
                }
            }
    
            // Fire handlers on the event path
            for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {
    
                cur = eventPath[i][0];
                event.type = eventPath[i][1];
    
                handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
                if ( handle ) {
                    handle.apply( cur, data );
                }
                // Note that this is a bare JS function and not a jQuery handler
                handle = ontype && cur[ ontype ];
                if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
                    event.preventDefault();
                }
            }
            event.type = type;
    
            // If nobody prevented the default action, do it now
            if ( !onlyHandlers && !event.isDefaultPrevented() ) {
    
                if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
                    !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
    
                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    // IE<9 dies on focus/blur to hidden element (#1486)
                    if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {
    
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        old = elem[ ontype ];
    
                        if ( old ) {
                            elem[ ontype ] = null;
                        }
    
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[ type ]();
                        jQuery.event.triggered = undefined;
    
                        if ( old ) {
                            elem[ ontype ] = old;
                        }
                    }
                }
            }
    
            return event.result;
        },
    
        dispatch: function( event ) {
    
            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix( event || window.event );
    
            var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
                delegateCount = handlers.delegateCount,
                args = [].slice.call( arguments, 0 ),
                run_all = !event.exclusive && !event.namespace,
                special = jQuery.event.special[ event.type ] || {},
                handlerQueue = [],
                i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;
    
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;
    
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                return;
            }
    
            // Determine handlers that should run if there are delegated events
            // Avoid non-left-click bubbling in Firefox (#3861)
            if ( delegateCount && !(event.button && event.type === "click") ) {
    
                // Pregenerate a single jQuery object for reuse with .is()
                jqcur = jQuery(this);
                jqcur.context = this.ownerDocument || this;
    
                for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
    
                    // Don't process events on disabled elements (#6911, #8165)
                    if ( cur.disabled !== true ) {
                        selMatch = {};
                        matches = [];
                        jqcur[0] = cur;
                        for ( i = 0; i < delegateCount; i++ ) {
                            handleObj = handlers[ i ];
                            sel = handleObj.selector;
    
                            if ( selMatch[ sel ] === undefined ) {
                                selMatch[ sel ] = (
                                    handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
                                );
                            }
                            if ( selMatch[ sel ] ) {
                                matches.push( handleObj );
                            }
                        }
                        if ( matches.length ) {
                            handlerQueue.push({ elem: cur, matches: matches });
                        }
                    }
                }
            }
    
            // Add the remaining (directly-bound) handlers
            if ( handlers.length > delegateCount ) {
                handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
            }
    
            // Run delegates first; they may want to stop propagation beneath us
            for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
                matched = handlerQueue[ i ];
                event.currentTarget = matched.elem;
    
                for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
                    handleObj = matched.matches[ j ];
    
                    // Triggered event must either 1) be non-exclusive and have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {
    
                        event.data = handleObj.data;
                        event.handleObj = handleObj;
    
                        ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                                .apply( matched.elem, args );
    
                        if ( ret !== undefined ) {
                            event.result = ret;
                            if ( ret === false ) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
    
            // Call the postDispatch hook for the mapped type
            if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
            }
    
            return event.result;
        },
    
        // Includes some event props shared by KeyEvent and MouseEvent
        // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    
        fixHooks: {},
    
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function( event, original ) {
    
                // Add which for key events
                if ( event.which == null ) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
    
                return event;
            }
        },
    
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function( event, original ) {
                var eventDoc, doc, body,
                    button = original.button,
                    fromElement = original.fromElement;
    
                // Calculate pageX/Y if missing and clientX/Y available
                if ( event.pageX == null && original.clientX != null ) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
    
                    event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                    event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                }
    
                // Add relatedTarget, if necessary
                if ( !event.relatedTarget && fromElement ) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }
    
                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if ( !event.which && button !== undefined ) {
                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                }
    
                return event;
            }
        },
    
        fix: function( event ) {
            if ( event[ jQuery.expando ] ) {
                return event;
            }
    
            // Create a writable copy of the event object and normalize some properties
            var i, prop,
                originalEvent = event,
                fixHook = jQuery.event.fixHooks[ event.type ] || {},
                copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
    
            event = jQuery.Event( originalEvent );
    
            for ( i = copy.length; i; ) {
                prop = copy[ --i ];
                event[ prop ] = originalEvent[ prop ];
            }
    
            // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
            if ( !event.target ) {
                event.target = originalEvent.srcElement || document;
            }
    
            // Target should not be a text node (#504, Safari)
            if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
            }
    
            // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
            if ( event.metaKey === undefined ) {
                event.metaKey = event.ctrlKey;
            }
    
            return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
        },
    
        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady
            },
    
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
    
            focus: {
                delegateType: "focusin"
            },
            blur: {
                delegateType: "focusout"
            },
    
            beforeunload: {
                setup: function( data, namespaces, eventHandle ) {
                    // We only want to do this special case on windows
                    if ( jQuery.isWindow( this ) ) {
                        this.onbeforeunload = eventHandle;
                    }
                },
    
                teardown: function( namespaces, eventHandle ) {
                    if ( this.onbeforeunload === eventHandle ) {
                        this.onbeforeunload = null;
                    }
                }
            }
        },
    
        simulate: function( type, elem, event, bubble ) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                { type: type,
                    isSimulated: true,
                    originalEvent: {}
                }
            );
            if ( bubble ) {
                jQuery.event.trigger( e, null, elem );
            } else {
                jQuery.event.dispatch.call( elem, e );
            }
            if ( e.isDefaultPrevented() ) {
                event.preventDefault();
            }
        }
    };
    
    // Some plugins are using, but it's undocumented/deprecated and will be removed.
    // The 1.7 special event interface should provide all the hooks needed now.
    jQuery.event.handle = jQuery.event.dispatch;
    
    jQuery.removeEvent = document.removeEventListener ?
        function( elem, type, handle ) {
            if ( elem.removeEventListener ) {
                elem.removeEventListener( type, handle, false );
            }
        } :
        function( elem, type, handle ) {
            if ( elem.detachEvent ) {
                elem.detachEvent( "on" + type, handle );
            }
        };
    
    jQuery.Event = function( src, props ) {
        // Allow instantiation without the 'new' keyword
        if ( !(this instanceof jQuery.Event) ) {
            return new jQuery.Event( src, props );
        }
    
        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;
    
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
                src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
    
        // Event type
        } else {
            this.type = src;
        }
    
        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }
    
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();
    
        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };
    
    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }
    
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function() {
            this.isDefaultPrevented = returnTrue;
    
            var e = this.originalEvent;
            if ( !e ) {
                return;
            }
    
            // if preventDefault exists run it on the original event
            if ( e.preventDefault ) {
                e.preventDefault();
    
            // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function() {
            this.isPropagationStopped = returnTrue;
    
            var e = this.originalEvent;
            if ( !e ) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if ( e.stopPropagation ) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };
    
    // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            delegateType: fix,
            bindType: fix,
    
            handle: function( event ) {
                var target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj,
                    selector = handleObj.selector,
                    ret;
    
                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply( this, arguments );
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    
    // IE submit delegation
    if ( !jQuery.support.submitBubbles ) {
    
        jQuery.event.special.submit = {
            setup: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, "form" ) ) {
                    return false;
                }
    
                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target,
                        form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                    if ( form && !form._submit_attached ) {
                        jQuery.event.add( form, "submit._submit", function( event ) {
                            event._submit_bubble = true;
                        });
                        form._submit_attached = true;
                    }
                });
                // return undefined since we don't need an event listener
            },
            
            postDispatch: function( event ) {
                // If form was submitted by the user, bubble the event up the tree
                if ( event._submit_bubble ) {
                    delete event._submit_bubble;
                    if ( this.parentNode && !event.isTrigger ) {
                        jQuery.event.simulate( "submit", this.parentNode, event, true );
                    }
                }
            },
    
            teardown: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, "form" ) ) {
                    return false;
                }
    
                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove( this, "._submit" );
            }
        };
    }
    
    // IE change delegation and checkbox/radio fix
    if ( !jQuery.support.changeBubbles ) {
    
        jQuery.event.special.change = {
    
            setup: function() {
    
                if ( rformElems.test( this.nodeName ) ) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if ( this.type === "checkbox" || this.type === "radio" ) {
                        jQuery.event.add( this, "propertychange._change", function( event ) {
                            if ( event.originalEvent.propertyName === "checked" ) {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add( this, "click._change", function( event ) {
                            if ( this._just_changed && !event.isTrigger ) {
                                this._just_changed = false;
                                jQuery.event.simulate( "change", this, event, true );
                            }
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add( this, "beforeactivate._change", function( e ) {
                    var elem = e.target;
    
                    if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
                        jQuery.event.add( elem, "change._change", function( event ) {
                            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                                jQuery.event.simulate( "change", this.parentNode, event, true );
                            }
                        });
                        elem._change_attached = true;
                    }
                });
            },
    
            handle: function( event ) {
                var elem = event.target;
    
                // Swallow native change events from checkbox/radio, we already triggered them above
                if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                    return event.handleObj.handler.apply( this, arguments );
                }
            },
    
            teardown: function() {
                jQuery.event.remove( this, "._change" );
    
                return rformElems.test( this.nodeName );
            }
        };
    }
    
    // Create "bubbling" focus and blur events
    if ( !jQuery.support.focusinBubbles ) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
    
            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0,
                handler = function( event ) {
                    jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
                };
    
            jQuery.event.special[ fix ] = {
                setup: function() {
                    if ( attaches++ === 0 ) {
                        document.addEventListener( orig, handler, true );
                    }
                },
                teardown: function() {
                    if ( --attaches === 0 ) {
                        document.removeEventListener( orig, handler, true );
                    }
                }
            };
        });
    }
    
    jQuery.fn.extend({
    
        on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
            var origFn, type;
    
            // Types can be a map of types/handlers
            if ( typeof types === "object" ) {
                // ( types-Object, selector, data )
                if ( typeof selector !== "string" ) { // && selector != null
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for ( type in types ) {
                    this.on( type, selector, data, types[ type ], one );
                }
                return this;
            }
    
            if ( data == null && fn == null ) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if ( fn == null ) {
                if ( typeof selector === "string" ) {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if ( fn === false ) {
                fn = returnFalse;
            } else if ( !fn ) {
                return this;
            }
    
            if ( one === 1 ) {
                origFn = fn;
                fn = function( event ) {
                    // Can use an empty set, since event contains the info
                    jQuery().off( event );
                    return origFn.apply( this, arguments );
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
            }
            return this.each( function() {
                jQuery.event.add( this, types, fn, data, selector );
            });
        },
        one: function( types, selector, data, fn ) {
            return this.on( types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
            if ( types && types.preventDefault && types.handleObj ) {
                // ( event )  dispatched jQuery.Event
                var handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                    handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if ( typeof types === "object" ) {
                // ( types-object [, selector] )
                for ( var type in types ) {
                    this.off( type, selector, types[ type ] );
                }
                return this;
            }
            if ( selector === false || typeof selector === "function" ) {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if ( fn === false ) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove( this, types, fn, selector );
            });
        },
    
        bind: function( types, data, fn ) {
            return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
            return this.off( types, null, fn );
        },
    
        live: function( types, data, fn ) {
            jQuery( this.context ).on( types, this.selector, data, fn );
            return this;
        },
        die: function( types, fn ) {
            jQuery( this.context ).off( types, this.selector || "**", fn );
            return this;
        },
    
        delegate: function( selector, types, data, fn ) {
            return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
        },
    
        trigger: function( type, data ) {
            return this.each(function() {
                jQuery.event.trigger( type, data, this );
            });
        },
        triggerHandler: function( type, data ) {
            if ( this[0] ) {
                return jQuery.event.trigger( type, data, this[0], true );
            }
        },
    
        toggle: function( fn ) {
            // Save reference to arguments for access in closure
            var args = arguments,
                guid = fn.guid || jQuery.guid++,
                i = 0,
                toggler = function( event ) {
                    // Figure out which function to execute
                    var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
                    jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
    
                    // Make sure that clicks stop
                    event.preventDefault();
    
                    // and execute the function
                    return args[ lastToggle ].apply( this, arguments ) || false;
                };
    
            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while ( i < args.length ) {
                args[ i++ ].guid = guid;
            }
    
            return this.click( toggler );
        },
    
        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        }
    });
    
    jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
    
        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
            if ( fn == null ) {
                fn = data;
                data = null;
            }
    
            return arguments.length > 0 ?
                this.on( name, null, data, fn ) :
                this.trigger( name );
        };
    
        if ( jQuery.attrFn ) {
            jQuery.attrFn[ name ] = true;
        }
    
        if ( rkeyEvent.test( name ) ) {
            jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
        }
    
        if ( rmouseEvent.test( name ) ) {
            jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
        }
    });
    
    
    
    /*!
     * Sizzle CSS Selector Engine
     *  Copyright 2011, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
    (function(){
    
    var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
        expando = "sizcache" + (Math.random() + '').replace('.', ''),
        done = 0,
        toString = Object.prototype.toString,
        hasDuplicate = false,
        baseHasDuplicate = true,
        rBackslash = /\\/g,
        rReturn = /\r\n/g,
        rNonWord = /\W/;
    
    // Here we check if the JavaScript engine is using some sort of
    // optimization where it does not always call our comparision
    // function. If that is the case, discard the hasDuplicate value.
    //   Thus far that includes Google Chrome.
    [0, 0].sort(function() {
        baseHasDuplicate = false;
        return 0;
    });
    
    var Sizzle = function( selector, context, results, seed ) {
        results = results || [];
        context = context || document;
    
        var origContext = context;
    
        if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
            return [];
        }
    
        if ( !selector || typeof selector !== "string" ) {
            return results;
        }
    
        var m, set, checkSet, extra, ret, cur, pop, i,
            prune = true,
            contextXML = Sizzle.isXML( context ),
            parts = [],
            soFar = selector;
    
        // Reset the position of the chunker regexp (start from head)
        do {
            chunker.exec( "" );
            m = chunker.exec( soFar );
    
            if ( m ) {
                soFar = m[3];
    
                parts.push( m[1] );
    
                if ( m[2] ) {
                    extra = m[3];
                    break;
                }
            }
        } while ( m );
    
        if ( parts.length > 1 && origPOS.exec( selector ) ) {
    
            if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
                set = posProcess( parts[0] + parts[1], context, seed );
    
            } else {
                set = Expr.relative[ parts[0] ] ?
                    [ context ] :
                    Sizzle( parts.shift(), context );
    
                while ( parts.length ) {
                    selector = parts.shift();
    
                    if ( Expr.relative[ selector ] ) {
                        selector += parts.shift();
                    }
    
                    set = posProcess( selector, set, seed );
                }
            }
    
        } else {
            // Take a shortcut and set the context if the root selector is an ID
            // (but not if it'll be faster if the inner selector is an ID)
            if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
                    Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
    
                ret = Sizzle.find( parts.shift(), context, contextXML );
                context = ret.expr ?
                    Sizzle.filter( ret.expr, ret.set )[0] :
                    ret.set[0];
            }
    
            if ( context ) {
                ret = seed ?
                    { expr: parts.pop(), set: makeArray(seed) } :
                    Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
    
                set = ret.expr ?
                    Sizzle.filter( ret.expr, ret.set ) :
                    ret.set;
    
                if ( parts.length > 0 ) {
                    checkSet = makeArray( set );
    
                } else {
                    prune = false;
                }
    
                while ( parts.length ) {
                    cur = parts.pop();
                    pop = cur;
    
                    if ( !Expr.relative[ cur ] ) {
                        cur = "";
                    } else {
                        pop = parts.pop();
                    }
    
                    if ( pop == null ) {
                        pop = context;
                    }
    
                    Expr.relative[ cur ]( checkSet, pop, contextXML );
                }
    
            } else {
                checkSet = parts = [];
            }
        }
    
        if ( !checkSet ) {
            checkSet = set;
        }
    
        if ( !checkSet ) {
            Sizzle.error( cur || selector );
        }
    
        if ( toString.call(checkSet) === "[object Array]" ) {
            if ( !prune ) {
                results.push.apply( results, checkSet );
    
            } else if ( context && context.nodeType === 1 ) {
                for ( i = 0; checkSet[i] != null; i++ ) {
                    if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
                        results.push( set[i] );
                    }
                }
    
            } else {
                for ( i = 0; checkSet[i] != null; i++ ) {
                    if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
                        results.push( set[i] );
                    }
                }
            }
    
        } else {
            makeArray( checkSet, results );
        }
    
        if ( extra ) {
            Sizzle( extra, origContext, results, seed );
            Sizzle.uniqueSort( results );
        }
    
        return results;
    };
    
    Sizzle.uniqueSort = function( results ) {
        if ( sortOrder ) {
            hasDuplicate = baseHasDuplicate;
            results.sort( sortOrder );
    
            if ( hasDuplicate ) {
                for ( var i = 1; i < results.length; i++ ) {
                    if ( results[i] === results[ i - 1 ] ) {
                        results.splice( i--, 1 );
                    }
                }
            }
        }
    
        return results;
    };
    
    Sizzle.matches = function( expr, set ) {
        return Sizzle( expr, null, null, set );
    };
    
    Sizzle.matchesSelector = function( node, expr ) {
        return Sizzle( expr, null, null, [node] ).length > 0;
    };
    
    Sizzle.find = function( expr, context, isXML ) {
        var set, i, len, match, type, left;
    
        if ( !expr ) {
            return [];
        }
    
        for ( i = 0, len = Expr.order.length; i < len; i++ ) {
            type = Expr.order[i];
    
            if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
                left = match[1];
                match.splice( 1, 1 );
    
                if ( left.substr( left.length - 1 ) !== "\\" ) {
                    match[1] = (match[1] || "").replace( rBackslash, "" );
                    set = Expr.find[ type ]( match, context, isXML );
    
                    if ( set != null ) {
                        expr = expr.replace( Expr.match[ type ], "" );
                        break;
                    }
                }
            }
        }
    
        if ( !set ) {
            set = typeof context.getElementsByTagName !== "undefined" ?
                context.getElementsByTagName( "*" ) :
                [];
        }
    
        return { set: set, expr: expr };
    };
    
    Sizzle.filter = function( expr, set, inplace, not ) {
        var match, anyFound,
            type, found, item, filter, left,
            i, pass,
            old = expr,
            result = [],
            curLoop = set,
            isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );
    
        while ( expr && set.length ) {
            for ( type in Expr.filter ) {
                if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
                    filter = Expr.filter[ type ];
                    left = match[1];
    
                    anyFound = false;
    
                    match.splice(1,1);
    
                    if ( left.substr( left.length - 1 ) === "\\" ) {
                        continue;
                    }
    
                    if ( curLoop === result ) {
                        result = [];
                    }
    
                    if ( Expr.preFilter[ type ] ) {
                        match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
    
                        if ( !match ) {
                            anyFound = found = true;
    
                        } else if ( match === true ) {
                            continue;
                        }
                    }
    
                    if ( match ) {
                        for ( i = 0; (item = curLoop[i]) != null; i++ ) {
                            if ( item ) {
                                found = filter( item, match, i, curLoop );
                                pass = not ^ found;
    
                                if ( inplace && found != null ) {
                                    if ( pass ) {
                                        anyFound = true;
    
                                    } else {
                                        curLoop[i] = false;
                                    }
    
                                } else if ( pass ) {
                                    result.push( item );
                                    anyFound = true;
                                }
                            }
                        }
                    }
    
                    if ( found !== undefined ) {
                        if ( !inplace ) {
                            curLoop = result;
                        }
    
                        expr = expr.replace( Expr.match[ type ], "" );
    
                        if ( !anyFound ) {
                            return [];
                        }
    
                        break;
                    }
                }
            }
    
            // Improper expression
            if ( expr === old ) {
                if ( anyFound == null ) {
                    Sizzle.error( expr );
    
                } else {
                    break;
                }
            }
    
            old = expr;
        }
    
        return curLoop;
    };
    
    Sizzle.error = function( msg ) {
        throw new Error( "Syntax error, unrecognized expression: " + msg );
    };
    
    /**
     * Utility function for retreiving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    var getText = Sizzle.getText = function( elem ) {
        var i, node,
            nodeType = elem.nodeType,
            ret = "";
    
        if ( nodeType ) {
            if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                // Use textContent || innerText for elements
                if ( typeof elem.textContent === 'string' ) {
                    return elem.textContent;
                } else if ( typeof elem.innerText === 'string' ) {
                    // Replace IE's carriage returns
                    return elem.innerText.replace( rReturn, '' );
                } else {
                    // Traverse it's children
                    for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText( elem );
                    }
                }
            } else if ( nodeType === 3 || nodeType === 4 ) {
                return elem.nodeValue;
            }
        } else {
    
            // If no nodeType, this is expected to be an array
            for ( i = 0; (node = elem[i]); i++ ) {
                // Do not traverse comment nodes
                if ( node.nodeType !== 8 ) {
                    ret += getText( node );
                }
            }
        }
        return ret;
    };
    
    var Expr = Sizzle.selectors = {
        order: [ "ID", "NAME", "TAG" ],
    
        match: {
            ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
            CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
            NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
            ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
            TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
            CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
            POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
            PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
        },
    
        leftMatch: {},
    
        attrMap: {
            "class": "className",
            "for": "htmlFor"
        },
    
        attrHandle: {
            href: function( elem ) {
                return elem.getAttribute( "href" );
            },
            type: function( elem ) {
                return elem.getAttribute( "type" );
            }
        },
    
        relative: {
            "+": function(checkSet, part){
                var isPartStr = typeof part === "string",
                    isTag = isPartStr && !rNonWord.test( part ),
                    isPartStrNotTag = isPartStr && !isTag;
    
                if ( isTag ) {
                    part = part.toLowerCase();
                }
    
                for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
                    if ( (elem = checkSet[i]) ) {
                        while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
    
                        checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
                            elem || false :
                            elem === part;
                    }
                }
    
                if ( isPartStrNotTag ) {
                    Sizzle.filter( part, checkSet, true );
                }
            },
    
            ">": function( checkSet, part ) {
                var elem,
                    isPartStr = typeof part === "string",
                    i = 0,
                    l = checkSet.length;
    
                if ( isPartStr && !rNonWord.test( part ) ) {
                    part = part.toLowerCase();
    
                    for ( ; i < l; i++ ) {
                        elem = checkSet[i];
    
                        if ( elem ) {
                            var parent = elem.parentNode;
                            checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                        }
                    }
    
                } else {
                    for ( ; i < l; i++ ) {
                        elem = checkSet[i];
    
                        if ( elem ) {
                            checkSet[i] = isPartStr ?
                                elem.parentNode :
                                elem.parentNode === part;
                        }
                    }
    
                    if ( isPartStr ) {
                        Sizzle.filter( part, checkSet, true );
                    }
                }
            },
    
            "": function(checkSet, part, isXML){
                var nodeCheck,
                    doneName = done++,
                    checkFn = dirCheck;
    
                if ( typeof part === "string" && !rNonWord.test( part ) ) {
                    part = part.toLowerCase();
                    nodeCheck = part;
                    checkFn = dirNodeCheck;
                }
    
                checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
            },
    
            "~": function( checkSet, part, isXML ) {
                var nodeCheck,
                    doneName = done++,
                    checkFn = dirCheck;
    
                if ( typeof part === "string" && !rNonWord.test( part ) ) {
                    part = part.toLowerCase();
                    nodeCheck = part;
                    checkFn = dirNodeCheck;
                }
    
                checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
            }
        },
    
        find: {
            ID: function( match, context, isXML ) {
                if ( typeof context.getElementById !== "undefined" && !isXML ) {
                    var m = context.getElementById(match[1]);
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    return m && m.parentNode ? [m] : [];
                }
            },
    
            NAME: function( match, context ) {
                if ( typeof context.getElementsByName !== "undefined" ) {
                    var ret = [],
                        results = context.getElementsByName( match[1] );
    
                    for ( var i = 0, l = results.length; i < l; i++ ) {
                        if ( results[i].getAttribute("name") === match[1] ) {
                            ret.push( results[i] );
                        }
                    }
    
                    return ret.length === 0 ? null : ret;
                }
            },
    
            TAG: function( match, context ) {
                if ( typeof context.getElementsByTagName !== "undefined" ) {
                    return context.getElementsByTagName( match[1] );
                }
            }
        },
        preFilter: {
            CLASS: function( match, curLoop, inplace, result, not, isXML ) {
                match = " " + match[1].replace( rBackslash, "" ) + " ";
    
                if ( isXML ) {
                    return match;
                }
    
                for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
                    if ( elem ) {
                        if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
                            if ( !inplace ) {
                                result.push( elem );
                            }
    
                        } else if ( inplace ) {
                            curLoop[i] = false;
                        }
                    }
                }
    
                return false;
            },
    
            ID: function( match ) {
                return match[1].replace( rBackslash, "" );
            },
    
            TAG: function( match, curLoop ) {
                return match[1].replace( rBackslash, "" ).toLowerCase();
            },
    
            CHILD: function( match ) {
                if ( match[1] === "nth" ) {
                    if ( !match[2] ) {
                        Sizzle.error( match[0] );
                    }
    
                    match[2] = match[2].replace(/^\+|\s*/g, '');
    
                    // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                    var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
                        match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
                        !/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
    
                    // calculate the numbers (first)n+(last) including if they are negative
                    match[2] = (test[1] + (test[2] || 1)) - 0;
                    match[3] = test[3] - 0;
                }
                else if ( match[2] ) {
                    Sizzle.error( match[0] );
                }
    
                // TODO: Move to normal caching system
                match[0] = done++;
    
                return match;
            },
    
            ATTR: function( match, curLoop, inplace, result, not, isXML ) {
                var name = match[1] = match[1].replace( rBackslash, "" );
    
                if ( !isXML && Expr.attrMap[name] ) {
                    match[1] = Expr.attrMap[name];
                }
    
                // Handle if an un-quoted value was used
                match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );
    
                if ( match[2] === "~=" ) {
                    match[4] = " " + match[4] + " ";
                }
    
                return match;
            },
    
            PSEUDO: function( match, curLoop, inplace, result, not ) {
                if ( match[1] === "not" ) {
                    // If we're dealing with a complex expression, or a simple one
                    if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
                        match[3] = Sizzle(match[3], null, null, curLoop);
    
                    } else {
                        var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
    
                        if ( !inplace ) {
                            result.push.apply( result, ret );
                        }
    
                        return false;
                    }
    
                } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
                    return true;
                }
    
                return match;
            },
    
            POS: function( match ) {
                match.unshift( true );
    
                return match;
            }
        },
    
        filters: {
            enabled: function( elem ) {
                return elem.disabled === false && elem.type !== "hidden";
            },
    
            disabled: function( elem ) {
                return elem.disabled === true;
            },
    
            checked: function( elem ) {
                return elem.checked === true;
            },
    
            selected: function( elem ) {
                // Accessing this property makes selected-by-default
                // options in Safari work properly
                if ( elem.parentNode ) {
                    elem.parentNode.selectedIndex;
                }
    
                return elem.selected === true;
            },
    
            parent: function( elem ) {
                return !!elem.firstChild;
            },
    
            empty: function( elem ) {
                return !elem.firstChild;
            },
    
            has: function( elem, i, match ) {
                return !!Sizzle( match[3], elem ).length;
            },
    
            header: function( elem ) {
                return (/h\d/i).test( elem.nodeName );
            },
    
            text: function( elem ) {
                var attr = elem.getAttribute( "type" ), type = elem.type;
                // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                // use getAttribute instead to test this case
                return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
            },
    
            radio: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
            },
    
            checkbox: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
            },
    
            file: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
            },
    
            password: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
            },
    
            submit: function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && "submit" === elem.type;
            },
    
            image: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
            },
    
            reset: function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && "reset" === elem.type;
            },
    
            button: function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && "button" === elem.type || name === "button";
            },
    
            input: function( elem ) {
                return (/input|select|textarea|button/i).test( elem.nodeName );
            },
    
            focus: function( elem ) {
                return elem === elem.ownerDocument.activeElement;
            }
        },
        setFilters: {
            first: function( elem, i ) {
                return i === 0;
            },
    
            last: function( elem, i, match, array ) {
                return i === array.length - 1;
            },
    
            even: function( elem, i ) {
                return i % 2 === 0;
            },
    
            odd: function( elem, i ) {
                return i % 2 === 1;
            },
    
            lt: function( elem, i, match ) {
                return i < match[3] - 0;
            },
    
            gt: function( elem, i, match ) {
                return i > match[3] - 0;
            },
    
            nth: function( elem, i, match ) {
                return match[3] - 0 === i;
            },
    
            eq: function( elem, i, match ) {
                return match[3] - 0 === i;
            }
        },
        filter: {
            PSEUDO: function( elem, match, i, array ) {
                var name = match[1],
                    filter = Expr.filters[ name ];
    
                if ( filter ) {
                    return filter( elem, i, match, array );
    
                } else if ( name === "contains" ) {
                    return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;
    
                } else if ( name === "not" ) {
                    var not = match[3];
    
                    for ( var j = 0, l = not.length; j < l; j++ ) {
                        if ( not[j] === elem ) {
                            return false;
                        }
                    }
    
                    return true;
    
                } else {
                    Sizzle.error( name );
                }
            },
    
            CHILD: function( elem, match ) {
                var first, last,
                    doneName, parent, cache,
                    count, diff,
                    type = match[1],
                    node = elem;
    
                switch ( type ) {
                    case "only":
                    case "first":
                        while ( (node = node.previousSibling) ) {
                            if ( node.nodeType === 1 ) {
                                return false;
                            }
                        }
    
                        if ( type === "first" ) {
                            return true;
                        }
    
                        node = elem;
    
                        /* falls through */
                    case "last":
                        while ( (node = node.nextSibling) ) {
                            if ( node.nodeType === 1 ) {
                                return false;
                            }
                        }
    
                        return true;
    
                    case "nth":
                        first = match[2];
                        last = match[3];
    
                        if ( first === 1 && last === 0 ) {
                            return true;
                        }
    
                        doneName = match[0];
                        parent = elem.parentNode;
    
                        if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
                            count = 0;
    
                            for ( node = parent.firstChild; node; node = node.nextSibling ) {
                                if ( node.nodeType === 1 ) {
                                    node.nodeIndex = ++count;
                                }
                            }
    
                            parent[ expando ] = doneName;
                        }
    
                        diff = elem.nodeIndex - last;
    
                        if ( first === 0 ) {
                            return diff === 0;
    
                        } else {
                            return ( diff % first === 0 && diff / first >= 0 );
                        }
                }
            },
    
            ID: function( elem, match ) {
                return elem.nodeType === 1 && elem.getAttribute("id") === match;
            },
    
            TAG: function( elem, match ) {
                return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
            },
    
            CLASS: function( elem, match ) {
                return (" " + (elem.className || elem.getAttribute("class")) + " ")
                    .indexOf( match ) > -1;
            },
    
            ATTR: function( elem, match ) {
                var name = match[1],
                    result = Sizzle.attr ?
                        Sizzle.attr( elem, name ) :
                        Expr.attrHandle[ name ] ?
                        Expr.attrHandle[ name ]( elem ) :
                        elem[ name ] != null ?
                            elem[ name ] :
                            elem.getAttribute( name ),
                    value = result + "",
                    type = match[2],
                    check = match[4];
    
                return result == null ?
                    type === "!=" :
                    !type && Sizzle.attr ?
                    result != null :
                    type === "=" ?
                    value === check :
                    type === "*=" ?
                    value.indexOf(check) >= 0 :
                    type === "~=" ?
                    (" " + value + " ").indexOf(check) >= 0 :
                    !check ?
                    value && result !== false :
                    type === "!=" ?
                    value !== check :
                    type === "^=" ?
                    value.indexOf(check) === 0 :
                    type === "$=" ?
                    value.substr(value.length - check.length) === check :
                    type === "|=" ?
                    value === check || value.substr(0, check.length + 1) === check + "-" :
                    false;
            },
    
            POS: function( elem, match, i, array ) {
                var name = match[2],
                    filter = Expr.setFilters[ name ];
    
                if ( filter ) {
                    return filter( elem, i, match, array );
                }
            }
        }
    };
    
    var origPOS = Expr.match.POS,
        fescape = function(all, num){
            return "\\" + (num - 0 + 1);
        };
    
    for ( var type in Expr.match ) {
        Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
        Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
    }
    // Expose origPOS
    // "global" as in regardless of relation to brackets/parens
    Expr.match.globalPOS = origPOS;
    
    var makeArray = function( array, results ) {
        array = Array.prototype.slice.call( array, 0 );
    
        if ( results ) {
            results.push.apply( results, array );
            return results;
        }
    
        return array;
    };
    
    // Perform a simple check to determine if the browser is capable of
    // converting a NodeList to an array using builtin methods.
    // Also verifies that the returned array holds DOM nodes
    // (which is not the case in the Blackberry browser)
    try {
        Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
    
    // Provide a fallback method if it does not work
    } catch( e ) {
        makeArray = function( array, results ) {
            var i = 0,
                ret = results || [];
    
            if ( toString.call(array) === "[object Array]" ) {
                Array.prototype.push.apply( ret, array );
    
            } else {
                if ( typeof array.length === "number" ) {
                    for ( var l = array.length; i < l; i++ ) {
                        ret.push( array[i] );
                    }
    
                } else {
                    for ( ; array[i]; i++ ) {
                        ret.push( array[i] );
                    }
                }
            }
    
            return ret;
        };
    }
    
    var sortOrder, siblingCheck;
    
    if ( document.documentElement.compareDocumentPosition ) {
        sortOrder = function( a, b ) {
            if ( a === b ) {
                hasDuplicate = true;
                return 0;
            }
    
            if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
                return a.compareDocumentPosition ? -1 : 1;
            }
    
            return a.compareDocumentPosition(b) & 4 ? -1 : 1;
        };
    
    } else {
        sortOrder = function( a, b ) {
            // The nodes are identical, we can exit early
            if ( a === b ) {
                hasDuplicate = true;
                return 0;
    
            // Fallback to using sourceIndex (in IE) if it's available on both nodes
            } else if ( a.sourceIndex && b.sourceIndex ) {
                return a.sourceIndex - b.sourceIndex;
            }
    
            var al, bl,
                ap = [],
                bp = [],
                aup = a.parentNode,
                bup = b.parentNode,
                cur = aup;
    
            // If the nodes are siblings (or identical) we can do a quick check
            if ( aup === bup ) {
                return siblingCheck( a, b );
    
            // If no parents were found then the nodes are disconnected
            } else if ( !aup ) {
                return -1;
    
            } else if ( !bup ) {
                return 1;
            }
    
            // Otherwise they're somewhere else in the tree so we need
            // to build up a full list of the parentNodes for comparison
            while ( cur ) {
                ap.unshift( cur );
                cur = cur.parentNode;
            }
    
            cur = bup;
    
            while ( cur ) {
                bp.unshift( cur );
                cur = cur.parentNode;
            }
    
            al = ap.length;
            bl = bp.length;
    
            // Start walking down the tree looking for a discrepancy
            for ( var i = 0; i < al && i < bl; i++ ) {
                if ( ap[i] !== bp[i] ) {
                    return siblingCheck( ap[i], bp[i] );
                }
            }
    
            // We ended someplace up the tree so do a sibling check
            return i === al ?
                siblingCheck( a, bp[i], -1 ) :
                siblingCheck( ap[i], b, 1 );
        };
    
        siblingCheck = function( a, b, ret ) {
            if ( a === b ) {
                return ret;
            }
    
            var cur = a.nextSibling;
    
            while ( cur ) {
                if ( cur === b ) {
                    return -1;
                }
    
                cur = cur.nextSibling;
            }
    
            return 1;
        };
    }
    
    // Check to see if the browser returns elements by name when
    // querying by getElementById (and provide a workaround)
    (function(){
        // We're going to inject a fake input element with a specified name
        var form = document.createElement("div"),
            id = "script" + (new Date()).getTime(),
            root = document.documentElement;
    
        form.innerHTML = "<a name='" + id + "'/>";
    
        // Inject it into the root element, check its status, and remove it quickly
        root.insertBefore( form, root.firstChild );
    
        // The workaround has to do additional checks after a getElementById
        // Which slows things down for other browsers (hence the branching)
        if ( document.getElementById( id ) ) {
            Expr.find.ID = function( match, context, isXML ) {
                if ( typeof context.getElementById !== "undefined" && !isXML ) {
                    var m = context.getElementById(match[1]);
    
                    return m ?
                        m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
                            [m] :
                            undefined :
                        [];
                }
            };
    
            Expr.filter.ID = function( elem, match ) {
                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
    
                return elem.nodeType === 1 && node && node.nodeValue === match;
            };
        }
    
        root.removeChild( form );
    
        // release memory in IE
        root = form = null;
    })();
    
    (function(){
        // Check to see if the browser returns only elements
        // when doing getElementsByTagName("*")
    
        // Create a fake element
        var div = document.createElement("div");
        div.appendChild( document.createComment("") );
    
        // Make sure no comments are found
        if ( div.getElementsByTagName("*").length > 0 ) {
            Expr.find.TAG = function( match, context ) {
                var results = context.getElementsByTagName( match[1] );
    
                // Filter out possible comments
                if ( match[1] === "*" ) {
                    var tmp = [];
    
                    for ( var i = 0; results[i]; i++ ) {
                        if ( results[i].nodeType === 1 ) {
                            tmp.push( results[i] );
                        }
                    }
    
                    results = tmp;
                }
    
                return results;
            };
        }
    
        // Check to see if an attribute returns normalized href attributes
        div.innerHTML = "<a href='#'></a>";
    
        if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
                div.firstChild.getAttribute("href") !== "#" ) {
    
            Expr.attrHandle.href = function( elem ) {
                return elem.getAttribute( "href", 2 );
            };
        }
    
        // release memory in IE
        div = null;
    })();
    
    if ( document.querySelectorAll ) {
        (function(){
            var oldSizzle = Sizzle,
                div = document.createElement("div"),
                id = "__sizzle__";
    
            div.innerHTML = "<p class='TEST'></p>";
    
            // Safari can't handle uppercase or unicode characters when
            // in quirks mode.
            if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
                return;
            }
    
            Sizzle = function( query, context, extra, seed ) {
                context = context || document;
    
                // Only use querySelectorAll on non-XML documents
                // (ID selectors don't work in non-HTML documents)
                if ( !seed && !Sizzle.isXML(context) ) {
                    // See if we find a selector to speed up
                    var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
    
                    if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
                        // Speed-up: Sizzle("TAG")
                        if ( match[1] ) {
                            return makeArray( context.getElementsByTagName( query ), extra );
    
                        // Speed-up: Sizzle(".CLASS")
                        } else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
                            return makeArray( context.getElementsByClassName( match[2] ), extra );
                        }
                    }
    
                    if ( context.nodeType === 9 ) {
                        // Speed-up: Sizzle("body")
                        // The body element only exists once, optimize finding it
                        if ( query === "body" && context.body ) {
                            return makeArray( [ context.body ], extra );
    
                        // Speed-up: Sizzle("#ID")
                        } else if ( match && match[3] ) {
                            var elem = context.getElementById( match[3] );
    
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if ( elem && elem.parentNode ) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if ( elem.id === match[3] ) {
                                    return makeArray( [ elem ], extra );
                                }
    
                            } else {
                                return makeArray( [], extra );
                            }
                        }
    
                        try {
                            return makeArray( context.querySelectorAll(query), extra );
                        } catch(qsaError) {}
    
                    // qSA works strangely on Element-rooted queries
                    // We can work around this by specifying an extra ID on the root
                    // and working up from there (Thanks to Andrew Dupont for the technique)
                    // IE 8 doesn't work on object elements
                    } else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                        var oldContext = context,
                            old = context.getAttribute( "id" ),
                            nid = old || id,
                            hasParent = context.parentNode,
                            relativeHierarchySelector = /^\s*[+~]/.test( query );
    
                        if ( !old ) {
                            context.setAttribute( "id", nid );
                        } else {
                            nid = nid.replace( /'/g, "\\$&" );
                        }
                        if ( relativeHierarchySelector && hasParent ) {
                            context = context.parentNode;
                        }
    
                        try {
                            if ( !relativeHierarchySelector || hasParent ) {
                                return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
                            }
    
                        } catch(pseudoError) {
                        } finally {
                            if ( !old ) {
                                oldContext.removeAttribute( "id" );
                            }
                        }
                    }
                }
    
                return oldSizzle(query, context, extra, seed);
            };
    
            for ( var prop in oldSizzle ) {
                Sizzle[ prop ] = oldSizzle[ prop ];
            }
    
            // release memory in IE
            div = null;
        })();
    }
    
    (function(){
        var html = document.documentElement,
            matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
    
        if ( matches ) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9 fails this)
            var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
                pseudoWorks = false;
    
            try {
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call( document.documentElement, "[test!='']:sizzle" );
    
            } catch( pseudoError ) {
                pseudoWorks = true;
            }
    
            Sizzle.matchesSelector = function( node, expr ) {
                // Make sure that attribute selectors are quoted
                expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
    
                if ( !Sizzle.isXML( node ) ) {
                    try {
                        if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
                            var ret = matches.call( node, expr );
    
                            // IE 9's matchesSelector returns false on disconnected nodes
                            if ( ret || !disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9, so check for that
                                    node.document && node.document.nodeType !== 11 ) {
                                return ret;
                            }
                        }
                    } catch(e) {}
                }
    
                return Sizzle(expr, null, null, [node]).length > 0;
            };
        }
    })();
    
    (function(){
        var div = document.createElement("div");
    
        div.innerHTML = "<div class='test e'></div><div class='test'></div>";
    
        // Opera can't find a second classname (in 9.6)
        // Also, make sure that getElementsByClassName actually exists
        if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
            return;
        }
    
        // Safari caches class attributes, doesn't catch changes (in 3.2)
        div.lastChild.className = "e";
    
        if ( div.getElementsByClassName("e").length === 1 ) {
            return;
        }
    
        Expr.order.splice(1, 0, "CLASS");
        Expr.find.CLASS = function( match, context, isXML ) {
            if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
                return context.getElementsByClassName(match[1]);
            }
        };
    
        // release memory in IE
        div = null;
    })();
    
    function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
        for ( var i = 0, l = checkSet.length; i < l; i++ ) {
            var elem = checkSet[i];
    
            if ( elem ) {
                var match = false;
    
                elem = elem[dir];
    
                while ( elem ) {
                    if ( elem[ expando ] === doneName ) {
                        match = checkSet[elem.sizset];
                        break;
                    }
    
                    if ( elem.nodeType === 1 && !isXML ){
                        elem[ expando ] = doneName;
                        elem.sizset = i;
                    }
    
                    if ( elem.nodeName.toLowerCase() === cur ) {
                        match = elem;
                        break;
                    }
    
                    elem = elem[dir];
                }
    
                checkSet[i] = match;
            }
        }
    }
    
    function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
        for ( var i = 0, l = checkSet.length; i < l; i++ ) {
            var elem = checkSet[i];
    
            if ( elem ) {
                var match = false;
    
                elem = elem[dir];
    
                while ( elem ) {
                    if ( elem[ expando ] === doneName ) {
                        match = checkSet[elem.sizset];
                        break;
                    }
    
                    if ( elem.nodeType === 1 ) {
                        if ( !isXML ) {
                            elem[ expando ] = doneName;
                            elem.sizset = i;
                        }
    
                        if ( typeof cur !== "string" ) {
                            if ( elem === cur ) {
                                match = true;
                                break;
                            }
    
                        } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
                            match = elem;
                            break;
                        }
                    }
    
                    elem = elem[dir];
                }
    
                checkSet[i] = match;
            }
        }
    }
    
    if ( document.documentElement.contains ) {
        Sizzle.contains = function( a, b ) {
            return a !== b && (a.contains ? a.contains(b) : true);
        };
    
    } else if ( document.documentElement.compareDocumentPosition ) {
        Sizzle.contains = function( a, b ) {
            return !!(a.compareDocumentPosition(b) & 16);
        };
    
    } else {
        Sizzle.contains = function() {
            return false;
        };
    }
    
    Sizzle.isXML = function( elem ) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
    
        return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    
    var posProcess = function( selector, context, seed ) {
        var match,
            tmpSet = [],
            later = "",
            root = context.nodeType ? [context] : context;
    
        // Position selectors must be done after the filter
        // And so must :not(positional) so we move all PSEUDOs to the end
        while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
            later += match[0];
            selector = selector.replace( Expr.match.PSEUDO, "" );
        }
    
        selector = Expr.relative[selector] ? selector + "*" : selector;
    
        for ( var i = 0, l = root.length; i < l; i++ ) {
            Sizzle( selector, root[i], tmpSet, seed );
        }
    
        return Sizzle.filter( later, tmpSet );
    };
    
    // EXPOSE
    // Override sizzle attribute retrieval
    Sizzle.attr = jQuery.attr;
    Sizzle.selectors.attrMap = {};
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.filters;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    
    
    })();
    
    
    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prevUntil|prevAll)/,
        // Note: This RegExp should be improved, or likely pulled from Sizzle
        rmultiselector = /,/,
        isSimple = /^.[^:#\[\.,]*$/,
        slice = Array.prototype.slice,
        POS = jQuery.expr.match.globalPOS,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    
    jQuery.fn.extend({
        find: function( selector ) {
            var self = this,
                i, l;
    
            if ( typeof selector !== "string" ) {
                return jQuery( selector ).filter(function() {
                    for ( i = 0, l = self.length; i < l; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                });
            }
    
            var ret = this.pushStack( "", "find", selector ),
                length, n, r;
    
            for ( i = 0, l = this.length; i < l; i++ ) {
                length = ret.length;
                jQuery.find( selector, this[i], ret );
    
                if ( i > 0 ) {
                    // Make sure that the results are unique
                    for ( n = length; n < ret.length; n++ ) {
                        for ( r = 0; r < length; r++ ) {
                            if ( ret[r] === ret[n] ) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }
    
            return ret;
        },
    
        has: function( target ) {
            var targets = jQuery( target );
            return this.filter(function() {
                for ( var i = 0, l = targets.length; i < l; i++ ) {
                    if ( jQuery.contains( this, targets[i] ) ) {
                        return true;
                    }
                }
            });
        },
    
        not: function( selector ) {
            return this.pushStack( winnow(this, selector, false), "not", selector);
        },
    
        filter: function( selector ) {
            return this.pushStack( winnow(this, selector, true), "filter", selector );
        },
    
        is: function( selector ) {
            return !!selector && (
                typeof selector === "string" ?
                    // If this is a positional selector, check membership in the returned set
                    // so $("p:first").is("p:last") won't return true for a doc with two "p".
                    POS.test( selector ) ?
                        jQuery( selector, this.context ).index( this[0] ) >= 0 :
                        jQuery.filter( selector, this ).length > 0 :
                    this.filter( selector ).length > 0 );
        },
    
        closest: function( selectors, context ) {
            var ret = [], i, l, cur = this[0];
    
            // Array (deprecated as of jQuery 1.7)
            if ( jQuery.isArray( selectors ) ) {
                var level = 1;
    
                while ( cur && cur.ownerDocument && cur !== context ) {
                    for ( i = 0; i < selectors.length; i++ ) {
    
                        if ( jQuery( cur ).is( selectors[ i ] ) ) {
                            ret.push({ selector: selectors[ i ], elem: cur, level: level });
                        }
                    }
    
                    cur = cur.parentNode;
                    level++;
                }
    
                return ret;
            }
    
            // String
            var pos = POS.test( selectors ) || typeof selectors !== "string" ?
                    jQuery( selectors, context || this.context ) :
                    0;
    
            for ( i = 0, l = this.length; i < l; i++ ) {
                cur = this[i];
    
                while ( cur ) {
                    if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
                        ret.push( cur );
                        break;
    
                    } else {
                        cur = cur.parentNode;
                        if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
                            break;
                        }
                    }
                }
            }
    
            ret = ret.length > 1 ? jQuery.unique( ret ) : ret;
    
            return this.pushStack( ret, "closest", selectors );
        },
    
        // Determine the position of an element within
        // the matched set of elements
        index: function( elem ) {
    
            // No argument, return index in parent
            if ( !elem ) {
                return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
            }
    
            // index in selector
            if ( typeof elem === "string" ) {
                return jQuery.inArray( this[0], jQuery( elem ) );
            }
    
            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this );
        },
    
        add: function( selector, context ) {
            var set = typeof selector === "string" ?
                    jQuery( selector, context ) :
                    jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
                all = jQuery.merge( this.get(), set );
    
            return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
                all :
                jQuery.unique( all ) );
        },
    
        andSelf: function() {
            return this.add( this.prevObject );
        }
    });
    
    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected( node ) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }
    
    jQuery.each({
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return jQuery.dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return jQuery.nth( elem, 2, "nextSibling" );
        },
        prev: function( elem ) {
            return jQuery.nth( elem, 2, "previousSibling" );
        },
        nextAll: function( elem ) {
            return jQuery.dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return jQuery.dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
            return jQuery.sibling( elem.firstChild );
        },
        contents: function( elem ) {
            return jQuery.nodeName( elem, "iframe" ) ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.makeArray( elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var ret = jQuery.map( this, fn, until );
    
            if ( !runtil.test( name ) ) {
                selector = until;
            }
    
            if ( selector && typeof selector === "string" ) {
                ret = jQuery.filter( selector, ret );
            }
    
            ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
    
            if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
                ret = ret.reverse();
            }
    
            return this.pushStack( ret, name, slice.call( arguments ).join(",") );
        };
    });
    
    jQuery.extend({
        filter: function( expr, elems, not ) {
            if ( not ) {
                expr = ":not(" + expr + ")";
            }
    
            return elems.length === 1 ?
                jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
                jQuery.find.matches(expr, elems);
        },
    
        dir: function( elem, dir, until ) {
            var matched = [],
                cur = elem[ dir ];
    
            while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                if ( cur.nodeType === 1 ) {
                    matched.push( cur );
                }
                cur = cur[dir];
            }
            return matched;
        },
    
        nth: function( cur, result, dir, elem ) {
            result = result || 1;
            var num = 0;
    
            for ( ; cur; cur = cur[dir] ) {
                if ( cur.nodeType === 1 && ++num === result ) {
                    break;
                }
            }
    
            return cur;
        },
    
        sibling: function( n, elem ) {
            var r = [];
    
            for ( ; n; n = n.nextSibling ) {
                if ( n.nodeType === 1 && n !== elem ) {
                    r.push( n );
                }
            }
    
            return r;
        }
    });
    
    // Implement the identical functionality for filter and not
    function winnow( elements, qualifier, keep ) {
    
        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;
    
        if ( jQuery.isFunction( qualifier ) ) {
            return jQuery.grep(elements, function( elem, i ) {
                var retVal = !!qualifier.call( elem, i, elem );
                return retVal === keep;
            });
    
        } else if ( qualifier.nodeType ) {
            return jQuery.grep(elements, function( elem, i ) {
                return ( elem === qualifier ) === keep;
            });
    
        } else if ( typeof qualifier === "string" ) {
            var filtered = jQuery.grep(elements, function( elem ) {
                return elem.nodeType === 1;
            });
    
            if ( isSimple.test( qualifier ) ) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter( qualifier, filtered );
            }
        }
    
        return jQuery.grep(elements, function( elem, i ) {
            return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
        });
    }
    
    
    
    
    function createSafeFragment( document ) {
        var list = nodeNames.split( "|" ),
        safeFrag = document.createDocumentFragment();
    
        if ( safeFrag.createElement ) {
            while ( list.length ) {
                safeFrag.createElement(
                    list.pop()
                );
            }
        }
        return safeFrag;
    }
    
    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
            "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
        rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style)/i,
        rnocache = /<(?:script|object|embed|option|style)/i,
        rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /\/(java|ecma)script/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
        wrapMap = {
            option: [ 1, "<select multiple='multiple'>", "</select>" ],
            legend: [ 1, "<fieldset>", "</fieldset>" ],
            thead: [ 1, "<table>", "</table>" ],
            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
            td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
            col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
            area: [ 1, "<map>", "</map>" ],
            _default: [ 0, "", "" ]
        },
        safeFragment = createSafeFragment( document );
    
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    
    // IE can't serialize <link> and <script> tags normally
    if ( !jQuery.support.htmlSerialize ) {
        wrapMap._default = [ 1, "div<div>", "</div>" ];
    }
    
    jQuery.fn.extend({
        text: function( value ) {
            return jQuery.access( this, function( value ) {
                return value === undefined ?
                    jQuery.text( this ) :
                    this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
            }, null, value, arguments.length );
        },
    
        wrapAll: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapAll( html.call(this, i) );
                });
            }
    
            if ( this[0] ) {
                // The elements to wrap the target around
                var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
    
                if ( this[0].parentNode ) {
                    wrap.insertBefore( this[0] );
                }
    
                wrap.map(function() {
                    var elem = this;
    
                    while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                        elem = elem.firstChild;
                    }
    
                    return elem;
                }).append( this );
            }
    
            return this;
        },
    
        wrapInner: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapInner( html.call(this, i) );
                });
            }
    
            return this.each(function() {
                var self = jQuery( this ),
                    contents = self.contents();
    
                if ( contents.length ) {
                    contents.wrapAll( html );
    
                } else {
                    self.append( html );
                }
            });
        },
    
        wrap: function( html ) {
            var isFunction = jQuery.isFunction( html );
    
            return this.each(function(i) {
                jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
            });
        },
    
        unwrap: function() {
            return this.parent().each(function() {
                if ( !jQuery.nodeName( this, "body" ) ) {
                    jQuery( this ).replaceWith( this.childNodes );
                }
            }).end();
        },
    
        append: function() {
            return this.domManip(arguments, true, function( elem ) {
                if ( this.nodeType === 1 ) {
                    this.appendChild( elem );
                }
            });
        },
    
        prepend: function() {
            return this.domManip(arguments, true, function( elem ) {
                if ( this.nodeType === 1 ) {
                    this.insertBefore( elem, this.firstChild );
                }
            });
        },
    
        before: function() {
            if ( this[0] && this[0].parentNode ) {
                return this.domManip(arguments, false, function( elem ) {
                    this.parentNode.insertBefore( elem, this );
                });
            } else if ( arguments.length ) {
                var set = jQuery.clean( arguments );
                set.push.apply( set, this.toArray() );
                return this.pushStack( set, "before", arguments );
            }
        },
    
        after: function() {
            if ( this[0] && this[0].parentNode ) {
                return this.domManip(arguments, false, function( elem ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                });
            } else if ( arguments.length ) {
                var set = this.pushStack( this, "after", arguments );
                set.push.apply( set, jQuery.clean(arguments) );
                return set;
            }
        },
    
        // keepData is for internal use only--do not document
        remove: function( selector, keepData ) {
            for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
                    if ( !keepData && elem.nodeType === 1 ) {
                        jQuery.cleanData( elem.getElementsByTagName("*") );
                        jQuery.cleanData( [ elem ] );
                    }
    
                    if ( elem.parentNode ) {
                        elem.parentNode.removeChild( elem );
                    }
                }
            }
    
            return this;
        },
    
        empty: function() {
            for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                // Remove element nodes and prevent memory leaks
                if ( elem.nodeType === 1 ) {
                    jQuery.cleanData( elem.getElementsByTagName("*") );
                }
    
                // Remove any remaining nodes
                while ( elem.firstChild ) {
                    elem.removeChild( elem.firstChild );
                }
            }
    
            return this;
        },
    
        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
    
            return this.map( function () {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            });
        },
    
        html: function( value ) {
            return jQuery.access( this, function( value ) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;
    
                if ( value === undefined ) {
                    return elem.nodeType === 1 ?
                        elem.innerHTML.replace( rinlinejQuery, "" ) :
                        null;
                }
    
    
                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                    ( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                    !wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {
    
                    value = value.replace( rxhtmlTag, "<$1></$2>" );
    
                    try {
                        for (; i < l; i++ ) {
                            // Remove element nodes and prevent memory leaks
                            elem = this[i] || {};
                            if ( elem.nodeType === 1 ) {
                                jQuery.cleanData( elem.getElementsByTagName( "*" ) );
                                elem.innerHTML = value;
                            }
                        }
    
                        elem = 0;
    
                    // If using innerHTML throws an exception, use the fallback method
                    } catch(e) {}
                }
    
                if ( elem ) {
                    this.empty().append( value );
                }
            }, null, value, arguments.length );
        },
    
        replaceWith: function( value ) {
            if ( this[0] && this[0].parentNode ) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if ( jQuery.isFunction( value ) ) {
                    return this.each(function(i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith( value.call( this, i, old ) );
                    });
                }
    
                if ( typeof value !== "string" ) {
                    value = jQuery( value ).detach();
                }
    
                return this.each(function() {
                    var next = this.nextSibling,
                        parent = this.parentNode;
    
                    jQuery( this ).remove();
    
                    if ( next ) {
                        jQuery(next).before( value );
                    } else {
                        jQuery(parent).append( value );
                    }
                });
            } else {
                return this.length ?
                    this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
                    this;
            }
        },
    
        detach: function( selector ) {
            return this.remove( selector, true );
        },
    
        domManip: function( args, table, callback ) {
            var results, first, fragment, parent,
                value = args[0],
                scripts = [];
    
            // We can't cloneNode fragments that contain checked, in WebKit
            if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
                return this.each(function() {
                    jQuery(this).domManip( args, table, callback, true );
                });
            }
    
            if ( jQuery.isFunction(value) ) {
                return this.each(function(i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip( args, table, callback );
                });
            }
    
            if ( this[0] ) {
                parent = value && value.parentNode;
    
                // If we're in a fragment, just use that instead of building a new one
                if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
                    results = { fragment: parent };
    
                } else {
                    results = jQuery.buildFragment( args, this, scripts );
                }
    
                fragment = results.fragment;
    
                if ( fragment.childNodes.length === 1 ) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }
    
                if ( first ) {
                    table = table && jQuery.nodeName( first, "tr" );
    
                    for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
                        callback.call(
                            table ?
                                root(this[i], first) :
                                this[i],
                            // Make sure that we do not leak memory by inadvertently discarding
                            // the original fragment (which might have attached data) instead of
                            // using it; in addition, use the original fragment object for the last
                            // item instead of first because it can end up being emptied incorrectly
                            // in certain situations (Bug #8070).
                            // Fragments from the fragment cache must always be cloned and never used
                            // in place.
                            results.cacheable || ( l > 1 && i < lastIndex ) ?
                                jQuery.clone( fragment, true, true ) :
                                fragment
                        );
                    }
                }
    
                if ( scripts.length ) {
                    jQuery.each( scripts, function( i, elem ) {
                        if ( elem.src ) {
                            jQuery.ajax({
                                type: "GET",
                                global: false,
                                url: elem.src,
                                async: false,
                                dataType: "script"
                            });
                        } else {
                            jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
                        }
    
                        if ( elem.parentNode ) {
                            elem.parentNode.removeChild( elem );
                        }
                    });
                }
            }
    
            return this;
        }
    });
    
    function root( elem, cur ) {
        return jQuery.nodeName(elem, "table") ?
            (elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
            elem;
    }
    
    function cloneCopyEvent( src, dest ) {
    
        if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
            return;
        }
    
        var type, i, l,
            oldData = jQuery._data( src ),
            curData = jQuery._data( dest, oldData ),
            events = oldData.events;
    
        if ( events ) {
            delete curData.handle;
            curData.events = {};
    
            for ( type in events ) {
                for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                    jQuery.event.add( dest, type, events[ type ][ i ] );
                }
            }
        }
    
        // make the cloned public data object a copy from the original
        if ( curData.data ) {
            curData.data = jQuery.extend( {}, curData.data );
        }
    }
    
    function cloneFixAttributes( src, dest ) {
        var nodeName;
    
        // We do not need to do anything for non-Elements
        if ( dest.nodeType !== 1 ) {
            return;
        }
    
        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if ( dest.clearAttributes ) {
            dest.clearAttributes();
        }
    
        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if ( dest.mergeAttributes ) {
            dest.mergeAttributes( src );
        }
    
        nodeName = dest.nodeName.toLowerCase();
    
        // IE6-8 fail to clone children inside object elements that use
        // the proprietary classid attribute value (rather than the type
        // attribute) to identify the type of content to display
        if ( nodeName === "object" ) {
            dest.outerHTML = src.outerHTML;
    
        } else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            if ( src.checked ) {
                dest.defaultChecked = dest.checked = src.checked;
            }
    
            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if ( dest.value !== src.value ) {
                dest.value = src.value;
            }
    
        // IE6-8 fails to return the selected option to the default selected
        // state when cloning options
        } else if ( nodeName === "option" ) {
            dest.selected = src.defaultSelected;
    
        // IE6-8 fails to set the defaultValue to the correct value when
        // cloning other types of input fields
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;
    
        // IE blanks contents when cloning scripts
        } else if ( nodeName === "script" && dest.text !== src.text ) {
            dest.text = src.text;
        }
    
        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute( jQuery.expando );
    
        // Clear flags for bubbling special change/submit events, they must
        // be reattached when the newly cloned events are first activated
        dest.removeAttribute( "_submit_attached" );
        dest.removeAttribute( "_change_attached" );
    }
    
    jQuery.buildFragment = function( args, nodes, scripts ) {
        var fragment, cacheable, cacheresults, doc,
        first = args[ 0 ];
    
        // nodes may contain either an explicit document object,
        // a jQuery collection or context object.
        // If nodes[0] contains a valid object to assign to doc
        if ( nodes && nodes[0] ) {
            doc = nodes[0].ownerDocument || nodes[0];
        }
    
        // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if ( !doc.createDocumentFragment ) {
            doc = document;
        }
    
        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
        if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
            first.charAt(0) === "<" && !rnocache.test( first ) &&
            (jQuery.support.checkClone || !rchecked.test( first )) &&
            (jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {
    
            cacheable = true;
    
            cacheresults = jQuery.fragments[ first ];
            if ( cacheresults && cacheresults !== 1 ) {
                fragment = cacheresults;
            }
        }
    
        if ( !fragment ) {
            fragment = doc.createDocumentFragment();
            jQuery.clean( args, doc, fragment, scripts );
        }
    
        if ( cacheable ) {
            jQuery.fragments[ first ] = cacheresults ? fragment : 1;
        }
    
        return { fragment: fragment, cacheable: cacheable };
    };
    
    jQuery.fragments = {};
    
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var ret = [],
                insert = jQuery( selector ),
                parent = this.length === 1 && this[0].parentNode;
    
            if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
                insert[ original ]( this[0] );
                return this;
    
            } else {
                for ( var i = 0, l = insert.length; i < l; i++ ) {
                    var elems = ( i > 0 ? this.clone(true) : this ).get();
                    jQuery( insert[i] )[ original ]( elems );
                    ret = ret.concat( elems );
                }
    
                return this.pushStack( ret, name, insert.selector );
            }
        };
    });
    
    function getAll( elem ) {
        if ( typeof elem.getElementsByTagName !== "undefined" ) {
            return elem.getElementsByTagName( "*" );
    
        } else if ( typeof elem.querySelectorAll !== "undefined" ) {
            return elem.querySelectorAll( "*" );
    
        } else {
            return [];
        }
    }
    
    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked( elem ) {
        if ( elem.type === "checkbox" || elem.type === "radio" ) {
            elem.defaultChecked = elem.checked;
        }
    }
    // Finds all inputs and passes them to fixDefaultChecked
    function findInputs( elem ) {
        var nodeName = ( elem.nodeName || "" ).toLowerCase();
        if ( nodeName === "input" ) {
            fixDefaultChecked( elem );
        // Skip scripts, get other children
        } else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
            jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
        }
    }
    
    // Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
    function shimCloneNode( elem ) {
        var div = document.createElement( "div" );
        safeFragment.appendChild( div );
    
        div.innerHTML = elem.outerHTML;
        return div.firstChild;
    }
    
    jQuery.extend({
        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var srcElements,
                destElements,
                i,
                // IE<=8 does not properly clone detached, unknown element nodes
                clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
                    elem.cloneNode( true ) :
                    shimCloneNode( elem );
    
            if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
                    (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.
    
                cloneFixAttributes( elem, clone );
    
                // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
                srcElements = getAll( elem );
                destElements = getAll( clone );
    
                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for ( i = 0; srcElements[i]; ++i ) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if ( destElements[i] ) {
                        cloneFixAttributes( srcElements[i], destElements[i] );
                    }
                }
            }
    
            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                cloneCopyEvent( elem, clone );
    
                if ( deepDataAndEvents ) {
                    srcElements = getAll( elem );
                    destElements = getAll( clone );
    
                    for ( i = 0; srcElements[i]; ++i ) {
                        cloneCopyEvent( srcElements[i], destElements[i] );
                    }
                }
            }
    
            srcElements = destElements = null;
    
            // Return the cloned set
            return clone;
        },
    
        clean: function( elems, context, fragment, scripts ) {
            var checkScriptType, script, j,
                    ret = [];
    
            context = context || document;
    
            // !context.createElement fails in IE with an error but returns typeof 'object'
            if ( typeof context.createElement === "undefined" ) {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }
    
            for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                if ( typeof elem === "number" ) {
                    elem += "";
                }
    
                if ( !elem ) {
                    continue;
                }
    
                // Convert html string into DOM nodes
                if ( typeof elem === "string" ) {
                    if ( !rhtml.test( elem ) ) {
                        elem = context.createTextNode( elem );
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");
    
                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
                            wrap = wrapMap[ tag ] || wrapMap._default,
                            depth = wrap[0],
                            div = context.createElement("div"),
                            safeChildNodes = safeFragment.childNodes,
                            remove;
    
                        // Append wrapper element to unknown element safe doc fragment
                        if ( context === document ) {
                            // Use the fragment we've already created for this document
                            safeFragment.appendChild( div );
                        } else {
                            // Use a fragment created with the owner document
                            createSafeFragment( context ).appendChild( div );
                        }
    
                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];
    
                        // Move to the right depth
                        while ( depth-- ) {
                            div = div.lastChild;
                        }
    
                        // Remove IE's autoinserted <tbody> from table fragments
                        if ( !jQuery.support.tbody ) {
    
                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
                                tbody = tag === "table" && !hasBody ?
                                    div.firstChild && div.firstChild.childNodes :
    
                                    // String was a bare <thead> or <tfoot>
                                    wrap[1] === "<table>" && !hasBody ?
                                        div.childNodes :
                                        [];
    
                            for ( j = tbody.length - 1; j >= 0 ; --j ) {
                                if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                                    tbody[ j ].parentNode.removeChild( tbody[ j ] );
                                }
                            }
                        }
    
                        // IE completely kills leading whitespace when innerHTML is used
                        if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                            div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
                        }
    
                        elem = div.childNodes;
    
                        // Clear elements from DocumentFragment (safeFragment or otherwise)
                        // to avoid hoarding elements. Fixes #11356
                        if ( div ) {
                            div.parentNode.removeChild( div );
    
                            // Guard against -1 index exceptions in FF3.6
                            if ( safeChildNodes.length > 0 ) {
                                remove = safeChildNodes[ safeChildNodes.length - 1 ];
    
                                if ( remove && remove.parentNode ) {
                                    remove.parentNode.removeChild( remove );
                                }
                            }
                        }
                    }
                }
    
                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if ( !jQuery.support.appendChecked ) {
                    if ( elem[0] && typeof (len = elem.length) === "number" ) {
                        for ( j = 0; j < len; j++ ) {
                            findInputs( elem[j] );
                        }
                    } else {
                        findInputs( elem );
                    }
                }
    
                if ( elem.nodeType ) {
                    ret.push( elem );
                } else {
                    ret = jQuery.merge( ret, elem );
                }
            }
    
            if ( fragment ) {
                checkScriptType = function( elem ) {
                    return !elem.type || rscriptType.test( elem.type );
                };
                for ( i = 0; ret[i]; i++ ) {
                    script = ret[i];
                    if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
                        scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );
    
                    } else {
                        if ( script.nodeType === 1 ) {
                            var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );
    
                            ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
                        }
                        fragment.appendChild( script );
                    }
                }
            }
    
            return ret;
        },
    
        cleanData: function( elems ) {
            var data, id,
                cache = jQuery.cache,
                special = jQuery.event.special,
                deleteExpando = jQuery.support.deleteExpando;
    
            for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
                    continue;
                }
    
                id = elem[ jQuery.expando ];
    
                if ( id ) {
                    data = cache[ id ];
    
                    if ( data && data.events ) {
                        for ( var type in data.events ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );
    
                            // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }
    
                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if ( data.handle ) {
                            data.handle.elem = null;
                        }
                    }
    
                    if ( deleteExpando ) {
                        delete elem[ jQuery.expando ];
    
                    } else if ( elem.removeAttribute ) {
                        elem.removeAttribute( jQuery.expando );
                    }
    
                    delete cache[ id ];
                }
            }
        }
    });
    
    
    
    
    var ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        // fixed for IE9, see #8346
        rupper = /([A-Z]|^ms)/g,
        rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
        rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
        rrelNum = /^([\-+])=([\-+.\de]+)/,
        rmargin = /^margin/,
    
        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    
        // order is important!
        cssExpand = [ "Top", "Right", "Bottom", "Left" ],
    
        curCSS,
    
        getComputedStyle,
        currentStyle;
    
    jQuery.fn.css = function( name, value ) {
        return jQuery.access( this, function( elem, name, value ) {
            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        }, name, value, arguments.length > 1 );
    };
    
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {
                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity" );
                        return ret === "" ? "1" : ret;
    
                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },
    
        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
    
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },
    
        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {
            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }
    
            // Make sure that we're working with the right name
            var ret, type, origName = jQuery.camelCase( name ),
                style = elem.style, hooks = jQuery.cssHooks[ origName ];
    
            name = jQuery.cssProps[ origName ] || origName;
    
            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;
    
                // convert relative number strings (+= or -=) to relative numbers. #7345
                if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                    value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
                    // Fixes bug #9237
                    type = "number";
                }
    
                // Make sure that NaN and null values aren't set. See: #7116
                if ( value == null || type === "number" && isNaN( value ) ) {
                    return;
                }
    
                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                    value += "px";
                }
    
                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[ name ] = value;
                    } catch(e) {}
                }
    
            } else {
                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                    return ret;
                }
    
                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },
    
        css: function( elem, name, extra ) {
            var ret, hooks;
    
            // Make sure that we're working with the right name
            name = jQuery.camelCase( name );
            hooks = jQuery.cssHooks[ name ];
            name = jQuery.cssProps[ name ] || name;
    
            // cssFloat needs a special treatment
            if ( name === "cssFloat" ) {
                name = "float";
            }
    
            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
                return ret;
    
            // Otherwise, if a way to get the computed value exists, use that
            } else if ( curCSS ) {
                return curCSS( elem, name );
            }
        },
    
        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function( elem, options, callback ) {
            var old = {},
                ret, name;
    
            // Remember the old values, and insert the new ones
            for ( name in options ) {
                old[ name ] = elem.style[ name ];
                elem.style[ name ] = options[ name ];
            }
    
            ret = callback.call( elem );
    
            // Revert the old values
            for ( name in options ) {
                elem.style[ name ] = old[ name ];
            }
    
            return ret;
        }
    });
    
    // DEPRECATED in 1.3, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;
    
    if ( document.defaultView && document.defaultView.getComputedStyle ) {
        getComputedStyle = function( elem, name ) {
            var ret, defaultView, computedStyle, width,
                style = elem.style;
    
            name = name.replace( rupper, "-$1" ).toLowerCase();
    
            if ( (defaultView = elem.ownerDocument.defaultView) &&
                    (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
    
                ret = computedStyle.getPropertyValue( name );
                if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
                    ret = jQuery.style( elem, name );
                }
            }
    
            // A tribute to the "awesome hack by Dean Edwards"
            // WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
            // which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
                width = style.width;
                style.width = ret;
                ret = computedStyle.width;
                style.width = width;
            }
    
            return ret;
        };
    }
    
    if ( document.documentElement.currentStyle ) {
        currentStyle = function( elem, name ) {
            var left, rsLeft, uncomputed,
                ret = elem.currentStyle && elem.currentStyle[ name ],
                style = elem.style;
    
            // Avoid setting ret to empty string here
            // so we don't default to auto
            if ( ret == null && style && (uncomputed = style[ name ]) ) {
                ret = uncomputed;
            }
    
            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
    
            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if ( rnumnonpx.test( ret ) ) {
    
                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
    
                // Put in the new values to get a computed value out
                if ( rsLeft ) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";
    
                // Revert the changed values
                style.left = left;
                if ( rsLeft ) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }
    
            return ret === "" ? "auto" : ret;
        };
    }
    
    curCSS = getComputedStyle || currentStyle;
    
    function getWidthOrHeight( elem, name, extra ) {
    
        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            i = name === "width" ? 1 : 0,
            len = 4;
    
        if ( val > 0 ) {
            if ( extra !== "border" ) {
                for ( ; i < len; i += 2 ) {
                    if ( !extra ) {
                        val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
                    }
                    if ( extra === "margin" ) {
                        val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
                    } else {
                        val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
                    }
                }
            }
    
            return val + "px";
        }
    
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name );
        if ( val < 0 || val == null ) {
            val = elem.style[ name ];
        }
    
        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
            return val;
        }
    
        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;
    
        // Add padding, border, margin
        if ( extra ) {
            for ( ; i < len; i += 2 ) {
                val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
                if ( extra !== "padding" ) {
                    val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
                }
                if ( extra === "margin" ) {
                    val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
                }
            }
        }
    
        return val + "px";
    }
    
    jQuery.each([ "height", "width" ], function( i, name ) {
        jQuery.cssHooks[ name ] = {
            get: function( elem, computed, extra ) {
                if ( computed ) {
                    if ( elem.offsetWidth !== 0 ) {
                        return getWidthOrHeight( elem, name, extra );
                    } else {
                        return jQuery.swap( elem, cssShow, function() {
                            return getWidthOrHeight( elem, name, extra );
                        });
                    }
                }
            },
    
            set: function( elem, value ) {
                return rnum.test( value ) ?
                    value + "px" :
                    value;
            }
        };
    });
    
    if ( !jQuery.support.opacity ) {
        jQuery.cssHooks.opacity = {
            get: function( elem, computed ) {
                // IE uses filters for opacity
                return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                    ( parseFloat( RegExp.$1 ) / 100 ) + "" :
                    computed ? "1" : "";
            },
    
            set: function( elem, value ) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                    filter = currentStyle && currentStyle.filter || style.filter || "";
    
                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;
    
                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {
    
                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute( "filter" );
    
                    // if there there is no filter style applied in a css rule, we are done
                    if ( currentStyle && !currentStyle.filter ) {
                        return;
                    }
                }
    
                // otherwise, set new filter values
                style.filter = ralpha.test( filter ) ?
                    filter.replace( ralpha, opacity ) :
                    filter + " " + opacity;
            }
        };
    }
    
    jQuery(function() {
        // This hook cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        if ( !jQuery.support.reliableMarginRight ) {
            jQuery.cssHooks.marginRight = {
                get: function( elem, computed ) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    return jQuery.swap( elem, { "display": "inline-block" }, function() {
                        if ( computed ) {
                            return curCSS( elem, "margin-right" );
                        } else {
                            return elem.style.marginRight;
                        }
                    });
                }
            };
        }
    });
    
    if ( jQuery.expr && jQuery.expr.filters ) {
        jQuery.expr.filters.hidden = function( elem ) {
            var width = elem.offsetWidth,
                height = elem.offsetHeight;
    
            return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
        };
    
        jQuery.expr.filters.visible = function( elem ) {
            return !jQuery.expr.filters.hidden( elem );
        };
    }
    
    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function( prefix, suffix ) {
    
        jQuery.cssHooks[ prefix + suffix ] = {
            expand: function( value ) {
                var i,
    
                    // assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [ value ],
                    expanded = {};
    
                for ( i = 0; i < 4; i++ ) {
                    expanded[ prefix + cssExpand[ i ] + suffix ] =
                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }
    
                return expanded;
            }
        };
    });
    
    
    
    
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
        rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rselectTextarea = /^(?:select|textarea)/i,
        rspacesAjax = /\s+/,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
    
        // Keep a copy of the old load method
        _load = jQuery.fn.load,
    
        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},
    
        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},
    
        // Document location
        ajaxLocation,
    
        // Document location segments
        ajaxLocParts,
    
        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = ["*/"] + ["*"];
    
    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch( e ) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }
    
    // Segment location into parts
    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
    
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {
    
        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {
    
            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
    
            if ( jQuery.isFunction( func ) ) {
                var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
                    i = 0,
                    length = dataTypes.length,
                    dataType,
                    list,
                    placeBefore;
    
                // For each dataType in the dataTypeExpression
                for ( ; i < length; i++ ) {
                    dataType = dataTypes[ i ];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test( dataType );
                    if ( placeBefore ) {
                        dataType = dataType.substr( 1 ) || "*";
                    }
                    list = structure[ dataType ] = structure[ dataType ] || [];
                    // then we add to the structure accordingly
                    list[ placeBefore ? "unshift" : "push" ]( func );
                }
            }
        };
    }
    
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
            dataType /* internal */, inspected /* internal */ ) {
    
        dataType = dataType || options.dataTypes[ 0 ];
        inspected = inspected || {};
    
        inspected[ dataType ] = true;
    
        var list = structure[ dataType ],
            i = 0,
            length = list ? list.length : 0,
            executeOnly = ( structure === prefilters ),
            selection;
    
        for ( ; i < length && ( executeOnly || !selection ); i++ ) {
            selection = list[ i ]( options, originalOptions, jqXHR );
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if ( typeof selection === "string" ) {
                if ( !executeOnly || inspected[ selection ] ) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift( selection );
                    selection = inspectPrefiltersOrTransports(
                            structure, options, originalOptions, jqXHR, selection, inspected );
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
            selection = inspectPrefiltersOrTransports(
                    structure, options, originalOptions, jqXHR, "*", inspected );
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }
    
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }
    }
    
    jQuery.fn.extend({
        load: function( url, params, callback ) {
            if ( typeof url !== "string" && _load ) {
                return _load.apply( this, arguments );
    
            // Don't do a request if no elements are being requested
            } else if ( !this.length ) {
                return this;
            }
    
            var off = url.indexOf( " " );
            if ( off >= 0 ) {
                var selector = url.slice( off, url.length );
                url = url.slice( 0, off );
            }
    
            // Default to a GET request
            var type = "GET";
    
            // If the second parameter was provided
            if ( params ) {
                // If it's a function
                if ( jQuery.isFunction( params ) ) {
                    // We assume that it's the callback
                    callback = params;
                    params = undefined;
    
                // Otherwise, build a param string
                } else if ( typeof params === "object" ) {
                    params = jQuery.param( params, jQuery.ajaxSettings.traditional );
                    type = "POST";
                }
            }
    
            var self = this;
    
            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function( jqXHR, status, responseText ) {
                    // Store the response as specified by the jqXHR object
                    responseText = jqXHR.responseText;
                    // If successful, inject the HTML into all the matched elements
                    if ( jqXHR.isResolved() ) {
                        // #4825: Get the actual response in case
                        // a dataFilter is present in ajaxSettings
                        jqXHR.done(function( r ) {
                            responseText = r;
                        });
                        // See if a selector was specified
                        self.html( selector ?
                            // Create a dummy div to hold the results
                            jQuery("<div>")
                                // inject the contents of the document in, removing the scripts
                                // to avoid any 'Permission Denied' errors in IE
                                .append(responseText.replace(rscript, ""))
    
                                // Locate the specified elements
                                .find(selector) :
    
                            // If not, just inject the full result
                            responseText );
                    }
    
                    if ( callback ) {
                        self.each( callback, [ responseText, status, jqXHR ] );
                    }
                }
            });
    
            return this;
        },
    
        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },
    
        serializeArray: function() {
            return this.map(function(){
                return this.elements ? jQuery.makeArray( this.elements ) : this;
            })
            .filter(function(){
                return this.name && !this.disabled &&
                    ( this.checked || rselectTextarea.test( this.nodeName ) ||
                        rinput.test( this.type ) );
            })
            .map(function( i, elem ){
                var val = jQuery( this ).val();
    
                return val == null ?
                    null :
                    jQuery.isArray( val ) ?
                        jQuery.map( val, function( val, i ){
                            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                        }) :
                        { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
            }).get();
        }
    });
    
    // Attach a bunch of functions for handling common AJAX events
    jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
        jQuery.fn[ o ] = function( f ){
            return this.on( o, f );
        };
    });
    
    jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {
            // shift arguments if data argument was omitted
            if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
    
            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });
    
    jQuery.extend({
    
        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        },
    
        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },
    
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            if ( settings ) {
                // Building a settings object
                ajaxExtend( target, jQuery.ajaxSettings );
            } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
            }
            ajaxExtend( target, settings );
            return target;
        },
    
        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            traditional: false,
            headers: {},
            */
    
            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },
    
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
    
            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },
    
            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {
    
                // Convert anything to text
                "* text": window.String,
    
                // Text to html (true = no transformation)
                "text html": true,
    
                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,
    
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
    
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                context: true,
                url: true
            }
        },
    
        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),
    
        // Main method
        ajax: function( url, options ) {
    
            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }
    
            // Force options to be an object
            options = options || {};
    
            var // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events
                // It's the callbackContext if one was provided in the options
                // and if it's a DOM node or a jQuery collection
                globalEventContext = callbackContext !== s &&
                    ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
                            jQuery( callbackContext ) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks( "once memory" ),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // ifModified key
                ifModifiedKey,
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // Response headers
                responseHeadersString,
                responseHeaders,
                // transport
                transport,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // The jqXHR state
                state = 0,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Fake xhr
                jqXHR = {
    
                    readyState: 0,
    
                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        if ( !state ) {
                            var lname = name.toLowerCase();
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },
    
                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },
    
                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match === undefined ? null : match;
                    },
    
                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },
    
                    // Cancel the request
                    abort: function( statusText ) {
                        statusText = statusText || "abort";
                        if ( transport ) {
                            transport.abort( statusText );
                        }
                        done( 0, statusText );
                        return this;
                    }
                };
    
            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done( status, nativeStatusText, responses, headers ) {
    
                // Called once
                if ( state === 2 ) {
                    return;
                }
    
                // State is "done" now
                state = 2;
    
                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    clearTimeout( timeoutTimer );
                }
    
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
    
                // Cache response headers
                responseHeadersString = headers || "";
    
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
    
                var isSuccess,
                    success,
                    error,
                    statusText = nativeStatusText,
                    response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
                    lastModified,
                    etag;
    
                // If successful, handle type chaining
                if ( status >= 200 && status < 300 || status === 304 ) {
    
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
    
                        if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
                            jQuery.lastModified[ ifModifiedKey ] = lastModified;
                        }
                        if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
                            jQuery.etag[ ifModifiedKey ] = etag;
                        }
                    }
    
                    // If not modified
                    if ( status === 304 ) {
    
                        statusText = "notmodified";
                        isSuccess = true;
    
                    // If we have data
                    } else {
    
                        try {
                            success = ajaxConvert( s, response );
                            statusText = "success";
                            isSuccess = true;
                        } catch(e) {
                            // We have a parsererror
                            statusText = "parsererror";
                            error = e;
                        }
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if ( !statusText || status ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }
    
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = "" + ( nativeStatusText || statusText );
    
                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }
    
                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;
    
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
                            [ jqXHR, s, isSuccess ? success : error ] );
                }
    
                // Complete
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
    
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger( "ajaxStop" );
                    }
                }
            }
    
            // Attach deferreds
            deferred.promise( jqXHR );
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;
    
            // Status-dependent callbacks
            jqXHR.statusCode = function( map ) {
                if ( map ) {
                    var tmp;
                    if ( state < 2 ) {
                        for ( tmp in map ) {
                            statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
                        }
                    } else {
                        tmp = map[ jqXHR.status ];
                        jqXHR.then( tmp, tmp );
                    }
                }
                return this;
            };
    
            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
    
            // Extract dataTypes list
            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );
    
            // Determine if a cross-domain request is in order
            if ( s.crossDomain == null ) {
                parts = rurl.exec( s.url.toLowerCase() );
                s.crossDomain = !!( parts &&
                    ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
                );
            }
    
            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }
    
            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
    
            // If request was aborted inside a prefilter, stop there
            if ( state === 2 ) {
                return false;
            }
    
            // We can fire global events as of now if asked to
            fireGlobals = s.global;
    
            // Uppercase the type
            s.type = s.type.toUpperCase();
    
            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );
    
            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger( "ajaxStart" );
            }
    
            // More options handling for requests with no content
            if ( !s.hasContent ) {
    
                // If data is available, append data to url
                if ( s.data ) {
                    s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
    
                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;
    
                // Add anti-cache in url if needed
                if ( s.cache === false ) {
    
                    var ts = jQuery.now(),
                        // try replacing _= if it is there
                        ret = s.url.replace( rts, "$1_=" + ts );
    
                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
                }
            }
    
            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }
    
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                ifModifiedKey = ifModifiedKey || s.url;
                if ( jQuery.lastModified[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
                }
                if ( jQuery.etag[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
                }
            }
    
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                    s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );
    
            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }
    
            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                    // Abort if not done already
                    jqXHR.abort();
                    return false;
    
            }
    
            // Install callbacks on deferreds
            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }
    
            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
    
            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = setTimeout( function(){
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }
    
                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch (e) {
                    // Propagate exception as error if not done
                    if ( state < 2 ) {
                        done( -1, e );
                    // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }
    
            return jqXHR;
        },
    
        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function( a, traditional ) {
            var s = [],
                add = function( key, value ) {
                    // If value is a function, invoke it and return its value
                    value = jQuery.isFunction( value ) ? value() : value;
                    s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                };
    
            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if ( traditional === undefined ) {
                traditional = jQuery.ajaxSettings.traditional;
            }
    
            // If an array was passed in, assume that it is an array of form elements.
            if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
                // Serialize the form elements
                jQuery.each( a, function() {
                    add( this.name, this.value );
                });
    
            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for ( var prefix in a ) {
                    buildParams( prefix, a[ prefix ], traditional, add );
                }
            }
    
            // Return the resulting serialization
            return s.join( "&" ).replace( r20, "+" );
        }
    });
    
    function buildParams( prefix, obj, traditional, add ) {
        if ( jQuery.isArray( obj ) ) {
            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {
                    // Treat each array item as a scalar.
                    add( prefix, v );
    
                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
                }
            });
    
        } else if ( !traditional && jQuery.type( obj ) === "object" ) {
            // Serialize object item.
            for ( var name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }
    
        } else {
            // Serialize scalar item.
            add( prefix, obj );
        }
    }
    
    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({
    
        // Counter for holding the number of active queries
        active: 0,
    
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}
    
    });
    
    /* Handles responses to an ajax request:
     * - sets all responseXXX fields accordingly
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses( s, jqXHR, responses ) {
    
        var contents = s.contents,
            dataTypes = s.dataTypes,
            responseFields = s.responseFields,
            ct,
            type,
            finalDataType,
            firstDataType;
    
        // Fill responseXXX fields
        for ( type in responseFields ) {
            if ( type in responses ) {
                jqXHR[ responseFields[type] ] = responses[ type ];
            }
        }
    
        // Remove auto dataType and get content-type in the process
        while( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
            }
        }
    
        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }
    
        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
    
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }
    
    // Chain conversions given the request and the original response
    function ajaxConvert( s, response ) {
    
        // Apply the dataFilter if provided
        if ( s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }
    
        var dataTypes = s.dataTypes,
            converters = {},
            i,
            key,
            length = dataTypes.length,
            tmp,
            // Current and previous dataTypes
            current = dataTypes[ 0 ],
            prev,
            // Conversion expression
            conversion,
            // Conversion function
            conv,
            // Conversion functions (transitive conversion)
            conv1,
            conv2;
    
        // For each dataType in the chain
        for ( i = 1; i < length; i++ ) {
    
            // Create converters map
            // with lowercased keys
            if ( i === 1 ) {
                for ( key in s.converters ) {
                    if ( typeof key === "string" ) {
                        converters[ key.toLowerCase() ] = s.converters[ key ];
                    }
                }
            }
    
            // Get the dataTypes
            prev = current;
            current = dataTypes[ i ];
    
            // If current is auto dataType, update it to prev
            if ( current === "*" ) {
                current = prev;
            // If no auto and dataTypes are actually different
            } else if ( prev !== "*" && prev !== current ) {
    
                // Get the converter
                conversion = prev + " " + current;
                conv = converters[ conversion ] || converters[ "* " + current ];
    
                // If there is no direct converter, search transitively
                if ( !conv ) {
                    conv2 = undefined;
                    for ( conv1 in converters ) {
                        tmp = conv1.split( " " );
                        if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
                            conv2 = converters[ tmp[1] + " " + current ];
                            if ( conv2 ) {
                                conv1 = converters[ conv1 ];
                                if ( conv1 === true ) {
                                    conv = conv2;
                                } else if ( conv2 === true ) {
                                    conv = conv1;
                                }
                                break;
                            }
                        }
                    }
                }
                // If we found no converter, dispatch an error
                if ( !( conv || conv2 ) ) {
                    jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
                }
                // If found converter is not an equivalence
                if ( conv !== true ) {
                    // Convert with 1 or 2 converters accordingly
                    response = conv ? conv( response ) : conv2( conv1(response) );
                }
            }
        }
        return response;
    }
    
    
    
    
    var jsc = jQuery.now(),
        jsre = /(\=)\?(&|$)|\?\?/i;
    
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            return jQuery.expando + "_" + ( jsc++ );
        }
    });
    
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
    
        var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );
    
        if ( s.dataTypes[ 0 ] === "jsonp" ||
            s.jsonp !== false && ( jsre.test( s.url ) ||
                    inspectData && jsre.test( s.data ) ) ) {
    
            var responseContainer,
                jsonpCallback = s.jsonpCallback =
                    jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
                previous = window[ jsonpCallback ],
                url = s.url,
                data = s.data,
                replace = "$1" + jsonpCallback + "$2";
    
            if ( s.jsonp !== false ) {
                url = url.replace( jsre, replace );
                if ( s.url === url ) {
                    if ( inspectData ) {
                        data = data.replace( jsre, replace );
                    }
                    if ( s.data === data ) {
                        // Add callback manually
                        url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                    }
                }
            }
    
            s.url = url;
            s.data = data;
    
            // Install callback
            window[ jsonpCallback ] = function( response ) {
                responseContainer = [ response ];
            };
    
            // Clean-up function
            jqXHR.always(function() {
                // Set callback back to previous value
                window[ jsonpCallback ] = previous;
                // Call if it was a function and we have a response
                if ( responseContainer && jQuery.isFunction( previous ) ) {
                    window[ jsonpCallback ]( responseContainer[ 0 ] );
                }
            });
    
            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if ( !responseContainer ) {
                    jQuery.error( jsonpCallback + " was not called" );
                }
                return responseContainer[ 0 ];
            };
    
            // force json dataType
            s.dataTypes[ 0 ] = "json";
    
            // Delegate to script
            return "script";
        }
    });
    
    
    
    
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    });
    
    // Handle cache's special case and global
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
            s.global = false;
        }
    });
    
    // Bind script tag hack transport
    jQuery.ajaxTransport( "script", function(s) {
    
        // This transport only deals with cross domain requests
        if ( s.crossDomain ) {
    
            var script,
                head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
    
            return {
    
                send: function( _, callback ) {
    
                    script = document.createElement( "script" );
    
                    script.async = "async";
    
                    if ( s.scriptCharset ) {
                        script.charset = s.scriptCharset;
                    }
    
                    script.src = s.url;
    
                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function( _, isAbort ) {
    
                        if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
    
                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;
    
                            // Remove the script
                            if ( head && script.parentNode ) {
                                head.removeChild( script );
                            }
    
                            // Dereference the script
                            script = undefined;
    
                            // Callback if not abort
                            if ( !isAbort ) {
                                callback( 200, "success" );
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore( script, head.firstChild );
                },
    
                abort: function() {
                    if ( script ) {
                        script.onload( 0, 1 );
                    }
                }
            };
        }
    });
    
    
    
    
    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
        xhrOnUnloadAbort = window.ActiveXObject ? function() {
            // Abort all pending requests
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]( 0, 1 );
            }
        } : false,
        xhrId = 0,
        xhrCallbacks;
    
    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch( e ) {}
    }
    
    function createActiveXHR() {
        try {
            return new window.ActiveXObject( "Microsoft.XMLHTTP" );
        } catch( e ) {}
    }
    
    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
        /* Microsoft failed to properly
         * implement the XMLHttpRequest in IE7 (can't request local files),
         * so we use the ActiveXObject when it is available
         * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
         * we need a fallback.
         */
        function() {
            return !this.isLocal && createStandardXHR() || createActiveXHR();
        } :
        // For all other browsers, use the standard XMLHttpRequest object
        createStandardXHR;
    
    // Determine support properties
    (function( xhr ) {
        jQuery.extend( jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ( "withCredentials" in xhr )
        });
    })( jQuery.ajaxSettings.xhr() );
    
    // Create transport if the browser can provide an xhr
    if ( jQuery.support.ajax ) {
    
        jQuery.ajaxTransport(function( s ) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if ( !s.crossDomain || jQuery.support.cors ) {
    
                var callback;
    
                return {
                    send: function( headers, complete ) {
    
                        // Get a new xhr
                        var xhr = s.xhr(),
                            handle,
                            i;
    
                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if ( s.username ) {
                            xhr.open( s.type, s.url, s.async, s.username, s.password );
                        } else {
                            xhr.open( s.type, s.url, s.async );
                        }
    
                        // Apply custom fields if provided
                        if ( s.xhrFields ) {
                            for ( i in s.xhrFields ) {
                                xhr[ i ] = s.xhrFields[ i ];
                            }
                        }
    
                        // Override mime type if needed
                        if ( s.mimeType && xhr.overrideMimeType ) {
                            xhr.overrideMimeType( s.mimeType );
                        }
    
                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if ( !s.crossDomain && !headers["X-Requested-With"] ) {
                            headers[ "X-Requested-With" ] = "XMLHttpRequest";
                        }
    
                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for ( i in headers ) {
                                xhr.setRequestHeader( i, headers[ i ] );
                            }
                        } catch( _ ) {}
    
                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send( ( s.hasContent && s.data ) || null );
    
                        // Listener
                        callback = function( _, isAbort ) {
    
                            var status,
                                statusText,
                                responseHeaders,
                                responses,
                                xml;
    
                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occured
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {
    
                                // Was never called and is aborted or complete
                                if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
    
                                    // Only called once
                                    callback = undefined;
    
                                    // Do not keep as active anymore
                                    if ( handle ) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if ( xhrOnUnloadAbort ) {
                                            delete xhrCallbacks[ handle ];
                                        }
                                    }
    
                                    // If it's an abort
                                    if ( isAbort ) {
                                        // Abort it manually if needed
                                        if ( xhr.readyState !== 4 ) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;
    
                                        // Construct response list
                                        if ( xml && xml.documentElement /* #4958 */ ) {
                                            responses.xml = xml;
                                        }
    
                                        // When requesting binary data, IE6-9 will throw an exception
                                        // on any attempt to access responseText (#11426)
                                        try {
                                            responses.text = xhr.responseText;
                                        } catch( _ ) {
                                        }
    
                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch( e ) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }
    
                                        // Filter status for non standard behaviors
    
                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if ( !status && s.isLocal && !s.crossDomain ) {
                                            status = responses.text ? 200 : 404;
                                        // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if ( status === 1223 ) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch( firefoxAccessException ) {
                                if ( !isAbort ) {
                                    complete( -1, firefoxAccessException );
                                }
                            }
    
                            // Call complete if needed
                            if ( responses ) {
                                complete( status, statusText, responses, responseHeaders );
                            }
                        };
    
                        // if we're in sync mode or it's in cache
                        // and has been retrieved directly (IE6 & IE7)
                        // we need to manually fire the callback
                        if ( !s.async || xhr.readyState === 4 ) {
                            callback();
                        } else {
                            handle = ++xhrId;
                            if ( xhrOnUnloadAbort ) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if ( !xhrCallbacks ) {
                                    xhrCallbacks = {};
                                    jQuery( window ).unload( xhrOnUnloadAbort );
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[ handle ] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },
    
                    abort: function() {
                        if ( callback ) {
                            callback(0,1);
                        }
                    }
                };
            }
        });
    }
    
    
    
    
    var elemdisplay = {},
        iframe, iframeDoc,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
        timerId,
        fxAttrs = [
            // height animations
            [ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
            // width animations
            [ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
            // opacity animations
            [ "opacity" ]
        ],
        fxNow;
    
    jQuery.fn.extend({
        show: function( speed, easing, callback ) {
            var elem, display;
    
            if ( speed || speed === 0 ) {
                return this.animate( genFx("show", 3), speed, easing, callback );
    
            } else {
                for ( var i = 0, j = this.length; i < j; i++ ) {
                    elem = this[ i ];
    
                    if ( elem.style ) {
                        display = elem.style.display;
    
                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
                            display = elem.style.display = "";
                        }
    
                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if ( (display === "" && jQuery.css(elem, "display") === "none") ||
                            !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
                            jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
                        }
                    }
                }
    
                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for ( i = 0; i < j; i++ ) {
                    elem = this[ i ];
    
                    if ( elem.style ) {
                        display = elem.style.display;
    
                        if ( display === "" || display === "none" ) {
                            elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
                        }
                    }
                }
    
                return this;
            }
        },
    
        hide: function( speed, easing, callback ) {
            if ( speed || speed === 0 ) {
                return this.animate( genFx("hide", 3), speed, easing, callback);
    
            } else {
                var elem, display,
                    i = 0,
                    j = this.length;
    
                for ( ; i < j; i++ ) {
                    elem = this[i];
                    if ( elem.style ) {
                        display = jQuery.css( elem, "display" );
    
                        if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
                            jQuery._data( elem, "olddisplay", display );
                        }
                    }
                }
    
                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for ( i = 0; i < j; i++ ) {
                    if ( this[i].style ) {
                        this[i].style.display = "none";
                    }
                }
    
                return this;
            }
        },
    
        // Save the old toggle function
        _toggle: jQuery.fn.toggle,
    
        toggle: function( fn, fn2, callback ) {
            var bool = typeof fn === "boolean";
    
            if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
                this._toggle.apply( this, arguments );
    
            } else if ( fn == null || bool ) {
                this.each(function() {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[ state ? "show" : "hide" ]();
                });
    
            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }
    
            return this;
        },
    
        fadeTo: function( speed, to, easing, callback ) {
            return this.filter(":hidden").css("opacity", 0).show().end()
                        .animate({opacity: to}, speed, easing, callback);
        },
    
        animate: function( prop, speed, easing, callback ) {
            var optall = jQuery.speed( speed, easing, callback );
    
            if ( jQuery.isEmptyObject( prop ) ) {
                return this.each( optall.complete, [ false ] );
            }
    
            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend( {}, prop );
    
            function doAnimation() {
                // XXX 'this' does not always have a nodeName when running the
                // test suite
    
                if ( optall.queue === false ) {
                    jQuery._mark( this );
                }
    
                var opt = jQuery.extend( {}, optall ),
                    isElement = this.nodeType === 1,
                    hidden = isElement && jQuery(this).is(":hidden"),
                    name, val, p, e, hooks, replace,
                    parts, start, end, unit,
                    method;
    
                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};
    
                // first pass over propertys to expand / normalize
                for ( p in prop ) {
                    name = jQuery.camelCase( p );
                    if ( p !== name ) {
                        prop[ name ] = prop[ p ];
                        delete prop[ p ];
                    }
    
                    if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
                        replace = hooks.expand( prop[ name ] );
                        delete prop[ name ];
    
                        // not quite $.extend, this wont overwrite keys already present.
                        // also - reusing 'p' from above because we have the correct "name"
                        for ( p in replace ) {
                            if ( ! ( p in prop ) ) {
                                prop[ p ] = replace[ p ];
                            }
                        }
                    }
                }
    
                for ( name in prop ) {
                    val = prop[ name ];
                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if ( jQuery.isArray( val ) ) {
                        opt.animatedProperties[ name ] = val[ 1 ];
                        val = prop[ name ] = val[ 0 ];
                    } else {
                        opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
                    }
    
                    if ( val === "hide" && hidden || val === "show" && !hidden ) {
                        return opt.complete.call( this );
                    }
    
                    if ( isElement && ( name === "height" || name === "width" ) ) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];
    
                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height animated
                        if ( jQuery.css( this, "display" ) === "inline" &&
                                jQuery.css( this, "float" ) === "none" ) {
    
                            // inline-level elements accept inline-block;
                            // block-level elements need to be inline with layout
                            if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
                                this.style.display = "inline-block";
    
                            } else {
                                this.style.zoom = 1;
                            }
                        }
                    }
                }
    
                if ( opt.overflow != null ) {
                    this.style.overflow = "hidden";
                }
    
                for ( p in prop ) {
                    e = new jQuery.fx( this, opt, p );
                    val = prop[ p ];
    
                    if ( rfxtypes.test( val ) ) {
    
                        // Tracks whether to show or hide based on private
                        // data attached to the element
                        method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
                        if ( method ) {
                            jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
                            e[ method ]();
                        } else {
                            e[ val ]();
                        }
    
                    } else {
                        parts = rfxnum.exec( val );
                        start = e.cur();
    
                        if ( parts ) {
                            end = parseFloat( parts[2] );
                            unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );
    
                            // We need to compute starting value
                            if ( unit !== "px" ) {
                                jQuery.style( this, p, (end || 1) + unit);
                                start = ( (end || 1) / e.cur() ) * start;
                                jQuery.style( this, p, start + unit);
                            }
    
                            // If a +=/-= token was provided, we're doing a relative animation
                            if ( parts[1] ) {
                                end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
                            }
    
                            e.custom( start, end, unit );
    
                        } else {
                            e.custom( start, val, "" );
                        }
                    }
                }
    
                // For JS strict compliance
                return true;
            }
    
            return optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
        },
    
        stop: function( type, clearQueue, gotoEnd ) {
            if ( typeof type !== "string" ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if ( clearQueue && type !== false ) {
                this.queue( type || "fx", [] );
            }
    
            return this.each(function() {
                var index,
                    hadTimers = false,
                    timers = jQuery.timers,
                    data = jQuery._data( this );
    
                // clear marker counters if we know they won't be
                if ( !gotoEnd ) {
                    jQuery._unmark( true, this );
                }
    
                function stopQueue( elem, data, index ) {
                    var hooks = data[ index ];
                    jQuery.removeData( elem, index, true );
                    hooks.stop( gotoEnd );
                }
    
                if ( type == null ) {
                    for ( index in data ) {
                        if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
                            stopQueue( this, data, index );
                        }
                    }
                } else if ( data[ index = type + ".run" ] && data[ index ].stop ){
                    stopQueue( this, data, index );
                }
    
                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                        if ( gotoEnd ) {
    
                            // force the next step to be the last
                            timers[ index ]( true );
                        } else {
                            timers[ index ].saveState();
                        }
                        hadTimers = true;
                        timers.splice( index, 1 );
                    }
                }
    
                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if ( !( gotoEnd && hadTimers ) ) {
                    jQuery.dequeue( this, type );
                }
            });
        }
    
    });
    
    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout( clearFxNow, 0 );
        return ( fxNow = jQuery.now() );
    }
    
    function clearFxNow() {
        fxNow = undefined;
    }
    
    // Generate parameters to create a standard animation
    function genFx( type, num ) {
        var obj = {};
    
        jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
            obj[ this ] = type;
        });
    
        return obj;
    }
    
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx( "show", 1 ),
        slideUp: genFx( "hide", 1 ),
        slideToggle: genFx( "toggle", 1 ),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    });
    
    jQuery.extend({
        speed: function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                complete: fn || !fn && easing ||
                    jQuery.isFunction( speed ) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
            };
    
            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
    
            // normalize opt.queue - true/undefined/null -> "fx"
            if ( opt.queue == null || opt.queue === true ) {
                opt.queue = "fx";
            }
    
            // Queueing
            opt.old = opt.complete;
    
            opt.complete = function( noUnmark ) {
                if ( jQuery.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }
    
                if ( opt.queue ) {
                    jQuery.dequeue( this, opt.queue );
                } else if ( noUnmark !== false ) {
                    jQuery._unmark( this );
                }
            };
    
            return opt;
        },
    
        easing: {
            linear: function( p ) {
                return p;
            },
            swing: function( p ) {
                return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
            }
        },
    
        timers: [],
    
        fx: function( elem, options, prop ) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;
    
            options.orig = options.orig || {};
        }
    
    });
    
    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function() {
            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }
    
            ( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
        },
    
        // Get the current size
        cur: function() {
            if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
                return this.elem[ this.prop ];
            }
    
            var parsed,
                r = jQuery.css( this.elem, this.prop );
            // Empty strings, null, undefined and "auto" are converted to 0,
            // complex values such as "rotate(1rad)" are returned as is,
            // simple values such as "10px" are parsed to Float.
            return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
        },
    
        // Start an animation from one number to another
        custom: function( from, to, unit ) {
            var self = this,
                fx = jQuery.fx;
    
            this.startTime = fxNow || createFxNow();
            this.end = to;
            this.now = this.start = from;
            this.pos = this.state = 0;
            this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
    
            function t( gotoEnd ) {
                return self.step( gotoEnd );
            }
    
            t.queue = this.options.queue;
            t.elem = this.elem;
            t.saveState = function() {
                if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
                    if ( self.options.hide ) {
                        jQuery._data( self.elem, "fxshow" + self.prop, self.start );
                    } else if ( self.options.show ) {
                        jQuery._data( self.elem, "fxshow" + self.prop, self.end );
                    }
                }
            };
    
            if ( t() && jQuery.timers.push(t) && !timerId ) {
                timerId = setInterval( fx.tick, fx.interval );
            }
        },
    
        // Simple 'show' function
        show: function() {
            var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );
    
            // Remember where we started, so that we can go back to it later
            this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
            this.options.show = true;
    
            // Begin the animation
            // Make sure that we start at a small width/height to avoid any flash of content
            if ( dataShow !== undefined ) {
                // This show is picking up where a previous hide or show left off
                this.custom( this.cur(), dataShow );
            } else {
                this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
            }
    
            // Start by showing the element
            jQuery( this.elem ).show();
        },
    
        // Simple 'hide' function
        hide: function() {
            // Remember where we started, so that we can go back to it later
            this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
            this.options.hide = true;
    
            // Begin the animation
            this.custom( this.cur(), 0 );
        },
    
        // Each step of an animation
        step: function( gotoEnd ) {
            var p, n, complete,
                t = fxNow || createFxNow(),
                done = true,
                elem = this.elem,
                options = this.options;
    
            if ( gotoEnd || t >= options.duration + this.startTime ) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();
    
                options.animatedProperties[ this.prop ] = true;
    
                for ( p in options.animatedProperties ) {
                    if ( options.animatedProperties[ p ] !== true ) {
                        done = false;
                    }
                }
    
                if ( done ) {
                    // Reset the overflow
                    if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
    
                        jQuery.each( [ "", "X", "Y" ], function( index, value ) {
                            elem.style[ "overflow" + value ] = options.overflow[ index ];
                        });
                    }
    
                    // Hide the element if the "hide" operation was done
                    if ( options.hide ) {
                        jQuery( elem ).hide();
                    }
    
                    // Reset the properties, if the item has been hidden or shown
                    if ( options.hide || options.show ) {
                        for ( p in options.animatedProperties ) {
                            jQuery.style( elem, p, options.orig[ p ] );
                            jQuery.removeData( elem, "fxshow" + p, true );
                            // Toggle data is no longer needed
                            jQuery.removeData( elem, "toggle" + p, true );
                        }
                    }
    
                    // Execute the complete function
                    // in the event that the complete function throws an exception
                    // we must ensure it won't be called twice. #5684
    
                    complete = options.complete;
                    if ( complete ) {
    
                        options.complete = false;
                        complete.call( elem );
                    }
                }
    
                return false;
    
            } else {
                // classical easing cannot be used with an Infinity duration
                if ( options.duration == Infinity ) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;
    
                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
                    this.now = this.start + ( (this.end - this.start) * this.pos );
                }
                // Perform the next step of the animation
                this.update();
            }
    
            return true;
        }
    };
    
    jQuery.extend( jQuery.fx, {
        tick: function() {
            var timer,
                timers = jQuery.timers,
                i = 0;
    
            for ( ; i < timers.length; i++ ) {
                timer = timers[ i ];
                // Checks the timer has not already been removed
                if ( !timer() && timers[ i ] === timer ) {
                    timers.splice( i--, 1 );
                }
            }
    
            if ( !timers.length ) {
                jQuery.fx.stop();
            }
        },
    
        interval: 13,
    
        stop: function() {
            clearInterval( timerId );
            timerId = null;
        },
    
        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },
    
        step: {
            opacity: function( fx ) {
                jQuery.style( fx.elem, "opacity", fx.now );
            },
    
            _default: function( fx ) {
                if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
                    fx.elem.style[ fx.prop ] = fx.now + fx.unit;
                } else {
                    fx.elem[ fx.prop ] = fx.now;
                }
            }
        }
    });
    
    // Ensure props that can't be negative don't go there on undershoot easing
    jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
        // exclude marginTop, marginLeft, marginBottom and marginRight from this list
        if ( prop.indexOf( "margin" ) ) {
            jQuery.fx.step[ prop ] = function( fx ) {
                jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
            };
        }
    });
    
    if ( jQuery.expr && jQuery.expr.filters ) {
        jQuery.expr.filters.animated = function( elem ) {
            return jQuery.grep(jQuery.timers, function( fn ) {
                return elem === fn.elem;
            }).length;
        };
    }
    
    // Try to restore the default display value of an element
    function defaultDisplay( nodeName ) {
    
        if ( !elemdisplay[ nodeName ] ) {
    
            var body = document.body,
                elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
                display = elem.css( "display" );
            elem.remove();
    
            // If the simple way fails,
            // get element's real default display by attaching it to a temp iframe
            if ( display === "none" || display === "" ) {
                // No iframe to use yet, so create it
                if ( !iframe ) {
                    iframe = document.createElement( "iframe" );
                    iframe.frameBorder = iframe.width = iframe.height = 0;
                }
    
                body.appendChild( iframe );
    
                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if ( !iframeDoc || !iframe.createElement ) {
                    iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
                    iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
                    iframeDoc.close();
                }
    
                elem = iframeDoc.createElement( nodeName );
    
                iframeDoc.body.appendChild( elem );
    
                display = jQuery.css( elem, "display" );
                body.removeChild( iframe );
            }
    
            // Store the correct default display
            elemdisplay[ nodeName ] = display;
        }
    
        return elemdisplay[ nodeName ];
    }
    
    
    
    
    var getOffset,
        rtable = /^t(?:able|d|h)$/i,
        rroot = /^(?:body|html)$/i;
    
    if ( "getBoundingClientRect" in document.documentElement ) {
        getOffset = function( elem, doc, docElem, box ) {
            try {
                box = elem.getBoundingClientRect();
            } catch(e) {}
    
            // Make sure we're not dealing with a disconnected DOM node
            if ( !box || !jQuery.contains( docElem, elem ) ) {
                return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
            }
    
            var body = doc.body,
                win = getWindow( doc ),
                clientTop  = docElem.clientTop  || body.clientTop  || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
                scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
                top  = box.top  + scrollTop  - clientTop,
                left = box.left + scrollLeft - clientLeft;
    
            return { top: top, left: left };
        };
    
    } else {
        getOffset = function( elem, doc, docElem ) {
            var computedStyle,
                offsetParent = elem.offsetParent,
                prevOffsetParent = elem,
                body = doc.body,
                defaultView = doc.defaultView,
                prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
                top = elem.offsetTop,
                left = elem.offsetLeft;
    
            while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
                if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
                    break;
                }
    
                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top  -= elem.scrollTop;
                left -= elem.scrollLeft;
    
                if ( elem === offsetParent ) {
                    top  += elem.offsetTop;
                    left += elem.offsetLeft;
    
                    if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
                        top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                        left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                    }
    
                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }
    
                if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
                    top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                    left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                }
    
                prevComputedStyle = computedStyle;
            }
    
            if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
                top  += body.offsetTop;
                left += body.offsetLeft;
            }
    
            if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
                top  += Math.max( docElem.scrollTop, body.scrollTop );
                left += Math.max( docElem.scrollLeft, body.scrollLeft );
            }
    
            return { top: top, left: left };
        };
    }
    
    jQuery.fn.offset = function( options ) {
        if ( arguments.length ) {
            return options === undefined ?
                this :
                this.each(function( i ) {
                    jQuery.offset.setOffset( this, options, i );
                });
        }
    
        var elem = this[0],
            doc = elem && elem.ownerDocument;
    
        if ( !doc ) {
            return null;
        }
    
        if ( elem === doc.body ) {
            return jQuery.offset.bodyOffset( elem );
        }
    
        return getOffset( elem, doc, doc.documentElement );
    };
    
    jQuery.offset = {
    
        bodyOffset: function( body ) {
            var top = body.offsetTop,
                left = body.offsetLeft;
    
            if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
                top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
                left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
            }
    
            return { top: top, left: left };
        },
    
        setOffset: function( elem, options, i ) {
            var position = jQuery.css( elem, "position" );
    
            // set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }
    
            var curElem = jQuery( elem ),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css( elem, "top" ),
                curCSSLeft = jQuery.css( elem, "left" ),
                calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
                props = {}, curPosition = {}, curTop, curLeft;
    
            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }
    
            if ( jQuery.isFunction( options ) ) {
                options = options.call( elem, i, curOffset );
            }
    
            if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }
    
            if ( "using" in options ) {
                options.using.call( elem, props );
            } else {
                curElem.css( props );
            }
        }
    };
    
    
    jQuery.fn.extend({
    
        position: function() {
            if ( !this[0] ) {
                return null;
            }
    
            var elem = this[0],
    
            // Get *real* offsetParent
            offsetParent = this.offsetParent(),
    
            // Get correct offsets
            offset       = this.offset(),
            parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
    
            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
            offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;
    
            // Add offsetParent borders
            parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
            parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;
    
            // Subtract the two offsets
            return {
                top:  offset.top  - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },
    
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || document.body;
                while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });
    
    
    // Create scrollLeft and scrollTop methods
    jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
        var top = /Y/.test( prop );
    
        jQuery.fn[ method ] = function( val ) {
            return jQuery.access( this, function( elem, method, val ) {
                var win = getWindow( elem );
    
                if ( val === undefined ) {
                    return win ? (prop in win) ? win[ prop ] :
                        jQuery.support.boxModel && win.document.documentElement[ method ] ||
                            win.document.body[ method ] :
                        elem[ method ];
                }
    
                if ( win ) {
                    win.scrollTo(
                        !top ? val : jQuery( win ).scrollLeft(),
                         top ? val : jQuery( win ).scrollTop()
                    );
    
                } else {
                    elem[ method ] = val;
                }
            }, method, val, arguments.length, null );
        };
    });
    
    function getWindow( elem ) {
        return jQuery.isWindow( elem ) ?
            elem :
            elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
    }
    
    
    
    
    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        var clientProp = "client" + name,
            scrollProp = "scroll" + name,
            offsetProp = "offset" + name;
    
        // innerHeight and innerWidth
        jQuery.fn[ "inner" + name ] = function() {
            var elem = this[0];
            return elem ?
                elem.style ?
                parseFloat( jQuery.css( elem, type, "padding" ) ) :
                this[ type ]() :
                null;
        };
    
        // outerHeight and outerWidth
        jQuery.fn[ "outer" + name ] = function( margin ) {
            var elem = this[0];
            return elem ?
                elem.style ?
                parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
                this[ type ]() :
                null;
        };
    
        jQuery.fn[ type ] = function( value ) {
            return jQuery.access( this, function( elem, type, value ) {
                var doc, docElemProp, orig, ret;
    
                if ( jQuery.isWindow( elem ) ) {
                    // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                    doc = elem.document;
                    docElemProp = doc.documentElement[ clientProp ];
                    return jQuery.support.boxModel && docElemProp ||
                        doc.body && doc.body[ clientProp ] || docElemProp;
                }
    
                // Get document width or height
                if ( elem.nodeType === 9 ) {
                    // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                    doc = elem.documentElement;
    
                    // when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
                    // so we can't use max, as it'll choose the incorrect offset[Width/Height]
                    // instead we use the correct client[Width/Height]
                    // support:IE6
                    if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
                        return doc[ clientProp ];
                    }
    
                    return Math.max(
                        elem.body[ scrollProp ], doc[ scrollProp ],
                        elem.body[ offsetProp ], doc[ offsetProp ]
                    );
                }
    
                // Get width or height on the element
                if ( value === undefined ) {
                    orig = jQuery.css( elem, type );
                    ret = parseFloat( orig );
                    return jQuery.isNumeric( ret ) ? ret : orig;
                }
    
                // Set the width or height on the element
                jQuery( elem ).css( type, value );
            }, type, value, arguments.length, null );
        };
    });
    
    
    
    
    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;
    
    // Expose jQuery as an AMD module, but only for AMD loaders that
    // understand the issues with loading multiple versions of jQuery
    // in a page that all might call define(). The loader will indicate
    // they have special allowances for multiple jQuery versions by
    // specifying define.amd.jQuery = true. Register as a named module,
    // since jQuery can be concatenated with other files that may use define,
    // but not use a proper concatenation script that understands anonymous
    // AMD modules. A named AMD is safest and most robust way to register.
    // Lowercase jquery is used because AMD module names are derived from
    // file names, and jQuery is normally delivered in a lowercase file name.
    // Do this after creating the global so that if an AMD module wants to call
    // noConflict to hide this version of jQuery, it will work.
    if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
        define( "jquery", [], function () { return jQuery; } );
    }
    
    
    
    })( window );/* ===================================================
 * bootstrap-transition.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#transitions
 * ===================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

(function ($) {

	"use strict"; // jshint ;_;


	/* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
	 * ======================================================= */

	$(function () {

		$.support.transition = (function () {

			var transitionEnd = (function () {

				var el = document.createElement('bootstrap')
					, transEndEventNames = {
						'WebkitTransition': 'webkitTransitionEnd'
						, 'MozTransition': 'transitionend'
						, 'OTransition': 'oTransitionEnd otransitionend'
						, 'transition': 'transitionend'
					}
					, name

				for (name in transEndEventNames) {
					if (el.style[name] !== undefined) {
						return transEndEventNames[name]
					}
				}

			}())

			return transitionEnd && {
				end: transitionEnd
			}

		})()

	})

})(window.jQuery);
/* =============================================================
 * bootstrap-scrollspy.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#scrollspy
 * =============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================== */


(function ($) {

	"use strict"; // jshint ;_;


	/* SCROLLSPY CLASS DEFINITION
	 * ========================== */

	function ScrollSpy(element, options) {
		var process = $.proxy(this.process, this)
			, $element = $(element).is('body') ? $(window) : $(element)
			, href
		this.options = $.extend({}, $.fn.scrollspy.defaults, options)
		this.$scrollElement = $element.on('scroll.scroll-spy.data-api', process)
		this.selector = (this.options.target
			|| ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
			|| '') + ' .nav li > a'
		this.$body = $('body')
		this.refresh()
		this.process()
	}

	ScrollSpy.prototype = {

		constructor: ScrollSpy

		, refresh: function () {
			var self = this
				, $targets

			this.offsets = $([])
			this.targets = $([])

			$targets = this.$body
				.find(this.selector)
				.map(function () {
					var $el = $(this)
						, href = $el.data('target') || $el.attr('href')
						, $href = /^#\w/.test(href) && $(href)
					return ($href
						&& $href.length
						&& [[$href.position().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href]]) || null
				})
				.sort(function (a, b) { return a[0] - b[0] })
				.each(function () {
					self.offsets.push(this[0])
					self.targets.push(this[1])
				})
		}

		, process: function () {
			var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
				, scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
				, maxScroll = scrollHeight - this.$scrollElement.height()
				, offsets = this.offsets
				, targets = this.targets
				, activeTarget = this.activeTarget
				, i

			if (scrollTop >= maxScroll) {
				return activeTarget != (i = targets.last()[0])
					&& this.activate(i)
			}

			for (i = offsets.length; i--;) {
				activeTarget != targets[i]
					&& scrollTop >= offsets[i]
					&& (!offsets[i + 1] || scrollTop <= offsets[i + 1])
					&& this.activate(targets[i])
			}
		}

		, activate: function (target) {
			var active
				, selector

			this.activeTarget = target

			$(this.selector)
				.parent('.active')
				.removeClass('active')

			selector = this.selector
				+ '[data-target="' + target + '"],'
				+ this.selector + '[href="' + target + '"]'

			active = $(selector)
				.parent('li')
				.addClass('active')

			if (active.parent('.dropdown-menu').length) {
				active = active.closest('li.dropdown').addClass('active')
			}

			active.trigger('activate')
		}

	}


	/* SCROLLSPY PLUGIN DEFINITION
	 * =========================== */

	var old = $.fn.scrollspy

	$.fn.scrollspy = function (option) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('scrollspy')
				, options = typeof option == 'object' && option
			if (!data) $this.data('scrollspy', (data = new ScrollSpy(this, options)))
			if (typeof option == 'string') data[option]()
		})
	}

	$.fn.scrollspy.Constructor = ScrollSpy

	$.fn.scrollspy.defaults = {
		offset: 10
	}


	/* SCROLLSPY NO CONFLICT
	 * ===================== */

	$.fn.scrollspy.noConflict = function () {
		$.fn.scrollspy = old
		return this
	}


	/* SCROLLSPY DATA-API
	 * ================== */

	$(window).on('load', function () {
		$('[data-spy="scroll"]').each(function () {
			var $spy = $(this)
			$spy.scrollspy($spy.data())
		})
	})

})(window.jQuery);
/* ========================================================
 * bootstrap-tab.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#tabs
 * ========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================== */


(function ($) {

	"use strict"; // jshint ;_;


	/* TAB CLASS DEFINITION
	 * ==================== */

	var Tab = function (element) {
		this.element = $(element)
	}

	Tab.prototype = {

		constructor: Tab

		, show: function () {
			var $this = this.element
				, $ul = $this.closest('ul:not(.dropdown-menu)')
				, selector = $this.attr('data-target')
				, previous
				, $target
				, e

			if (!selector) {
				selector = $this.attr('href')
				selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
			}

			if ($this.parent('li').hasClass('active')) return

			previous = $ul.find('.active:last a')[0]

			e = $.Event('show', {
				relatedTarget: previous
			})

			$this.trigger(e)

			if (e.isDefaultPrevented()) return

			$target = $(selector)

			this.activate($this.parent('li'), $ul)
			this.activate($target, $target.parent(), function () {
				$this.trigger({
					type: 'shown'
					, relatedTarget: previous
				})
			})
		}

		, activate: function (element, container, callback) {
			var $active = container.find('> .active')
				, transition = callback
					&& $.support.transition
					&& $active.hasClass('fade')

			function next() {
				$active
					.removeClass('active')
					.find('> .dropdown-menu > .active')
					.removeClass('active')

				element.addClass('active')

				if (transition) {
					element[0].offsetWidth; // reflow for transition
					element.addClass('in')
				} else {
					element.removeClass('fade')
				}

				if (element.parent('.dropdown-menu')) {
					element.closest('li.dropdown').addClass('active')
				}

				callback && callback()
			}

			transition ?
				$active.one($.support.transition.end, next) :
				next()

			$active.removeClass('in')
		}
	}


	/* TAB PLUGIN DEFINITION
	 * ===================== */

	var old = $.fn.tab

	$.fn.tab = function (option) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('tab')
			if (!data) $this.data('tab', (data = new Tab(this)))
			if (typeof option == 'string') data[option]()
		})
	}

	$.fn.tab.Constructor = Tab


	/* TAB NO CONFLICT
	 * =============== */

	$.fn.tab.noConflict = function () {
		$.fn.tab = old
		return this
	}


	/* TAB DATA-API
	 * ============ */

	$(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
		e.preventDefault()
		$(this).tab('show')
	})

})(window.jQuery);
/* ===========================================================
 * bootstrap-tooltip.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


(function ($) {

	"use strict"; // jshint ;_;


	/* TOOLTIP PUBLIC CLASS DEFINITION
	 * =============================== */

	var Tooltip = function (element, options) {
		this.init('tooltip', element, options)
	}

	Tooltip.prototype = {

		constructor: Tooltip

		, init: function (type, element, options) {
			var eventIn
				, eventOut
				, triggers
				, trigger
				, i

			this.type = type
			this.$element = $(element)
			this.options = this.getOptions(options)
			this.enabled = true

			triggers = this.options.trigger.split(' ')

			for (i = triggers.length; i--;) {
				trigger = triggers[i]
				if (trigger == 'click') {
					this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
				} else if (trigger != 'manual') {
					eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
					eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
					this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
					this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
				}
			}

			this.options.selector ?
				(this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
				this.fixTitle()
		}

		, getOptions: function (options) {
			options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

			if (options.delay && typeof options.delay == 'number') {
				options.delay = {
					show: options.delay
					, hide: options.delay
				}
			}

			return options
		}

		, enter: function (e) {
			var defaults = $.fn[this.type].defaults
				, options = {}
				, self

			this._options && $.each(this._options, function (key, value) {
				if (defaults[key] != value) options[key] = value
			}, this)

			self = $(e.currentTarget)[this.type](options).data(this.type)

			if (!self.options.delay || !self.options.delay.show) return self.show()

			clearTimeout(this.timeout)
			self.hoverState = 'in'
			this.timeout = setTimeout(function () {
				if (self.hoverState == 'in') self.show()
			}, self.options.delay.show)
		}

		, leave: function (e) {
			var self = $(e.currentTarget)[this.type](this._options).data(this.type)

			if (this.timeout) clearTimeout(this.timeout)
			if (!self.options.delay || !self.options.delay.hide) return self.hide()

			self.hoverState = 'out'
			this.timeout = setTimeout(function () {
				if (self.hoverState == 'out') self.hide()
			}, self.options.delay.hide)
		}

		, show: function () {
			var $tip
				, pos
				, actualWidth
				, actualHeight
				, placement
				, tp
				, e = $.Event('show')

			if (this.hasContent() && this.enabled) {
				this.$element.trigger(e)
				if (e.isDefaultPrevented()) return
				$tip = this.tip()
				this.setContent()

				if (this.options.animation) {
					$tip.addClass('fade')
				}

				placement = typeof this.options.placement == 'function' ?
					this.options.placement.call(this, $tip[0], this.$element[0]) :
					this.options.placement

				$tip
					.detach()
					.css({ top: 0, left: 0, display: 'block' })

				this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

				pos = this.getPosition()

				actualWidth = $tip[0].offsetWidth
				actualHeight = $tip[0].offsetHeight

				switch (placement) {
					case 'bottom':
						tp = { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 }
						break
					case 'top':
						tp = { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 }
						break
					case 'left':
						tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth }
						break
					case 'right':
						tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }
						break
				}

				this.applyPlacement(tp, placement)
				this.$element.trigger('shown')
			}
		}

		, applyPlacement: function (offset, placement) {
			var $tip = this.tip()
				, width = $tip[0].offsetWidth
				, height = $tip[0].offsetHeight
				, actualWidth
				, actualHeight
				, delta
				, replace

			$tip
				.offset(offset)
				.addClass(placement)
				.addClass('in')

			actualWidth = $tip[0].offsetWidth
			actualHeight = $tip[0].offsetHeight

			if (placement == 'top' && actualHeight != height) {
				offset.top = offset.top + height - actualHeight;
				replace = true
			}

			if (placement == 'bottom' || placement == 'top') {
				delta = 0

				if (offset.left < 0) {
					delta = offset.left * -2
					offset.left = 0
					$tip.offset(offset)
					actualWidth = $tip[0].offsetWidth
					actualHeight = $tip[0].offsetHeight
				}

				this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
			} else {
				this.replaceArrow(actualHeight - height, actualHeight, 'top')
			}

			if (replace) $tip.offset(offset)
		}

		, replaceArrow: function (delta, dimension, position) {
			this
				.arrow()
				.css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
		}

		, setContent: function () {
			var $tip = this.tip()
				, title = this.getTitle()

			$tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
			$tip.removeClass('fade in top bottom left right')
		}

		, hide: function () {
			var that = this
				, $tip = this.tip()
				, e = $.Event('hide')

			this.$element.trigger(e)
			if (e.isDefaultPrevented()) return

			$tip.removeClass('in')

			function removeWithAnimation() {
				var timeout = setTimeout(function () {
					$tip.off($.support.transition.end).detach()
				}, 500)

				$tip.one($.support.transition.end, function () {
					clearTimeout(timeout)
					$tip.detach()
				})
			}

			$.support.transition && this.$tip.hasClass('fade') ?
				removeWithAnimation() :
				$tip.detach()

			this.$element.trigger('hidden')

			return this
		}

		, fixTitle: function () {
			var $e = this.$element
			if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
				$e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
			}
		}

		, hasContent: function () {
			return this.getTitle()
		}

		, getPosition: function () {
			var el = this.$element[0]
			return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
				width: el.offsetWidth
				, height: el.offsetHeight
			}, this.$element.offset())
		}

		, getTitle: function () {
			var title
				, $e = this.$element
				, o = this.options

			title = $e.attr('data-original-title')
				|| (typeof o.title == 'function' ? o.title.call($e[0]) : o.title)

			return title
		}

		, tip: function () {
			return this.$tip = this.$tip || $(this.options.template)
		}

		, arrow: function () {
			return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
		}

		, validate: function () {
			if (!this.$element[0].parentNode) {
				this.hide()
				this.$element = null
				this.options = null
			}
		}

		, enable: function () {
			this.enabled = true
		}

		, disable: function () {
			this.enabled = false
		}

		, toggleEnabled: function () {
			this.enabled = !this.enabled
		}

		, toggle: function (e) {
			var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
			self.tip().hasClass('in') ? self.hide() : self.show()
		}

		, destroy: function () {
			this.hide().$element.off('.' + this.type).removeData(this.type)
		}

	}


	/* TOOLTIP PLUGIN DEFINITION
	 * ========================= */

	var old = $.fn.tooltip

	$.fn.tooltip = function (option) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('tooltip')
				, options = typeof option == 'object' && option
			if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
			if (typeof option == 'string') data[option]()
		})
	}

	$.fn.tooltip.Constructor = Tooltip

	$.fn.tooltip.defaults = {
		animation: true
		, placement: 'top'
		, selector: false
		, template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
		, trigger: 'hover focus'
		, title: ''
		, delay: 0
		, html: false
		, container: false
	}


	/* TOOLTIP NO CONFLICT
	 * =================== */

	$.fn.tooltip.noConflict = function () {
		$.fn.tooltip = old
		return this
	}

})(window.jQuery);

/* ===========================================================
 * bootstrap-popover.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#popovers
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */


(function ($) {

	"use strict"; // jshint ;_;


	/* POPOVER PUBLIC CLASS DEFINITION
	 * =============================== */

	var Popover = function (element, options) {
		this.init('popover', element, options)
	}


	/* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
	   ========================================== */

	Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {

		constructor: Popover

		, setContent: function () {
			var $tip = this.tip()
				, title = this.getTitle()
				, content = this.getContent()

			$tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
			$tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

			$tip.removeClass('fade top bottom left right in')
		}

		, hasContent: function () {
			return this.getTitle() || this.getContent()
		}

		, getContent: function () {
			var content
				, $e = this.$element
				, o = this.options

			content = (typeof o.content == 'function' ? o.content.call($e[0]) : o.content)
				|| $e.attr('data-content')

			return content
		}

		, tip: function () {
			if (!this.$tip) {
				this.$tip = $(this.options.template)
			}
			return this.$tip
		}

		, destroy: function () {
			this.hide().$element.off('.' + this.type).removeData(this.type)
		}

	})


	/* POPOVER PLUGIN DEFINITION
	 * ======================= */

	var old = $.fn.popover

	$.fn.popover = function (option) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('popover')
				, options = typeof option == 'object' && option
			if (!data) $this.data('popover', (data = new Popover(this, options)))
			if (typeof option == 'string') data[option]()
		})
	}

	$.fn.popover.Constructor = Popover

	$.fn.popover.defaults = $.extend({}, $.fn.tooltip.defaults, {
		placement: 'right'
		, trigger: 'click'
		, content: ''
		, template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	})


	/* POPOVER NO CONFLICT
	 * =================== */

	$.fn.popover.noConflict = function () {
		$.fn.popover = old
		return this
	}

})(window.jQuery);

/* ==========================================================
 * bootstrap-alert.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#alerts
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


(function ($) {

	"use strict"; // jshint ;_;


	/* ALERT CLASS DEFINITION
	 * ====================== */

	var dismiss = '[data-dismiss="alert"]'
		, Alert = function (el) {
			$(el).on('click', dismiss, this.close)
		}

	Alert.prototype.close = function (e) {
		var $this = $(this)
			, selector = $this.attr('data-target')
			, $parent

		if (!selector) {
			selector = $this.attr('href')
			selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
		}

		$parent = $(selector)

		e && e.preventDefault()

		$parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())

		$parent.trigger(e = $.Event('close'))

		if (e.isDefaultPrevented()) return

		$parent.removeClass('in')

		function removeElement() {
			$parent
				.trigger('closed')
				.remove()
		}

		$.support.transition && $parent.hasClass('fade') ?
			$parent.on($.support.transition.end, removeElement) :
			removeElement()
	}


	/* ALERT PLUGIN DEFINITION
	 * ======================= */

	var old = $.fn.alert

	$.fn.alert = function (option) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('alert')
			if (!data) $this.data('alert', (data = new Alert(this)))
			if (typeof option == 'string') data[option].call($this)
		})
	}

	$.fn.alert.Constructor = Alert


	/* ALERT NO CONFLICT
	 * ================= */

	$.fn.alert.noConflict = function () {
		$.fn.alert = old
		return this
	}


	/* ALERT DATA-API
	 * ============== */

	$(document).on('click.alert.data-api', dismiss, Alert.prototype.close)

})(window.jQuery);
/* ============================================================
 * bootstrap-button.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#buttons
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


(function ($) {

	"use strict"; // jshint ;_;


	/* BUTTON PUBLIC CLASS DEFINITION
	 * ============================== */

	var Button = function (element, options) {
		this.$element = $(element)
		this.options = $.extend({}, $.fn.button.defaults, options)
	}

	Button.prototype.setState = function (state) {
		var d = 'disabled'
			, $el = this.$element
			, data = $el.data()
			, val = $el.is('input') ? 'val' : 'html'

		state = state + 'Text'
		data.resetText || $el.data('resetText', $el[val]())

		$el[val](data[state] || this.options[state])

		// push to event loop to allow forms to submit
		setTimeout(function () {
			state == 'loadingText' ?
				$el.addClass(d).attr(d, d) :
				$el.removeClass(d).removeAttr(d)
		}, 0)
	}

	Button.prototype.toggle = function () {
		var $parent = this.$element.closest('[data-toggle="buttons-radio"]')

		$parent && $parent
			.find('.active')
			.removeClass('active')

		this.$element.toggleClass('active')
	}


	/* BUTTON PLUGIN DEFINITION
	 * ======================== */

	var old = $.fn.button

	$.fn.button = function (option) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('button')
				, options = typeof option == 'object' && option
			if (!data) $this.data('button', (data = new Button(this, options)))
			if (option == 'toggle') data.toggle()
			else if (option) data.setState(option)
		})
	}

	$.fn.button.defaults = {
		loadingText: 'loading...'
	}

	$.fn.button.Constructor = Button


	/* BUTTON NO CONFLICT
	 * ================== */

	$.fn.button.noConflict = function () {
		$.fn.button = old
		return this
	}


	/* BUTTON DATA-API
	 * =============== */

	$(document).on('click.button.data-api', '[data-toggle^=button]', function (e) {
		var $btn = $(e.target)
		if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
		$btn.button('toggle')
	})

})(window.jQuery);
/* =============================================================
* bootstrap-collapse.js v2.3.1
* http://twitter.github.com/bootstrap/javascript.html#collapse
* =============================================================
* Copyright 2012 Twitter, Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ============================================================ */
(function ($) {
	"use strict"; // jshint ;_;
	/* COLLAPSE PUBLIC CLASS DEFINITION
	* ================================ */
	var Collapse = function (element, options) {
		this.$element = $(element)
		this.options = $.extend({}, $.fn.collapse.defaults, options)
		if (this.options.parent) {
			this.$parent = $(this.options.parent)
		}
		this.options.toggle && this.toggle()
	}
	Collapse.prototype = {
		constructor: Collapse
		, dimension: function () {
			var hasWidth = this.$element.hasClass('width')
			return hasWidth ? 'width' : 'height'
		}
		, show: function () {
			var dimension
				, scroll
				, actives
				, hasData
			if (this.transitioning || this.$element.hasClass('in')) return
			dimension = this.dimension()
			scroll = $.camelCase(['scroll', dimension].join('-'))
			actives = this.$parent && this.$parent.find('> .accordion-group > .in')
			if (actives && actives.length) {
				hasData = actives.data('collapse')
				if (hasData && hasData.transitioning) return
				actives.collapse('hide')
				hasData || actives.data('collapse', null)
			}
			this.$element[dimension](0)
			this.transition('addClass', $.Event('show'), 'shown')
			$.support.transition && this.$element[dimension](this.$element[0][scroll])
		}
		, hide: function () {
			var dimension
			if (this.transitioning || !this.$element.hasClass('in')) return
			dimension = this.dimension()
			this.reset(this.$element[dimension]())
			this.transition('removeClass', $.Event('hide'), 'hidden')
			this.$element[dimension](0)
		}
		, reset: function (size) {
			var dimension = this.dimension()
			this.$element
				.removeClass('collapse')
			[dimension](size || 'auto')
			[0].offsetWidth
			this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')
			return this
		}
		, transition: function (method, startEvent, completeEvent) {
			var that = this
				, complete = function () {
					if (startEvent.type == 'show') that.reset()
					that.transitioning = 0
					that.$element.trigger(completeEvent)
				}
			this.$element.trigger(startEvent)
			if (startEvent.isDefaultPrevented()) return
			this.transitioning = 1
			this.$element[method]('in')
			$.support.transition && this.$element.hasClass('collapse') ?
				this.$element.one($.support.transition.end, complete) :
				complete()
		}
		, toggle: function () {
			this[this.$element.hasClass('in') ? 'hide' : 'show']()
		}
	}
	/* COLLAPSE PLUGIN DEFINITION
	* ========================== */
	var old = $.fn.collapse
	$.fn.collapse = function (option) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('collapse')
				, options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option)
			if (!data) $this.data('collapse', (data = new Collapse(this, options)))
			if (typeof option == 'string') data[option]()
		})
	}
	$.fn.collapse.defaults = {
		toggle: true
	}
	$.fn.collapse.Constructor = Collapse
	/* COLLAPSE NO CONFLICT
	* ==================== */
	$.fn.collapse.noConflict = function () {
		$.fn.collapse = old
		return this
	}
	/* COLLAPSE DATA-API
	* ================= */
	$(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
		var $this = $(this), href
			, target = $this.attr('data-target')
				|| e.preventDefault()
				|| (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
			, option = $(target).data('collapse') ? 'toggle' : $this.data()
		$this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
		$(target).collapse(option)
	})
})(window.jQuery);
/* =========================================================
 * bootstrap-datepicker.js 
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

(function ($) {

	// Picker object

	var Datepicker = function (element, options) {
		this.element = $(element);
		this.format = DPGlobal.parseFormat(options.format || this.element.data('date-format') || 'mm/dd/yyyy');
		this.picker = $(DPGlobal.template)
			.appendTo('body')
			.on({
				click: $.proxy(this.click, this),
				mousedown: $.proxy(this.mousedown, this)
			});
		this.isInput = this.element.is('input');
		this.component = this.element.is('.date') ? this.element.find('.add-on') : false;

		if (this.isInput) {
			this.element.on({
				focus: $.proxy(this.show, this),
				blur: $.proxy(this.hide, this),
				keyup: $.proxy(this.update, this)
			});
		} else {
			if (this.component) {
				this.component.on('click', $.proxy(this.show, this));
			} else {
				this.element.on('click', $.proxy(this.show, this));
			}
		}

		this.viewMode = 0;
		this.weekStart = options.weekStart || this.element.data('date-weekstart') || 0;
		this.weekEnd = this.weekStart == 0 ? 6 : this.weekStart - 1;
		this.fillDow();
		this.fillMonths();
		this.update();
		this.showMode();
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		show: function (e) {
			this.picker.show();
			this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
			this.place();
			$(window).on('resize', $.proxy(this.place, this));
			if (e) {
				e.stopPropagation();
				e.preventDefault();
			}
			if (!this.isInput) {
				$(document).on('mousedown', $.proxy(this.hide, this));
			}
			this.element.trigger({
				type: 'show',
				date: this.date
			});
		},

		hide: function () {
			this.picker.hide();
			$(window).off('resize', this.place);
			this.viewMode = 0;
			this.showMode();
			if (!this.isInput) {
				$(document).off('mousedown', this.hide);
			}
			this.setValue();
			this.element.trigger({
				type: 'hide',
				date: this.date
			});
		},

		setValue: function () {
			var formated = DPGlobal.formatDate(this.date, this.format);
			if (!this.isInput) {
				if (this.component) {
					this.element.find('input').prop('value', formated);
				}
				this.element.data('date', formated);
			} else {
				this.element.prop('value', formated);
			}
		},

		place: function () {
			var offset = this.component ? this.component.offset() : this.element.offset();
			this.picker.css({
				top: offset.top + this.height,
				left: offset.left
			});
		},

		update: function () {
			this.date = DPGlobal.parseDate(
				this.isInput ? this.element.prop('value') : this.element.data('date'),
				this.format
			);
			this.viewDate = new Date(this.date);
			this.fill();
		},

		fillDow: function () {
			var dowCnt = this.weekStart;
			var html = '<tr>';
			while (dowCnt < this.weekStart + 7) {
				html += '<th class="dow">' + DPGlobal.dates.daysMin[(dowCnt++) % 7] + '</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
		},

		fillMonths: function () {
			var html = '';
			var i = 0;
			while (i < 12) {
				html += '<span class="month">' + DPGlobal.dates.monthsShort[i++] + '</span>';
			}
			this.picker.find('.datepicker-months td').append(html);
		},

		fill: function () {
			var d = new Date(this.viewDate),
				year = d.getFullYear(),
				month = d.getMonth(),
				currentDate = this.date.valueOf();
			this.picker.find('.datepicker-days th:eq(1)')
				.text(DPGlobal.dates.months[month] + ' ' + year);
			var prevMonth = new Date(year, month - 1, 28, 0, 0, 0, 0),
				day = DPGlobal.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
			prevMonth.setDate(day);
			prevMonth.setDate(day - (prevMonth.getDay() - this.weekStart + 7) % 7);
			var nextMonth = new Date(prevMonth);
			nextMonth.setDate(nextMonth.getDate() + 42);
			nextMonth = nextMonth.valueOf();
			html = [];
			var clsName;
			while (prevMonth.valueOf() < nextMonth) {
				if (prevMonth.getDay() == this.weekStart) {
					html.push('<tr>');
				}
				clsName = '';
				if (prevMonth.getMonth() < month) {
					clsName += ' old';
				} else if (prevMonth.getMonth() > month) {
					clsName += ' new';
				}
				if (prevMonth.valueOf() == currentDate) {
					clsName += ' active';
				}
				html.push('<td class="day' + clsName + '">' + prevMonth.getDate() + '</td>');
				if (prevMonth.getDay() == this.weekEnd) {
					html.push('</tr>');
				}
				prevMonth.setDate(prevMonth.getDate() + 1);
			}
			this.picker.find('.datepicker-days tbody').empty().append(html.join(''));
			var currentYear = this.date.getFullYear();

			var months = this.picker.find('.datepicker-months')
				.find('th:eq(1)')
				.text(year)
				.end()
				.find('span').removeClass('active');
			if (currentYear == year) {
				months.eq(this.date.getMonth()).addClass('active');
			}

			html = '';
			year = parseInt(year / 10, 10) * 10;
			var yearCont = this.picker.find('.datepicker-years')
				.find('th:eq(1)')
				.text(year + '-' + (year + 9))
				.end()
				.find('td');
			year -= 1;
			for (var i = -1; i < 11; i++) {
				html += '<span class="year' + (i == -1 || i == 10 ? ' old' : '') + (currentYear == year ? ' active' : '') + '">' + year + '</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		click: function (e) {
			e.stopPropagation();
			e.preventDefault();
			var target = $(e.target).closest('span, td, th');
			if (target.length == 1) {
				switch (target[0].nodeName.toLowerCase()) {
					case 'th':
						switch (target[0].className) {
							case 'switch':
								this.showMode(1);
								break;
							case 'prev':
							case 'next':
								this.viewDate['set' + DPGlobal.modes[this.viewMode].navFnc].call(
									this.viewDate,
									this.viewDate['get' + DPGlobal.modes[this.viewMode].navFnc].call(this.viewDate) +
									DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1)
								);
								this.fill();
								break;
						}
						break;
					case 'span':
						if (target.is('.month')) {
							var month = target.parent().find('span').index(target);
							this.viewDate.setMonth(month);
						} else {
							var year = parseInt(target.text(), 10) || 0;
							this.viewDate.setFullYear(year);
						}
						this.showMode(-1);
						this.fill();
						break;
					case 'td':
						if (target.is('.day')) {
							var day = parseInt(target.text(), 10) || 1;
							var month = this.viewDate.getMonth();
							if (target.is('.old')) {
								month -= 1;
							} else if (target.is('.new')) {
								month += 1;
							}
							var year = this.viewDate.getFullYear();
							this.date = new Date(year, month, day, 0, 0, 0, 0);
							this.viewDate = new Date(year, month, day, 0, 0, 0, 0);
							this.fill();
							this.setValue();
							this.element.trigger({
								type: 'changeDate',
								date: this.date
							});
						}
						break;
				}
			}
		},

		mousedown: function (e) {
			e.stopPropagation();
			e.preventDefault();
		},

		showMode: function (dir) {
			if (dir) {
				this.viewMode = Math.max(0, Math.min(2, this.viewMode + dir));
			}
			this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).show();
		}
	};

	$.fn.datepicker = function (option) {
		return this.each(function () {
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option == 'object' && option;
			if (!data) {
				$this.data('datepicker', (data = new Datepicker(this, $.extend({}, $.fn.datepicker.defaults, options))));
			}
			if (typeof option == 'string') data[option]();
		});
	};

	$.fn.datepicker.defaults = {
	};
	$.fn.datepicker.Constructor = Datepicker;

	var DPGlobal = {
		modes: [
			{
				clsName: 'days',
				navFnc: 'Month',
				navStep: 1
			},
			{
				clsName: 'months',
				navFnc: 'FullYear',
				navStep: 1
			},
			{
				clsName: 'years',
				navFnc: 'FullYear',
				navStep: 10
			}],
		dates: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
			daysMin: ["日", "月", "火", "水", "木", "金", "土", "日"],
			months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
		},
		isLeapYear: function (year) {
			return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
		},
		getDaysInMonth: function (year, month) {
			return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
		},
		parseFormat: function (format) {
			var separator = format.match(/[.\/-].*?/),
				parts = format.split(/\W+/);
			if (!separator || !parts || parts.length == 0) {
				throw new Error("Invalid date format.");
			}
			return { separator: separator, parts: parts };
		},
		parseDate: function (date, format) {
			var parts = date.split(format.separator),
				date = new Date(1970, 1, 1, 0, 0, 0),
				val;
			if (parts.length == format.parts.length) {
				for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
					val = parseInt(parts[i], 10) || 1;
					switch (format.parts[i]) {
						case 'dd':
						case 'd':
							date.setDate(val);
							break;
						case 'mm':
						case 'm':
							date.setMonth(val - 1);
							break;
						case 'yy':
							date.setFullYear(2000 + val);
							break;
						case 'yyyy':
							date.setFullYear(val);
							break;
					}
				}
			}
			return date;
		},
		formatDate: function (date, format) {
			var val = {
				d: date.getDate(),
				m: date.getMonth() + 1,
				yy: date.getFullYear().toString().substring(2),
				yyyy: date.getFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			var date = [];
			for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
				date.push(val[format.parts[i]]);
			}
			return date.join(format.separator);
		},
		headTemplate: '<thead>' +
			'<tr>' +
			'<th class="prev"><i class="icon-arrow-left"/></th>' +
			'<th colspan="5" class="switch"></th>' +
			'<th class="next"><i class="icon-arrow-right"/></th>' +
			'</tr>' +
			'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
	};
	DPGlobal.template = '<div class="datepicker dropdown-menu">' +
		'<div class="datepicker-days">' +
		'<table class=" table-condensed">' +
		DPGlobal.headTemplate +
		'<tbody></tbody>' +
		'</table>' +
		'</div>' +
		'<div class="datepicker-months">' +
		'<table class="table-condensed">' +
		DPGlobal.headTemplate +
		DPGlobal.contTemplate +
		'</table>' +
		'</div>' +
		'<div class="datepicker-years">' +
		'<table class="table-condensed">' +
		DPGlobal.headTemplate +
		DPGlobal.contTemplate +
		'</table>' +
		'</div>' +
		'</div>';

})(window.jQuery);/**
   * @version 0.1
   * H_CookieManager - クッキー管理クラス
   * @author  H-Hash (studyinghttp.net)
   */
function H_CookieManager() {
	/**
	 * getCookie - クッキー取得用メソッド
	 * name という名前のクッキーがない場合は null を返す
	 * @param name クッキー名
	 * @return クッキー値
	 */
	this.getCookie = function (name) {
		if (!_cookieHash[name]) {
			return null;
		} else {
			return unescape(_cookieHash[name]);
		}
	};

	/**
	 * setCookie - クッキー設定用メソッド
	 * @param name   クッキー名
	 * @param value  クッキー値
	 * @param age    クッキー有効期限（秒単位）
	 * @param path   クッキー有効パス
	 * @param domain クッキー有効ドメイン
	 * @param secure 真の場合、SSL通信時のみクッキーを送る
	 * @return なし
	 */
	this.setCookie = function (name, value, age, path, domain, secure) {
		// Set-Cookie: header
		var _setCookieHeader;

		// name, value
		_cookieHash[name] = escape(value);
		_setCookieHeader = name + "=" + _cookieHash[name];

		// expires (age)
		if (age > 0) {
			_setCookieHeader += "; expires=" + _convGmtStr(age);
		}

		// path は String型である事を明示
		path = new String(path);
		// pathの先頭は“/”
		if (path.charAt(0) == "/") {
			_setCookieHeader += "; path=" + path;
		}

		// domain
		// Todo: “.”の数をチェック
		if (domain) {
			_setCookieHeader += "; domain=" + domain;
		}

		// secure
		if (secure) {
			_setCookieHeader += "; secure";
		}

		document.cookie = _setCookieHeader;

		if (window.localStorage) {
			localStorage.setItem(name, value);
		}
	};

	// Constructor
	{
		var _cookieHash = new Object();
		_parseCookie();
	}

	// private method
	function _parseCookie() {
		var _ary1 = new Array();
		var _ary2 = new Array();

		if (document.cookie) {
			// スペースを先頭に付加
			var _cStr = document.cookie;
			_ary1 = _cStr.split(";");
			for (var i = 0; i < _ary1.length; i++) {
				_ary2 = _ary1[i].split("=");
				// 余計な空白文字は消す
				_ary2[0].match(/^\s*(.+)/);
				_cookieHash[RegExp.$1] = _ary2[1];
			}
		}
	}
	function _convGmtStr(age) {
		var _exDate = new Date();
		_exDate.setTime(_exDate.getTime() + age * 1000);
		return _exDate.toGMTString();
	}
}
/**
 * @summary     DataTables
 * @description Paginate, search and sort HTML tables
 * @version     1.9.3
 * @file        jquery.dataTables.js
 * @author      Allan Jardine (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 *
 * @copyright Copyright 2008-2012 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, available at:
 *   http://datatables.net/license_gpl2
 *   http://datatables.net/license_bsd
 * 
 * This source file is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 * 
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $, jQuery,_fnExternApiFunc,_fnInitialise,_fnInitComplete,_fnLanguageCompat,_fnAddColumn,_fnColumnOptions,_fnAddData,_fnCreateTr,_fnGatherData,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnServerParams,_fnAddOptionsHtml,_fnFeatureHtmlTable,_fnScrollDraw,_fnAdjustColumnSizing,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnBuildSearchArray,_fnBuildSearchRow,_fnFilterCreateSearch,_fnDataToSearch,_fnSort,_fnSortAttachListener,_fnSortingClasses,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnFeatureHtmlLength,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnNodeToDataIndex,_fnVisbleColumns,_fnCalculateEnd,_fnConvertToWidth,_fnCalculateColumnWidths,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnDetectType,_fnSettingsFromNode,_fnGetDataMaster,_fnGetTrNodes,_fnGetTdNodes,_fnEscapeRegex,_fnDeleteIndex,_fnReOrderIndex,_fnColumnOrdering,_fnLog,_fnClearTable,_fnSaveState,_fnLoadState,_fnCreateCookie,_fnReadCookie,_fnDetectHeader,_fnGetUniqueThs,_fnScrollBarWidth,_fnApplyToChildren,_fnMap,_fnGetRowData,_fnGetCellData,_fnSetCellData,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnApplyColumnDefs,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnJsonString,_fnRender,_fnNodeToColumnIndex,_fnInfoMacros,_fnBrowserDetect,_fnGetColumns*/

(/** @lends <global> */function ($, window, document, undefined) {
	/** 
	 * DataTables is a plug-in for the jQuery Javascript library. It is a 
	 * highly flexible tool, based upon the foundations of progressive 
	 * enhancement, which will add advanced interaction controls to any 
	 * HTML table. For a full list of features please refer to
	 * <a href="http://datatables.net">DataTables.net</a>.
	 *
	 * Note that the <i>DataTable</i> object is not a global variable but is
	 * aliased to <i>jQuery.fn.DataTable</i> and <i>jQuery.fn.dataTable</i> through which 
	 * it may be  accessed.
	 *
	 *  @class
	 *  @param {object} [oInit={}] Configuration object for DataTables. Options
	 *    are defined by {@link DataTable.defaults}
	 *  @requires jQuery 1.3+
	 * 
	 *  @example
	 *    // Basic initialisation
	 *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
	 *  
	 *  @example
	 *    // Initialisation with configuration options - in this case, disable
	 *    // pagination and sorting.
	 *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "bPaginate": false,
	 *        "bSort": false 
	 *      } );
	 *    } );
	 */
	var DataTable = function (oInit) {


		/**
		 * Add a column to the list used for the table with default values
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nTh The th element for this column
		 *  @memberof DataTable#oApi
		 */
		function _fnAddColumn(oSettings, nTh) {
			var oDefaults = DataTable.defaults.columns;
			var iCol = oSettings.aoColumns.length;
			var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
				"sSortingClass": oSettings.oClasses.sSortable,
				"sSortingClassJUI": oSettings.oClasses.sSortJUI,
				"nTh": nTh ? nTh : document.createElement('th'),
				"sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
				"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
				"mData": oDefaults.mData ? oDefaults.oDefaults : iCol
			});
			oSettings.aoColumns.push(oCol);

			/* Add a column specific filter */
			if (oSettings.aoPreSearchCols[iCol] === undefined || oSettings.aoPreSearchCols[iCol] === null) {
				oSettings.aoPreSearchCols[iCol] = $.extend({}, DataTable.models.oSearch);
			}
			else {
				var oPre = oSettings.aoPreSearchCols[iCol];

				/* Don't require that the user must specify bRegex, bSmart or bCaseInsensitive */
				if (oPre.bRegex === undefined) {
					oPre.bRegex = true;
				}

				if (oPre.bSmart === undefined) {
					oPre.bSmart = true;
				}

				if (oPre.bCaseInsensitive === undefined) {
					oPre.bCaseInsensitive = true;
				}
			}

			/* Use the column options function to initialise classes etc */
			_fnColumnOptions(oSettings, iCol, null);
		}


		/**
		 * Apply options for a column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column index to consider
		 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnOptions(oSettings, iCol, oOptions) {
			var oCol = oSettings.aoColumns[iCol];

			/* User specified column options */
			if (oOptions !== undefined && oOptions !== null) {
				/* Backwards compatibility for mDataProp */
				if (oOptions.mDataProp && !oOptions.mData) {
					oOptions.mData = oOptions.mDataProp;
				}

				if (oOptions.sType !== undefined) {
					oCol.sType = oOptions.sType;
					oCol._bAutoType = false;
				}

				$.extend(oCol, oOptions);
				_fnMap(oCol, oOptions, "sWidth", "sWidthOrig");

				/* iDataSort to be applied (backwards compatibility), but aDataSort will take
				 * priority if defined
				 */
				if (oOptions.iDataSort !== undefined) {
					oCol.aDataSort = [oOptions.iDataSort];
				}
				_fnMap(oCol, oOptions, "aDataSort");
			}

			/* Cache the data get and set functions for speed */
			var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
			var mData = _fnGetObjectDataFn(oCol.mData);

			oCol.fnGetData = function (oData, sSpecific) {
				var innerData = mData(oData, sSpecific);

				if (oCol.mRender && (sSpecific && sSpecific !== '')) {
					return mRender(innerData, sSpecific, oData);
				}
				return innerData;
			};
			oCol.fnSetData = _fnSetObjectDataFn(oCol.mData);

			/* Feature sorting overrides column specific when off */
			if (!oSettings.oFeatures.bSort) {
				oCol.bSortable = false;
			}

			/* Check that the class assignment is correct for sorting */
			if (!oCol.bSortable ||
				($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1)) {
				oCol.sSortingClass = oSettings.oClasses.sSortableNone;
				oCol.sSortingClassJUI = "";
			}
			else if (oCol.bSortable ||
				($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1)) {
				oCol.sSortingClass = oSettings.oClasses.sSortable;
				oCol.sSortingClassJUI = oSettings.oClasses.sSortJUI;
			}
			else if ($.inArray('asc', oCol.asSorting) != -1 && $.inArray('desc', oCol.asSorting) == -1) {
				oCol.sSortingClass = oSettings.oClasses.sSortableAsc;
				oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIAscAllowed;
			}
			else if ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) != -1) {
				oCol.sSortingClass = oSettings.oClasses.sSortableDesc;
				oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIDescAllowed;
			}
		}


		/**
		 * Adjust the table column widths for new data. Note: you would probably want to 
		 * do a redraw after calling this function!
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAdjustColumnSizing(oSettings) {
			/* Not interested in doing column width calculation if auto-width is disabled */
			if (oSettings.oFeatures.bAutoWidth === false) {
				return false;
			}

			_fnCalculateColumnWidths(oSettings);
			for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				oSettings.aoColumns[i].nTh.style.width = oSettings.aoColumns[i].sWidth;
			}
		}


		/**
		 * Covert the index of a visible column to the index in the data array (take account
		 * of hidden columns)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iMatch Visible column index to lookup
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnVisibleToColumnIndex(oSettings, iMatch) {
			var aiVis = _fnGetColumns(oSettings, 'bVisible');

			return typeof aiVis[iMatch] === 'number' ?
				aiVis[iMatch] :
				null;
		}


		/**
		 * Covert the index of an index in the data array and convert it to the visible
		 *   column index (take account of hidden columns)
		 *  @param {int} iMatch Column index to lookup
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnIndexToVisible(oSettings, iMatch) {
			var aiVis = _fnGetColumns(oSettings, 'bVisible');
			var iPos = $.inArray(iMatch, aiVis);

			return iPos !== -1 ? iPos : null;
		}


		/**
		 * Get the number of visible columns
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the number of visible columns
		 *  @memberof DataTable#oApi
		 */
		function _fnVisbleColumns(oSettings) {
			return _fnGetColumns(oSettings, 'bVisible').length;
		}


		/**
		 * Get an array of column indexes that match a given property
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sParam Parameter in aoColumns to look for - typically 
		 *    bVisible or bSearchable
		 *  @returns {array} Array of indexes with matched properties
		 *  @memberof DataTable#oApi
		 */
		function _fnGetColumns(oSettings, sParam) {
			var a = [];

			$.map(oSettings.aoColumns, function (val, i) {
				if (val[sParam]) {
					a.push(i);
				}
			});

			return a;
		}


		/**
		 * Get the sort type based on an input string
		 *  @param {string} sData data we wish to know the type of
		 *  @returns {string} type (defaults to 'string' if no type can be detected)
		 *  @memberof DataTable#oApi
		 */
		function _fnDetectType(sData) {
			var aTypes = DataTable.ext.aTypes;
			var iLen = aTypes.length;

			for (var i = 0; i < iLen; i++) {
				var sType = aTypes[i](sData);
				if (sType !== null) {
					return sType;
				}
			}

			return 'string';
		}


		/**
		 * Figure out how to reorder a display list
		 *  @param {object} oSettings dataTables settings object
		 *  @returns array {int} aiReturn index list for reordering
		 *  @memberof DataTable#oApi
		 */
		function _fnReOrderIndex(oSettings, sColumns) {
			var aColumns = sColumns.split(',');
			var aiReturn = [];

			for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				for (var j = 0; j < iLen; j++) {
					if (oSettings.aoColumns[i].sName == aColumns[j]) {
						aiReturn.push(j);
						break;
					}
				}
			}

			return aiReturn;
		}


		/**
		 * Get the column ordering that DataTables expects
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {string} comma separated list of names
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnOrdering(oSettings) {
			var sNames = '';
			for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				sNames += oSettings.aoColumns[i].sName + ',';
			}
			if (sNames.length == iLen) {
				return "";
			}
			return sNames.slice(0, -1);
		}


		/**
		 * Take the column definitions and static columns arrays and calculate how
		 * they relate to column indexes. The callback function will then apply the
		 * definition found for a column to a suitable configuration object.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
		 *  @param {array} aoCols The aoColumns array that defines columns individually
		 *  @param {function} fn Callback function - takes two parameters, the calculated
		 *    column index and the definition for that column.
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
			var i, iLen, j, jLen, k, kLen;

			// Column definitions with aTargets
			if (aoColDefs) {
				/* Loop over the definitions array - loop in reverse so first instance has priority */
				for (i = aoColDefs.length - 1; i >= 0; i--) {
					/* Each definition can target multiple columns, as it is an array */
					var aTargets = aoColDefs[i].aTargets;
					if (!$.isArray(aTargets)) {
						_fnLog(oSettings, 1, 'aTargets must be an array of targets, not a ' + (typeof aTargets));
					}

					for (j = 0, jLen = aTargets.length; j < jLen; j++) {
						if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
							/* Add columns that we don't yet know about */
							while (oSettings.aoColumns.length <= aTargets[j]) {
								_fnAddColumn(oSettings);
							}

							/* Integer, basic index */
							fn(aTargets[j], aoColDefs[i]);
						}
						else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
							/* Negative integer, right to left column counting */
							fn(oSettings.aoColumns.length + aTargets[j], aoColDefs[i]);
						}
						else if (typeof aTargets[j] === 'string') {
							/* Class name matching on TH element */
							for (k = 0, kLen = oSettings.aoColumns.length; k < kLen; k++) {
								if (aTargets[j] == "_all" ||
									$(oSettings.aoColumns[k].nTh).hasClass(aTargets[j])) {
									fn(k, aoColDefs[i]);
								}
							}
						}
					}
				}
			}

			// Statically defined columns array
			if (aoCols) {
				for (i = 0, iLen = aoCols.length; i < iLen; i++) {
					fn(i, aoCols[i]);
				}
			}
		}



		/**
		 * Add a data array to the table, creating DOM node etc. This is the parallel to 
		 * _fnGatherData, but for adding rows from a Javascript source, rather than a
		 * DOM source.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aData data array to be added
		 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
		 *  @memberof DataTable#oApi
		 */
		function _fnAddData(oSettings, aDataSupplied) {
			var oCol;

			/* Take an independent copy of the data source so we can bash it about as we wish */
			var aDataIn = ($.isArray(aDataSupplied)) ?
				aDataSupplied.slice() :
				$.extend(true, {}, aDataSupplied);

			/* Create the object for storing information about this new row */
			var iRow = oSettings.aoData.length;
			var oData = $.extend(true, {}, DataTable.models.oRow);
			oData._aData = aDataIn;
			oSettings.aoData.push(oData);

			/* Create the cells */
			var nTd, sThisType;
			for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				oCol = oSettings.aoColumns[i];

				/* Use rendered data for filtering / sorting */
				if (typeof oCol.fnRender === 'function' && oCol.bUseRendered && oCol.mData !== null) {
					_fnSetCellData(oSettings, iRow, i, _fnRender(oSettings, iRow, i));
				}
				else {
					_fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i));
				}

				/* See if we should auto-detect the column type */
				if (oCol._bAutoType && oCol.sType != 'string') {
					/* Attempt to auto detect the type - same as _fnGatherData() */
					var sVarType = _fnGetCellData(oSettings, iRow, i, 'type');
					if (sVarType !== null && sVarType !== '') {
						sThisType = _fnDetectType(sVarType);
						if (oCol.sType === null) {
							oCol.sType = sThisType;
						}
						else if (oCol.sType != sThisType && oCol.sType != "html") {
							/* String is always the 'fallback' option */
							oCol.sType = 'string';
						}
					}
				}
			}

			/* Add to the display array */
			oSettings.aiDisplayMaster.push(iRow);

			/* Create the DOM imformation */
			if (!oSettings.oFeatures.bDeferRender) {
				_fnCreateTr(oSettings, iRow);
			}

			return iRow;
		}


		/**
		 * Read in the data from the target table from the DOM
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnGatherData(oSettings) {
			var iLoop, i, iLen, j, jLen, jInner,
				nTds, nTrs, nTd, aLocalData, iThisIndex,
				iRow, iRows, iColumn, iColumns, sNodeName,
				oCol, oData;

			/*
			 * Process by row first
			 * Add the data object for the whole table - storing the tr node. Note - no point in getting
			 * DOM based data if we are going to go and replace it with Ajax source data.
			 */
			if (oSettings.bDeferLoading || oSettings.sAjaxSource === null) {
				nTrs = oSettings.nTBody.childNodes;
				for (i = 0, iLen = nTrs.length; i < iLen; i++) {
					if (nTrs[i].nodeName.toUpperCase() == "TR") {
						iThisIndex = oSettings.aoData.length;
						nTrs[i]._DT_RowIndex = iThisIndex;
						oSettings.aoData.push($.extend(true, {}, DataTable.models.oRow, {
							"nTr": nTrs[i]
						}));

						oSettings.aiDisplayMaster.push(iThisIndex);
						nTds = nTrs[i].childNodes;
						jInner = 0;

						for (j = 0, jLen = nTds.length; j < jLen; j++) {
							sNodeName = nTds[j].nodeName.toUpperCase();
							if (sNodeName == "TD" || sNodeName == "TH") {
								_fnSetCellData(oSettings, iThisIndex, jInner, $.trim(nTds[j].innerHTML));
								jInner++;
							}
						}
					}
				}
			}

			/* Gather in the TD elements of the Table - note that this is basically the same as
			 * fnGetTdNodes, but that function takes account of hidden columns, which we haven't yet
			 * setup!
			 */
			nTrs = _fnGetTrNodes(oSettings);
			nTds = [];
			for (i = 0, iLen = nTrs.length; i < iLen; i++) {
				for (j = 0, jLen = nTrs[i].childNodes.length; j < jLen; j++) {
					nTd = nTrs[i].childNodes[j];
					sNodeName = nTd.nodeName.toUpperCase();
					if (sNodeName == "TD" || sNodeName == "TH") {
						nTds.push(nTd);
					}
				}
			}

			/* Now process by column */
			for (iColumn = 0, iColumns = oSettings.aoColumns.length; iColumn < iColumns; iColumn++) {
				oCol = oSettings.aoColumns[iColumn];

				/* Get the title of the column - unless there is a user set one */
				if (oCol.sTitle === null) {
					oCol.sTitle = oCol.nTh.innerHTML;
				}

				var
					bAutoType = oCol._bAutoType,
					bRender = typeof oCol.fnRender === 'function',
					bClass = oCol.sClass !== null,
					bVisible = oCol.bVisible,
					nCell, sThisType, sRendered, sValType;

				/* A single loop to rule them all (and be more efficient) */
				if (bAutoType || bRender || bClass || !bVisible) {
					for (iRow = 0, iRows = oSettings.aoData.length; iRow < iRows; iRow++) {
						oData = oSettings.aoData[iRow];
						nCell = nTds[(iRow * iColumns) + iColumn];

						/* Type detection */
						if (bAutoType && oCol.sType != 'string') {
							sValType = _fnGetCellData(oSettings, iRow, iColumn, 'type');
							if (sValType !== '') {
								sThisType = _fnDetectType(sValType);
								if (oCol.sType === null) {
									oCol.sType = sThisType;
								}
								else if (oCol.sType != sThisType &&
									oCol.sType != "html") {
									/* String is always the 'fallback' option */
									oCol.sType = 'string';
								}
							}
						}

						if (typeof oCol.mData === 'function') {
							nCell.innerHTML = _fnGetCellData(oSettings, iRow, iColumn, 'display');
						}

						/* Rendering */
						if (bRender) {
							sRendered = _fnRender(oSettings, iRow, iColumn);
							nCell.innerHTML = sRendered;
							if (oCol.bUseRendered) {
								/* Use the rendered data for filtering / sorting */
								_fnSetCellData(oSettings, iRow, iColumn, sRendered);
							}
						}

						/* Classes */
						if (bClass) {
							nCell.className += ' ' + oCol.sClass;
						}

						/* Column visibility */
						if (!bVisible) {
							oData._anHidden[iColumn] = nCell;
							nCell.parentNode.removeChild(nCell);
						}
						else {
							oData._anHidden[iColumn] = null;
						}

						if (oCol.fnCreatedCell) {
							oCol.fnCreatedCell.call(oSettings.oInstance,
								nCell, _fnGetCellData(oSettings, iRow, iColumn, 'display'), oData._aData, iRow, iColumn
							);
						}
					}
				}
			}

			/* Row created callbacks */
			if (oSettings.aoRowCreatedCallback.length !== 0) {
				for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
					oData = oSettings.aoData[i];
					_fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, i]);
				}
			}
		}


		/**
		 * Take a TR element and convert it to an index in aoData
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} n the TR element to find
		 *  @returns {int} index if the node is found, null if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToDataIndex(oSettings, n) {
			return (n._DT_RowIndex !== undefined) ? n._DT_RowIndex : null;
		}


		/**
		 * Take a TD element and convert it into a column data index (not the visible index)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow The row number the TD/TH can be found in
		 *  @param {node} n The TD/TH element to find
		 *  @returns {int} index if the node is found, -1 if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToColumnIndex(oSettings, iRow, n) {
			var anCells = _fnGetTdNodes(oSettings, iRow);

			for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				if (anCells[i] === n) {
					return i;
				}
			}
			return -1;
		}


		/**
		 * Get an array of data for a given row from the internal data cache
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow aoData row id
		 *  @param {string} sSpecific data get type ('type' 'filter' 'sort')
		 *  @param {array} aiColumns Array of column indexes to get data from
		 *  @returns {array} Data array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetRowData(oSettings, iRow, sSpecific, aiColumns) {
			var out = [];
			for (var i = 0, iLen = aiColumns.length; i < iLen; i++) {
				out.push(_fnGetCellData(oSettings, iRow, aiColumns[i], sSpecific));
			}
			return out;
		}


		/**
		 * Get the data for a given cell from the internal cache, taking into account data mapping
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow aoData row id
		 *  @param {int} iCol Column index
		 *  @param {string} sSpecific data get type ('display', 'type' 'filter' 'sort')
		 *  @returns {*} Cell data
		 *  @memberof DataTable#oApi
		 */
		function _fnGetCellData(oSettings, iRow, iCol, sSpecific) {
			var sData;
			var oCol = oSettings.aoColumns[iCol];
			var oData = oSettings.aoData[iRow]._aData;

			if ((sData = oCol.fnGetData(oData, sSpecific)) === undefined) {
				if (oSettings.iDrawError != oSettings.iDraw && oCol.sDefaultContent === null) {
					_fnLog(oSettings, 0, "Requested unknown parameter " +
						(typeof oCol.mData == 'function' ? '{mData function}' : "'" + oCol.mData + "'") +
						" from the data source for row " + iRow);
					oSettings.iDrawError = oSettings.iDraw;
				}
				return oCol.sDefaultContent;
			}

			/* When the data source is null, we can use default column data */
			if (sData === null && oCol.sDefaultContent !== null) {
				sData = oCol.sDefaultContent;
			}
			else if (typeof sData === 'function') {
				/* If the data source is a function, then we run it and use the return */
				return sData();
			}

			if (sSpecific == 'display' && sData === null) {
				return '';
			}
			return sData;
		}


		/**
		 * Set the value for a specific cell, into the internal data cache
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow aoData row id
		 *  @param {int} iCol Column index
		 *  @param {*} val Value to set
		 *  @memberof DataTable#oApi
		 */
		function _fnSetCellData(oSettings, iRow, iCol, val) {
			var oCol = oSettings.aoColumns[iCol];
			var oData = oSettings.aoData[iRow]._aData;

			oCol.fnSetData(oData, val);
		}


		// Private variable that is used to match array syntax in the data property object
		var __reArray = /\[.*?\]$/;

		/**
		 * Return a function that can be used to get data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data get function
		 *  @memberof DataTable#oApi
		 */
		function _fnGetObjectDataFn(mSource) {
			if (mSource === null) {
				/* Give an empty string for rendering / sorting etc */
				return function (data, type) {
					return null;
				};
			}
			else if (typeof mSource === 'function') {
				return function (data, type, extra) {
					return mSource(data, type, extra);
				};
			}
			else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1)) {
				/* If there is a . in the source string then the data source is in a 
				 * nested object so we loop over the data for each level to get the next
				 * level down. On each loop we test for undefined, and if found immediately
				 * return. This allows entire objects to be missing and sDefaultContent to
				 * be used if defined, rather than throwing an error
				 */
				var fetchData = function (data, type, src) {
					var a = src.split('.');
					var arrayNotation, out, innerSrc;

					if (src !== "") {
						for (var i = 0, iLen = a.length; i < iLen; i++) {
							// Check if we are dealing with an array notation request
							arrayNotation = a[i].match(__reArray);

							if (arrayNotation) {
								a[i] = a[i].replace(__reArray, '');

								// Condition allows simply [] to be passed in
								if (a[i] !== "") {
									data = data[a[i]];
								}
								out = [];

								// Get the remainder of the nested object to get
								a.splice(0, i + 1);
								innerSrc = a.join('.');

								// Traverse each entry in the array getting the properties requested
								for (var j = 0, jLen = data.length; j < jLen; j++) {
									out.push(fetchData(data[j], type, innerSrc));
								}

								// If a string is given in between the array notation indicators, that
								// is used to join the strings together, otherwise an array is returned
								var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
								data = (join === "") ? out : out.join(join);

								// The inner call to fetchData has already traversed through the remainder
								// of the source requested, so we exit from the loop
								break;
							}

							if (data === null || data[a[i]] === undefined) {
								return undefined;
							}
							data = data[a[i]];
						}
					}

					return data;
				};

				return function (data, type) {
					return fetchData(data, type, mSource);
				};
			}
			else {
				/* Array or flat object mapping */
				return function (data, type) {
					return data[mSource];
				};
			}
		}


		/**
		 * Return a function that can be used to set data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data set function
		 *  @memberof DataTable#oApi
		 */
		function _fnSetObjectDataFn(mSource) {
			if (mSource === null) {
				/* Nothing to do when the data source is null */
				return function (data, val) { };
			}
			else if (typeof mSource === 'function') {
				return function (data, val) {
					mSource(data, 'set', val);
				};
			}
			else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1)) {
				/* Like the get, we need to get data from a nested object */
				var setData = function (data, val, src) {
					var a = src.split('.'), b;
					var arrayNotation, o, innerSrc;

					for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
						// Check if we are dealing with an array notation request
						arrayNotation = a[i].match(__reArray);

						if (arrayNotation) {
							a[i] = a[i].replace(__reArray, '');
							data[a[i]] = [];

							// Get the remainder of the nested object to set so we can recurse
							b = a.slice();
							b.splice(0, i + 1);
							innerSrc = b.join('.');

							// Traverse each entry in the array setting the properties requested
							for (var j = 0, jLen = val.length; j < jLen; j++) {
								o = {};
								setData(o, val[j], innerSrc);
								data[a[i]].push(o);
							}

							// The inner call to setData has already traversed through the remainder
							// of the source and has set the data, thus we can exit here
							return;
						}

						// If the nested object doesn't currently exist - since we are
						// trying to set the value - create it
						if (data[a[i]] === null || data[a[i]] === undefined) {
							data[a[i]] = {};
						}
						data = data[a[i]];
					}

					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn't used, then we get the result we want anyway
					data[a[a.length - 1].replace(__reArray, '')] = val;
				};

				return function (data, val) {
					return setData(data, val, mSource);
				};
			}
			else {
				/* Array or flat object mapping */
				return function (data, val) {
					data[mSource] = val;
				};
			}
		}


		/**
		 * Return an array with the full table data
		 *  @param {object} oSettings dataTables settings object
		 *  @returns array {array} aData Master data array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetDataMaster(oSettings) {
			var aData = [];
			var iLen = oSettings.aoData.length;
			for (var i = 0; i < iLen; i++) {
				aData.push(oSettings.aoData[i]._aData);
			}
			return aData;
		}


		/**
		 * Nuke the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnClearTable(oSettings) {
			oSettings.aoData.splice(0, oSettings.aoData.length);
			oSettings.aiDisplayMaster.splice(0, oSettings.aiDisplayMaster.length);
			oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);
			_fnCalculateEnd(oSettings);
		}


		/**
		* Take an array of integers (index array) and remove a target integer (value - not 
		* the key!)
		*  @param {array} a Index array to target
		*  @param {int} iTarget value to find
		*  @memberof DataTable#oApi
		*/
		function _fnDeleteIndex(a, iTarget) {
			var iTargetIndex = -1;

			for (var i = 0, iLen = a.length; i < iLen; i++) {
				if (a[i] == iTarget) {
					iTargetIndex = i;
				}
				else if (a[i] > iTarget) {
					a[i]--;
				}
			}

			if (iTargetIndex != -1) {
				a.splice(iTargetIndex, 1);
			}
		}


		/**
		* Call the developer defined fnRender function for a given cell (row/column) with
		* the required parameters and return the result.
		*  @param {object} oSettings dataTables settings object
		*  @param {int} iRow aoData index for the row
		*  @param {int} iCol aoColumns index for the column
		*  @returns {*} Return of the developer's fnRender function
		*  @memberof DataTable#oApi
		*/
		function _fnRender(oSettings, iRow, iCol) {
			var oCol = oSettings.aoColumns[iCol];

			return oCol.fnRender({
				"iDataRow": iRow,
				"iDataColumn": iCol,
				"oSettings": oSettings,
				"aData": oSettings.aoData[iRow]._aData,
				"mDataProp": oCol.mData
			}, _fnGetCellData(oSettings, iRow, iCol, 'display'));
		}

		/**
		 * Create a new TR element (and it's TD children) for a row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow Row to consider
		 *  @memberof DataTable#oApi
		 */
		function _fnCreateTr(oSettings, iRow) {
			var oData = oSettings.aoData[iRow];
			var nTd;

			if (oData.nTr === null) {
				oData.nTr = document.createElement('tr');

				/* Use a private property on the node to allow reserve mapping from the node
				 * to the aoData array for fast look up
				 */
				oData.nTr._DT_RowIndex = iRow;

				/* Special parameters can be given by the data source to be used on the row */
				if (oData._aData.DT_RowId) {
					oData.nTr.id = oData._aData.DT_RowId;
				}

				if (oData._aData.DT_RowClass) {
					$(oData.nTr).addClass(oData._aData.DT_RowClass);
				}

				/* Process each column */
				for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
					var oCol = oSettings.aoColumns[i];
					nTd = document.createElement(oCol.sCellType);

					/* Render if needed - if bUseRendered is true then we already have the rendered
					 * value in the data source - so can just use that
					 */
					nTd.innerHTML = (typeof oCol.fnRender === 'function' && (!oCol.bUseRendered || oCol.mData === null)) ?
						_fnRender(oSettings, iRow, i) :
						_fnGetCellData(oSettings, iRow, i, 'display');

					/* Add user defined class */
					if (oCol.sClass !== null) {
						nTd.className = oCol.sClass;
					}

					if (oCol.bVisible) {
						oData.nTr.appendChild(nTd);
						oData._anHidden[i] = null;
					}
					else {
						oData._anHidden[i] = nTd;
					}

					if (oCol.fnCreatedCell) {
						oCol.fnCreatedCell.call(oSettings.oInstance,
							nTd, _fnGetCellData(oSettings, iRow, i, 'display'), oData._aData, iRow, i
						);
					}
				}

				_fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, iRow]);
			}
		}


		/**
		 * Create the HTML header for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildHead(oSettings) {
			var i, nTh, iLen, j, jLen;
			var iThs = oSettings.nTHead.getElementsByTagName('th').length;
			var iCorrector = 0;
			var jqChildren;

			/* If there is a header in place - then use it - otherwise it's going to get nuked... */
			if (iThs !== 0) {
				/* We've got a thead from the DOM, so remove hidden columns and apply width to vis cols */
				for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
					nTh = oSettings.aoColumns[i].nTh;
					nTh.setAttribute('role', 'columnheader');
					if (oSettings.aoColumns[i].bSortable) {
						nTh.setAttribute('tabindex', oSettings.iTabIndex);
						nTh.setAttribute('aria-controls', oSettings.sTableId);
					}

					if (oSettings.aoColumns[i].sClass !== null) {
						$(nTh).addClass(oSettings.aoColumns[i].sClass);
					}

					/* Set the title of the column if it is user defined (not what was auto detected) */
					if (oSettings.aoColumns[i].sTitle != nTh.innerHTML) {
						nTh.innerHTML = oSettings.aoColumns[i].sTitle;
					}
				}
			}
			else {
				/* We don't have a header in the DOM - so we are going to have to create one */
				var nTr = document.createElement("tr");

				for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
					nTh = oSettings.aoColumns[i].nTh;
					nTh.innerHTML = oSettings.aoColumns[i].sTitle;
					nTh.setAttribute('tabindex', '0');

					if (oSettings.aoColumns[i].sClass !== null) {
						$(nTh).addClass(oSettings.aoColumns[i].sClass);
					}

					nTr.appendChild(nTh);
				}
				$(oSettings.nTHead).html('')[0].appendChild(nTr);
				_fnDetectHeader(oSettings.aoHeader, oSettings.nTHead);
			}

			/* ARIA role for the rows */
			$(oSettings.nTHead).children('tr').attr('role', 'row');

			/* Add the extra markup needed by jQuery UI's themes */
			if (oSettings.bJUI) {
				for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
					nTh = oSettings.aoColumns[i].nTh;

					var nDiv = document.createElement('div');
					nDiv.className = oSettings.oClasses.sSortJUIWrapper;
					$(nTh).contents().appendTo(nDiv);

					var nSpan = document.createElement('span');
					nSpan.className = oSettings.oClasses.sSortIcon;
					nDiv.appendChild(nSpan);
					nTh.appendChild(nDiv);
				}
			}

			if (oSettings.oFeatures.bSort) {
				for (i = 0; i < oSettings.aoColumns.length; i++) {
					if (oSettings.aoColumns[i].bSortable !== false) {
						_fnSortAttachListener(oSettings, oSettings.aoColumns[i].nTh, i);
					}
					else {
						$(oSettings.aoColumns[i].nTh).addClass(oSettings.oClasses.sSortableNone);
					}
				}
			}

			/* Deal with the footer - add classes if required */
			if (oSettings.oClasses.sFooterTH !== "") {
				$(oSettings.nTFoot).children('tr').children('th').addClass(oSettings.oClasses.sFooterTH);
			}

			/* Cache the footer elements */
			if (oSettings.nTFoot !== null) {
				var anCells = _fnGetUniqueThs(oSettings, null, oSettings.aoFooter);
				for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
					if (anCells[i]) {
						oSettings.aoColumns[i].nTf = anCells[i];
						if (oSettings.aoColumns[i].sClass) {
							$(anCells[i]).addClass(oSettings.aoColumns[i].sClass);
						}
					}
				}
			}
		}


		/**
		 * Draw the header (or footer) element based on the column visibility states. The
		 * methodology here is to use the layout array from _fnDetectHeader, modified for
		 * the instantaneous column visibility, to construct the new layout. The grid is
		 * traversed over cell at a time in a rows x columns grid fashion, although each 
		 * cell insert can cover multiple elements in the grid - which is tracks using the
		 * aApplied array. Cell inserts in the grid will only occur where there isn't
		 * already a cell in that position.
		 *  @param {object} oSettings dataTables settings object
		 *  @param array {objects} aoSource Layout array from _fnDetectHeader
		 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc, 
		 *  @memberof DataTable#oApi
		 */
		function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
			var i, iLen, j, jLen, k, kLen, n, nLocalTr;
			var aoLocal = [];
			var aApplied = [];
			var iColumns = oSettings.aoColumns.length;
			var iRowspan, iColspan;

			if (bIncludeHidden === undefined) {
				bIncludeHidden = false;
			}

			/* Make a copy of the master layout array, but without the visible columns in it */
			for (i = 0, iLen = aoSource.length; i < iLen; i++) {
				aoLocal[i] = aoSource[i].slice();
				aoLocal[i].nTr = aoSource[i].nTr;

				/* Remove any columns which are currently hidden */
				for (j = iColumns - 1; j >= 0; j--) {
					if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
						aoLocal[i].splice(j, 1);
					}
				}

				/* Prep the applied array - it needs an element for each row */
				aApplied.push([]);
			}

			for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
				nLocalTr = aoLocal[i].nTr;

				/* All cells are going to be replaced, so empty out the row */
				if (nLocalTr) {
					while ((n = nLocalTr.firstChild)) {
						nLocalTr.removeChild(n);
					}
				}

				for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
					iRowspan = 1;
					iColspan = 1;

					/* Check to see if there is already a cell (row/colspan) covering our target
					 * insert point. If there is, then there is nothing to do.
					 */
					if (aApplied[i][j] === undefined) {
						nLocalTr.appendChild(aoLocal[i][j].cell);
						aApplied[i][j] = 1;

						/* Expand the cell to cover as many rows as needed */
						while (aoLocal[i + iRowspan] !== undefined &&
							aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
							aApplied[i + iRowspan][j] = 1;
							iRowspan++;
						}

						/* Expand the cell to cover as many columns as needed */
						while (aoLocal[i][j + iColspan] !== undefined &&
							aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
							/* Must update the applied array over the rows for the columns */
							for (k = 0; k < iRowspan; k++) {
								aApplied[i + k][j + iColspan] = 1;
							}
							iColspan++;
						}

						/* Do the actual expansion in the DOM */
						aoLocal[i][j].cell.rowSpan = iRowspan;
						aoLocal[i][j].cell.colSpan = iColspan;
					}
				}
			}
		}


		/**
		 * Insert the required TR nodes into the table for display
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnDraw(oSettings) {
			/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
			var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
			if ($.inArray(false, aPreDraw) !== -1) {
				_fnProcessingDisplay(oSettings, false);
				return;
			}

			var i, iLen, n;
			var anRows = [];
			var iRowCount = 0;
			var iStripes = oSettings.asStripeClasses.length;
			var iOpenRows = oSettings.aoOpenRows.length;

			oSettings.bDrawing = true;

			/* Check and see if we have an initial draw position from state saving */
			if (oSettings.iInitDisplayStart !== undefined && oSettings.iInitDisplayStart != -1) {
				if (oSettings.oFeatures.bServerSide) {
					oSettings._iDisplayStart = oSettings.iInitDisplayStart;
				}
				else {
					oSettings._iDisplayStart = (oSettings.iInitDisplayStart >= oSettings.fnRecordsDisplay()) ?
						0 : oSettings.iInitDisplayStart;
				}
				oSettings.iInitDisplayStart = -1;
				_fnCalculateEnd(oSettings);
			}

			/* Server-side processing draw intercept */
			if (oSettings.bDeferLoading) {
				oSettings.bDeferLoading = false;
				oSettings.iDraw++;
			}
			else if (!oSettings.oFeatures.bServerSide) {
				oSettings.iDraw++;
			}
			else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
				return;
			}

			if (oSettings.aiDisplay.length !== 0) {
				var iStart = oSettings._iDisplayStart;
				var iEnd = oSettings._iDisplayEnd;

				if (oSettings.oFeatures.bServerSide) {
					iStart = 0;
					iEnd = oSettings.aoData.length;
				}

				for (var j = iStart; j < iEnd; j++) {
					var aoData = oSettings.aoData[oSettings.aiDisplay[j]];
					if (aoData.nTr === null) {
						_fnCreateTr(oSettings, oSettings.aiDisplay[j]);
					}

					var nRow = aoData.nTr;

					/* Remove the old striping classes and then add the new one */
					if (iStripes !== 0) {
						var sStripe = oSettings.asStripeClasses[iRowCount % iStripes];
						if (aoData._sRowStripe != sStripe) {
							$(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
							aoData._sRowStripe = sStripe;
						}
					}

					/* Row callback functions - might want to manipulate the row */
					_fnCallbackFire(oSettings, 'aoRowCallback', null,
						[nRow, oSettings.aoData[oSettings.aiDisplay[j]]._aData, iRowCount, j]);

					anRows.push(nRow);
					iRowCount++;

					/* If there is an open row - and it is attached to this parent - attach it on redraw */
					if (iOpenRows !== 0) {
						for (var k = 0; k < iOpenRows; k++) {
							if (nRow == oSettings.aoOpenRows[k].nParent) {
								anRows.push(oSettings.aoOpenRows[k].nTr);
								break;
							}
						}
					}
				}
			}
			else {
				/* Table is empty - create a row with an empty message in it */
				anRows[0] = document.createElement('tr');

				if (oSettings.asStripeClasses[0]) {
					anRows[0].className = oSettings.asStripeClasses[0];
				}

				var oLang = oSettings.oLanguage;
				var sZero = oLang.sZeroRecords;
				if (oSettings.iDraw == 1 && oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide) {
					sZero = oLang.sLoadingRecords;
				}
				else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
					sZero = oLang.sEmptyTable;
				}

				var nTd = document.createElement('td');
				nTd.setAttribute('valign', "top");
				nTd.colSpan = _fnVisbleColumns(oSettings);
				nTd.className = oSettings.oClasses.sRowEmpty;
				nTd.innerHTML = _fnInfoMacros(oSettings, sZero);

				anRows[iRowCount].appendChild(nTd);
			}

			/* Header and footer callbacks */
			_fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0],
			_fnGetDataMaster(oSettings), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay]);

			_fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0],
			_fnGetDataMaster(oSettings), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay]);

			/* 
			 * Need to remove any old row from the display - note we can't just empty the tbody using
			 * $().html('') since this will unbind the jQuery event handlers (even although the node 
			 * still exists!) - equally we can't use innerHTML, since IE throws an exception.
			 */
			var
				nAddFrag = document.createDocumentFragment(),
				nRemoveFrag = document.createDocumentFragment(),
				nBodyPar, nTrs;

			if (oSettings.nTBody) {
				nBodyPar = oSettings.nTBody.parentNode;
				nRemoveFrag.appendChild(oSettings.nTBody);

				/* When doing infinite scrolling, only remove child rows when sorting, filtering or start
				 * up. When not infinite scroll, always do it.
				 */
				if (!oSettings.oScroll.bInfinite || !oSettings._bInitComplete ||
					oSettings.bSorted || oSettings.bFiltered) {
					while ((n = oSettings.nTBody.firstChild)) {
						oSettings.nTBody.removeChild(n);
					}
				}

				/* Put the draw table into the dom */
				for (i = 0, iLen = anRows.length; i < iLen; i++) {
					nAddFrag.appendChild(anRows[i]);
				}

				oSettings.nTBody.appendChild(nAddFrag);
				if (nBodyPar !== null) {
					nBodyPar.appendChild(oSettings.nTBody);
				}
			}

			/* Call all required callback functions for the end of a draw */
			_fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);

			/* Draw is complete, sorting and filtering must be as well */
			oSettings.bSorted = false;
			oSettings.bFiltered = false;
			oSettings.bDrawing = false;

			if (oSettings.oFeatures.bServerSide) {
				_fnProcessingDisplay(oSettings, false);
				if (!oSettings._bInitComplete) {
					_fnInitComplete(oSettings);
				}
			}
		}


		/**
		 * Redraw the table - taking account of the various features which are enabled
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnReDraw(oSettings) {
			if (oSettings.oFeatures.bSort) {
				/* Sorting will refilter and draw for us */
				_fnSort(oSettings, oSettings.oPreviousSearch);
			}
			else if (oSettings.oFeatures.bFilter) {
				/* Filtering will redraw for us */
				_fnFilterComplete(oSettings, oSettings.oPreviousSearch);
			}
			else {
				_fnCalculateEnd(oSettings);
				_fnDraw(oSettings);
			}
		}


		/**
		 * Add the options to the page HTML for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAddOptionsHtml(oSettings) {
			/*
			 * Create a temporary, empty, div which we can later on replace with what we have generated
			 * we do it this way to rendering the 'options' html offline - speed :-)
			 */
			var nHolding = $('<div></div>')[0];
			oSettings.nTable.parentNode.insertBefore(nHolding, oSettings.nTable);

			/* 
			 * All DataTables are wrapped in a div
			 */
			oSettings.nTableWrapper = $('<div id="' + oSettings.sTableId + '_wrapper" class="' + oSettings.oClasses.sWrapper + '" role="grid"></div>')[0];
			oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

			/* Track where we want to insert the option */
			var nInsertNode = oSettings.nTableWrapper;

			/* Loop over the user set positioning and place the elements as needed */
			var aDom = oSettings.sDom.split('');
			var nTmp, iPushFeature, cOption, nNewNode, cNext, sAttr, j;
			for (var i = 0; i < aDom.length; i++) {
				iPushFeature = 0;
				cOption = aDom[i];

				if (cOption == '<') {
					/* New container div */
					nNewNode = $('<div></div>')[0];

					/* Check to see if we should append an id and/or a class name to the container */
					cNext = aDom[i + 1];
					if (cNext == "'" || cNext == '"') {
						sAttr = "";
						j = 2;
						while (aDom[i + j] != cNext) {
							sAttr += aDom[i + j];
							j++;
						}

						/* Replace jQuery UI constants */
						if (sAttr == "H") {
							sAttr = oSettings.oClasses.sJUIHeader;
						}
						else if (sAttr == "F") {
							sAttr = oSettings.oClasses.sJUIFooter;
						}

						/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
						 * breaks the string into parts and applies them as needed
						 */
						if (sAttr.indexOf('.') != -1) {
							var aSplit = sAttr.split('.');
							nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
							nNewNode.className = aSplit[1];
						}
						else if (sAttr.charAt(0) == "#") {
							nNewNode.id = sAttr.substr(1, sAttr.length - 1);
						}
						else {
							nNewNode.className = sAttr;
						}

						i += j; /* Move along the position array */
					}

					nInsertNode.appendChild(nNewNode);
					nInsertNode = nNewNode;
				}
				else if (cOption == '>') {
					/* End container div */
					nInsertNode = nInsertNode.parentNode;
				}
				else if (cOption == 'l' && oSettings.oFeatures.bPaginate && oSettings.oFeatures.bLengthChange) {
					/* Length */
					nTmp = _fnFeatureHtmlLength(oSettings);
					iPushFeature = 1;
				}
				else if (cOption == 'f' && oSettings.oFeatures.bFilter) {
					/* Filter */
					nTmp = _fnFeatureHtmlFilter(oSettings);
					iPushFeature = 1;
				}
				else if (cOption == 'r' && oSettings.oFeatures.bProcessing) {
					/* pRocessing */
					nTmp = _fnFeatureHtmlProcessing(oSettings);
					iPushFeature = 1;
				}
				else if (cOption == 't') {
					/* Table */
					nTmp = _fnFeatureHtmlTable(oSettings);
					iPushFeature = 1;
				}
				else if (cOption == 'i' && oSettings.oFeatures.bInfo) {
					/* Info */
					nTmp = _fnFeatureHtmlInfo(oSettings);
					iPushFeature = 1;
				}
				else if (cOption == 'p' && oSettings.oFeatures.bPaginate) {
					/* Pagination */
					nTmp = _fnFeatureHtmlPaginate(oSettings);
					iPushFeature = 1;
				}
				else if (DataTable.ext.aoFeatures.length !== 0) {
					/* Plug-in features */
					var aoFeatures = DataTable.ext.aoFeatures;
					for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
						if (cOption == aoFeatures[k].cFeature) {
							nTmp = aoFeatures[k].fnInit(oSettings);
							if (nTmp) {
								iPushFeature = 1;
							}
							break;
						}
					}
				}

				/* Add to the 2D features array */
				if (iPushFeature == 1 && nTmp !== null) {
					if (typeof oSettings.aanFeatures[cOption] !== 'object') {
						oSettings.aanFeatures[cOption] = [];
					}
					oSettings.aanFeatures[cOption].push(nTmp);
					nInsertNode.appendChild(nTmp);
				}
			}

			/* Built our DOM structure - replace the holding div with what we want */
			nHolding.parentNode.replaceChild(oSettings.nTableWrapper, nHolding);
		}


		/**
		 * Use the DOM source to create up an array of header cells. The idea here is to
		 * create a layout grid (array) of rows x columns, which contains a reference
		 * to the cell that that point in the grid (regardless of col/rowspan), such that
		 * any column / row could be removed and the new grid constructed
		 *  @param array {object} aLayout Array to store the calculated layout in
		 *  @param {node} nThead The header/footer element for the table
		 *  @memberof DataTable#oApi
		 */
		function _fnDetectHeader(aLayout, nThead) {
			var nTrs = $(nThead).children('tr');
			var nCell;
			var i, j, k, l, iLen, jLen, iColShifted;
			var fnShiftCol = function (a, i, j) {
				while (a[i][j]) {
					j++;
				}
				return j;
			};

			aLayout.splice(0, aLayout.length);

			/* We know how many rows there are in the layout - so prep it */
			for (i = 0, iLen = nTrs.length; i < iLen; i++) {
				aLayout.push([]);
			}

			/* Calculate a layout array */
			for (i = 0, iLen = nTrs.length; i < iLen; i++) {
				var iColumn = 0;

				/* For every cell in the row... */
				for (j = 0, jLen = nTrs[i].childNodes.length; j < jLen; j++) {
					nCell = nTrs[i].childNodes[j];

					if (nCell.nodeName.toUpperCase() == "TD" ||
						nCell.nodeName.toUpperCase() == "TH") {
						/* Get the col and rowspan attributes from the DOM and sanitise them */
						var iColspan = nCell.getAttribute('colspan') * 1;
						var iRowspan = nCell.getAttribute('rowspan') * 1;
						iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;
						iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;

						/* There might be colspan cells already in this row, so shift our target 
						 * accordingly
						 */
						iColShifted = fnShiftCol(aLayout, i, iColumn);

						/* If there is col / rowspan, copy the information into the layout grid */
						for (l = 0; l < iColspan; l++) {
							for (k = 0; k < iRowspan; k++) {
								aLayout[i + k][iColShifted + l] = {
									"cell": nCell,
									"unique": iColspan == 1 ? true : false
								};
								aLayout[i + k].nTr = nTrs[i];
							}
						}
					}
				}
			}
		}


		/**
		 * Get an array of unique th elements, one for each column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nHeader automatically detect the layout from this node - optional
		 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
		 *  @returns array {node} aReturn list of unique th's
		 *  @memberof DataTable#oApi
		 */
		function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
			var aReturn = [];
			if (!aLayout) {
				aLayout = oSettings.aoHeader;
				if (nHeader) {
					aLayout = [];
					_fnDetectHeader(aLayout, nHeader);
				}
			}

			for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
				for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
					if (aLayout[i][j].unique &&
						(!aReturn[j] || !oSettings.bSortCellsTop)) {
						aReturn[j] = aLayout[i][j].cell;
					}
				}
			}

			return aReturn;
		}



		/**
		 * Update the table using an Ajax call
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {boolean} Block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdate(oSettings) {
			if (oSettings.bAjaxDataGet) {
				oSettings.iDraw++;
				_fnProcessingDisplay(oSettings, true);
				var iColumns = oSettings.aoColumns.length;
				var aoData = _fnAjaxParameters(oSettings);
				_fnServerParams(oSettings, aoData);

				oSettings.fnServerData.call(oSettings.oInstance, oSettings.sAjaxSource, aoData,
					function (json) {
						_fnAjaxUpdateDraw(oSettings, json);
					}, oSettings);
				return false;
			}
			else {
				return true;
			}
		}


		/**
		 * Build up the parameters in an object needed for a server-side processing request
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {bool} block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxParameters(oSettings) {
			var iColumns = oSettings.aoColumns.length;
			var aoData = [], mDataProp, aaSort, aDataSort;
			var i, j;

			aoData.push({ "name": "sEcho", "value": oSettings.iDraw });
			aoData.push({ "name": "iColumns", "value": iColumns });
			aoData.push({ "name": "sColumns", "value": _fnColumnOrdering(oSettings) });
			aoData.push({ "name": "iDisplayStart", "value": oSettings._iDisplayStart });
			aoData.push({
				"name": "iDisplayLength", "value": oSettings.oFeatures.bPaginate !== false ?
					oSettings._iDisplayLength : -1
			});

			for (i = 0; i < iColumns; i++) {
				mDataProp = oSettings.aoColumns[i].mData;
				aoData.push({ "name": "mDataProp_" + i, "value": typeof (mDataProp) === "function" ? 'function' : mDataProp });
			}

			/* Filtering */
			if (oSettings.oFeatures.bFilter !== false) {
				aoData.push({ "name": "sSearch", "value": oSettings.oPreviousSearch.sSearch });
				aoData.push({ "name": "bRegex", "value": oSettings.oPreviousSearch.bRegex });
				for (i = 0; i < iColumns; i++) {
					aoData.push({ "name": "sSearch_" + i, "value": oSettings.aoPreSearchCols[i].sSearch });
					aoData.push({ "name": "bRegex_" + i, "value": oSettings.aoPreSearchCols[i].bRegex });
					aoData.push({ "name": "bSearchable_" + i, "value": oSettings.aoColumns[i].bSearchable });
				}
			}

			/* Sorting */
			if (oSettings.oFeatures.bSort !== false) {
				var iCounter = 0;

				aaSort = (oSettings.aaSortingFixed !== null) ?
					oSettings.aaSortingFixed.concat(oSettings.aaSorting) :
					oSettings.aaSorting.slice();

				for (i = 0; i < aaSort.length; i++) {
					aDataSort = oSettings.aoColumns[aaSort[i][0]].aDataSort;

					for (j = 0; j < aDataSort.length; j++) {
						aoData.push({ "name": "iSortCol_" + iCounter, "value": aDataSort[j] });
						aoData.push({ "name": "sSortDir_" + iCounter, "value": aaSort[i][1] });
						iCounter++;
					}
				}
				aoData.push({ "name": "iSortingCols", "value": iCounter });

				for (i = 0; i < iColumns; i++) {
					aoData.push({ "name": "bSortable_" + i, "value": oSettings.aoColumns[i].bSortable });
				}
			}

			return aoData;
		}


		/**
		 * Add Ajax parameters from plug-ins
		 *  @param {object} oSettings dataTables settings object
		 *  @param array {objects} aoData name/value pairs to send to the server
		 *  @memberof DataTable#oApi
		 */
		function _fnServerParams(oSettings, aoData) {
			_fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [aoData]);
		}


		/**
		 * Data the data from the server (nuking the old) and redraw the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} json json data return from the server.
		 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
		 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
		 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
		 *  @param {array} json.aaData The data to display on this page
		 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdateDraw(oSettings, json) {
			if (json.sEcho !== undefined) {
				/* Protect against old returns over-writing a new one. Possible when you get
				 * very fast interaction, and later queries are completed much faster
				 */
				if (json.sEcho * 1 < oSettings.iDraw) {
					return;
				}
				else {
					oSettings.iDraw = json.sEcho * 1;
				}
			}

			if (!oSettings.oScroll.bInfinite ||
				(oSettings.oScroll.bInfinite && (oSettings.bSorted || oSettings.bFiltered))) {
				_fnClearTable(oSettings);
			}
			oSettings._iRecordsTotal = parseInt(json.iTotalRecords, 10);
			oSettings._iRecordsDisplay = parseInt(json.iTotalDisplayRecords, 10);

			/* Determine if reordering is required */
			var sOrdering = _fnColumnOrdering(oSettings);
			var bReOrder = (json.sColumns !== undefined && sOrdering !== "" && json.sColumns != sOrdering);
			var aiIndex;
			if (bReOrder) {
				aiIndex = _fnReOrderIndex(oSettings, json.sColumns);
			}

			var aData = _fnGetObjectDataFn(oSettings.sAjaxDataProp)(json);
			for (var i = 0, iLen = aData.length; i < iLen; i++) {
				if (bReOrder) {
					/* If we need to re-order, then create a new array with the correct order and add it */
					var aDataSorted = [];
					for (var j = 0, jLen = oSettings.aoColumns.length; j < jLen; j++) {
						aDataSorted.push(aData[i][aiIndex[j]]);
					}
					_fnAddData(oSettings, aDataSorted);
				}
				else {
					/* No re-order required, sever got it "right" - just straight add */
					_fnAddData(oSettings, aData[i]);
				}
			}
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

			oSettings.bAjaxDataGet = false;
			_fnDraw(oSettings);
			oSettings.bAjaxDataGet = true;
			_fnProcessingDisplay(oSettings, false);
		}



		/**
		 * Generate the node required for filtering text
		 *  @returns {node} Filter control element
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlFilter(oSettings) {
			var oPreviousSearch = oSettings.oPreviousSearch;

			var sSearchStr = oSettings.oLanguage.sSearch;
			sSearchStr = (sSearchStr.indexOf('_INPUT_') !== -1) ?
				sSearchStr.replace('_INPUT_', '<input type="text" />') :
				sSearchStr === "" ? '<input type="text" />' : sSearchStr + ' <input type="text" />';

			var nFilter = document.createElement('div');
			nFilter.className = oSettings.oClasses.sFilter;
			nFilter.innerHTML = '<label>' + sSearchStr + '</label>';
			if (!oSettings.aanFeatures.f) {
				nFilter.id = oSettings.sTableId + '_filter';
			}

			var jqFilter = $('input[type="text"]', nFilter);

			// Store a reference to the input element, so other input elements could be
			// added to the filter wrapper if needed (submit button for example)
			nFilter._DT_Input = jqFilter[0];

			jqFilter.val(oPreviousSearch.sSearch.replace('"', '&quot;'));
			jqFilter.bind('keyup.DT', function (e) {
				/* Update all other filter input elements for the new display */
				var n = oSettings.aanFeatures.f;
				var val = this.value === "" ? "" : this.value; // mental IE8 fix :-(

				for (var i = 0, iLen = n.length; i < iLen; i++) {
					if (n[i] != $(this).parents('div.dataTables_filter')[0]) {
						$(n[i]._DT_Input).val(val);
					}
				}

				/* Now do the filter */
				if (val != oPreviousSearch.sSearch) {
					_fnFilterComplete(oSettings, {
						"sSearch": val,
						"bRegex": oPreviousSearch.bRegex,
						"bSmart": oPreviousSearch.bSmart,
						"bCaseInsensitive": oPreviousSearch.bCaseInsensitive
					});
				}
			});

			jqFilter
				.attr('aria-controls', oSettings.sTableId)
				.bind('keypress.DT', function (e) {
					/* Prevent form submission */
					if (e.keyCode == 13) {
						return false;
					}
				}
				);

			return nFilter;
		}


		/**
		 * Filter the table using both the global filter and column based filtering
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oSearch search information
		 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterComplete(oSettings, oInput, iForce) {
			var oPrevSearch = oSettings.oPreviousSearch;
			var aoPrevSearch = oSettings.aoPreSearchCols;
			var fnSaveFilter = function (oFilter) {
				/* Save the filtering values */
				oPrevSearch.sSearch = oFilter.sSearch;
				oPrevSearch.bRegex = oFilter.bRegex;
				oPrevSearch.bSmart = oFilter.bSmart;
				oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
			};

			/* In server-side processing all filtering is done by the server, so no point hanging around here */
			if (!oSettings.oFeatures.bServerSide) {
				/* Global filter */
				_fnFilter(oSettings, oInput.sSearch, iForce, oInput.bRegex, oInput.bSmart, oInput.bCaseInsensitive);
				fnSaveFilter(oInput);

				/* Now do the individual column filter */
				for (var i = 0; i < oSettings.aoPreSearchCols.length; i++) {
					_fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, aoPrevSearch[i].bRegex,
						aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
				}

				/* Custom filtering */
				_fnFilterCustom(oSettings);
			}
			else {
				fnSaveFilter(oInput);
			}

			/* Tell the draw function we have been filtering */
			oSettings.bFiltered = true;
			$(oSettings.oInstance).trigger('filter', oSettings);

			/* Redraw the table */
			oSettings._iDisplayStart = 0;
			_fnCalculateEnd(oSettings);
			_fnDraw(oSettings);

			/* Rebuild search array 'offline' */
			_fnBuildSearchArray(oSettings, 0);
		}


		/**
		 * Apply custom filtering functions
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCustom(oSettings) {
			var afnFilters = DataTable.ext.afnFiltering;
			var aiFilterColumns = _fnGetColumns(oSettings, 'bSearchable');

			for (var i = 0, iLen = afnFilters.length; i < iLen; i++) {
				var iCorrector = 0;
				for (var j = 0, jLen = oSettings.aiDisplay.length; j < jLen; j++) {
					var iDisIndex = oSettings.aiDisplay[j - iCorrector];
					var bTest = afnFilters[i](
						oSettings,
						_fnGetRowData(oSettings, iDisIndex, 'filter', aiFilterColumns),
						iDisIndex
					);

					/* Check if we should use this row based on the filtering function */
					if (!bTest) {
						oSettings.aiDisplay.splice(j - iCorrector, 1);
						iCorrector++;
					}
				}
			}
		}


		/**
		 * Filter the table on a per-column basis
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sInput string to filter on
		 *  @param {int} iColumn column to filter
		 *  @param {bool} bRegex treat search string as a regular expression or not
		 *  @param {bool} bSmart use smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterColumn(oSettings, sInput, iColumn, bRegex, bSmart, bCaseInsensitive) {
			if (sInput === "") {
				return;
			}

			var iIndexCorrector = 0;
			var rpSearch = _fnFilterCreateSearch(sInput, bRegex, bSmart, bCaseInsensitive);

			for (var i = oSettings.aiDisplay.length - 1; i >= 0; i--) {
				var sData = _fnDataToSearch(_fnGetCellData(oSettings, oSettings.aiDisplay[i], iColumn, 'filter'),
					oSettings.aoColumns[iColumn].sType);
				if (!rpSearch.test(sData)) {
					oSettings.aiDisplay.splice(i, 1);
					iIndexCorrector++;
				}
			}
		}


		/**
		 * Filter the data table based on user input and draw the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sInput string to filter on
		 *  @param {int} iForce optional - force a research of the master array (1) or not (undefined or 0)
		 *  @param {bool} bRegex treat as a regular expression or not
		 *  @param {bool} bSmart perform smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilter(oSettings, sInput, iForce, bRegex, bSmart, bCaseInsensitive) {
			var i;
			var rpSearch = _fnFilterCreateSearch(sInput, bRegex, bSmart, bCaseInsensitive);
			var oPrevSearch = oSettings.oPreviousSearch;

			/* Check if we are forcing or not - optional parameter */
			if (!iForce) {
				iForce = 0;
			}

			/* Need to take account of custom filtering functions - always filter */
			if (DataTable.ext.afnFiltering.length !== 0) {
				iForce = 1;
			}

			/*
			 * If the input is blank - we want the full data set
			 */
			if (sInput.length <= 0) {
				oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			}
			else {
				/*
				 * We are starting a new search or the new search string is smaller 
				 * then the old one (i.e. delete). Search from the master array
				  */
				if (oSettings.aiDisplay.length == oSettings.aiDisplayMaster.length ||
					oPrevSearch.sSearch.length > sInput.length || iForce == 1 ||
					sInput.indexOf(oPrevSearch.sSearch) !== 0) {
					/* Nuke the old display array - we are going to rebuild it */
					oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);

					/* Force a rebuild of the search array */
					_fnBuildSearchArray(oSettings, 1);

					/* Search through all records to populate the search array
					 * The the oSettings.aiDisplayMaster and asDataSearch arrays have 1 to 1 
					 * mapping
					 */
					for (i = 0; i < oSettings.aiDisplayMaster.length; i++) {
						if (rpSearch.test(oSettings.asDataSearch[i])) {
							oSettings.aiDisplay.push(oSettings.aiDisplayMaster[i]);
						}
					}
				}
				else {
					/* Using old search array - refine it - do it this way for speed
					 * Don't have to search the whole master array again
					   */
					var iIndexCorrector = 0;

					/* Search the current results */
					for (i = 0; i < oSettings.asDataSearch.length; i++) {
						if (!rpSearch.test(oSettings.asDataSearch[i])) {
							oSettings.aiDisplay.splice(i - iIndexCorrector, 1);
							iIndexCorrector++;
						}
					}
				}
			}
		}


		/**
		 * Create an array which can be quickly search through
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iMaster use the master data array - optional
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildSearchArray(oSettings, iMaster) {
			if (!oSettings.oFeatures.bServerSide) {
				/* Clear out the old data */
				oSettings.asDataSearch = [];

				var aiFilterColumns = _fnGetColumns(oSettings, 'bSearchable');
				var aiIndex = (iMaster === 1) ?
					oSettings.aiDisplayMaster :
					oSettings.aiDisplay;

				for (var i = 0, iLen = aiIndex.length; i < iLen; i++) {
					oSettings.asDataSearch[i] = _fnBuildSearchRow(
						oSettings,
						_fnGetRowData(oSettings, aiIndex[i], 'filter', aiFilterColumns)
					);
				}
			}
		}


		/**
		 * Create a searchable string from a single data row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aData Row data array to use for the data to search
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildSearchRow(oSettings, aData) {
			var sSearch = aData.join('  ');

			/* If it looks like there is an HTML entity in the string, attempt to decode it */
			if (sSearch.indexOf('&') !== -1) {
				sSearch = $('<div>').html(sSearch).text();
			}

			// Strip newline characters
			return sSearch.replace(/[\n\r]/g, " ");
		}

		/**
		 * Build a regular expression object suitable for searching a table
		 *  @param {string} sSearch string to search for
		 *  @param {bool} bRegex treat as a regular expression or not
		 *  @param {bool} bSmart perform smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
		 *  @returns {RegExp} constructed object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCreateSearch(sSearch, bRegex, bSmart, bCaseInsensitive) {
			var asSearch, sRegExpString;

			if (bSmart) {
				/* Generate the regular expression to use. Something along the lines of:
				 * ^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).*$
				 */
				asSearch = bRegex ? sSearch.split(' ') : _fnEscapeRegex(sSearch).split(' ');
				sRegExpString = '^(?=.*?' + asSearch.join(')(?=.*?') + ').*$';
				return new RegExp(sRegExpString, bCaseInsensitive ? "i" : "");
			}
			else {
				sSearch = bRegex ? sSearch : _fnEscapeRegex(sSearch);
				return new RegExp(sSearch, bCaseInsensitive ? "i" : "");
			}
		}


		/**
		 * Convert raw data into something that the user can search on
		 *  @param {string} sData data to be modified
		 *  @param {string} sType data type
		 *  @returns {string} search string
		 *  @memberof DataTable#oApi
		 */
		function _fnDataToSearch(sData, sType) {
			if (typeof DataTable.ext.ofnSearch[sType] === "function") {
				return DataTable.ext.ofnSearch[sType](sData);
			}
			else if (sData === null) {
				return '';
			}
			else if (sType == "html") {
				return sData.replace(/[\r\n]/g, " ").replace(/<.*?>/g, "");
			}
			else if (typeof sData === "string") {
				return sData.replace(/[\r\n]/g, " ");
			}
			return sData;
		}


		/**
		 * scape a string such that it can be used in a regular expression
		 *  @param {string} sVal string to escape
		 *  @returns {string} escaped string
		 *  @memberof DataTable#oApi
		 */
		function _fnEscapeRegex(sVal) {
			var acEscape = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'];
			var reReplace = new RegExp('(\\' + acEscape.join('|\\') + ')', 'g');
			return sVal.replace(reReplace, '\\$1');
		}



		/**
		 * Generate the node required for the info display
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Information element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlInfo(oSettings) {
			var nInfo = document.createElement('div');
			nInfo.className = oSettings.oClasses.sInfo;

			/* Actions that are to be taken once only for this feature */
			if (!oSettings.aanFeatures.i) {
				/* Add draw callback */
				oSettings.aoDrawCallback.push({
					"fn": _fnUpdateInfo,
					"sName": "information"
				});

				/* Add id */
				nInfo.id = oSettings.sTableId + '_info';
			}
			oSettings.nTable.setAttribute('aria-describedby', oSettings.sTableId + '_info');

			return nInfo;
		}


		/**
		 * Update the information elements in the display
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnUpdateInfo(oSettings) {
			/* Show information about the table */
			if (!oSettings.oFeatures.bInfo || oSettings.aanFeatures.i.length === 0) {
				return;
			}

			var
				oLang = oSettings.oLanguage,
				iStart = oSettings._iDisplayStart + 1,
				iEnd = oSettings.fnDisplayEnd(),
				iMax = oSettings.fnRecordsTotal(),
				iTotal = oSettings.fnRecordsDisplay(),
				sOut;

			if (iTotal === 0 && iTotal == iMax) {
				/* Empty record set */
				sOut = oLang.sInfoEmpty;
			}
			else if (iTotal === 0) {
				/* Empty record set after filtering */
				sOut = oLang.sInfoEmpty + ' ' + oLang.sInfoFiltered;
			}
			else if (iTotal == iMax) {
				/* Normal record set */
				sOut = oLang.sInfo;
			}
			else {
				/* Record set after filtering */
				sOut = oLang.sInfo + ' ' + oLang.sInfoFiltered;
			}

			// Convert the macros
			sOut += oLang.sInfoPostFix;
			sOut = _fnInfoMacros(oSettings, sOut);

			if (oLang.fnInfoCallback !== null) {
				sOut = oLang.fnInfoCallback.call(oSettings.oInstance,
					oSettings, iStart, iEnd, iMax, iTotal, sOut);
			}

			var n = oSettings.aanFeatures.i;
			for (var i = 0, iLen = n.length; i < iLen; i++) {
				$(n[i]).html(sOut);
			}
		}


		function _fnInfoMacros(oSettings, str) {
			var
				iStart = oSettings._iDisplayStart + 1,
				sStart = oSettings.fnFormatNumber(iStart),
				iEnd = oSettings.fnDisplayEnd(),
				sEnd = oSettings.fnFormatNumber(iEnd),
				iTotal = oSettings.fnRecordsDisplay(),
				sTotal = oSettings.fnFormatNumber(iTotal),
				iMax = oSettings.fnRecordsTotal(),
				sMax = oSettings.fnFormatNumber(iMax);

			// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
			// internally
			if (oSettings.oScroll.bInfinite) {
				sStart = oSettings.fnFormatNumber(1);
			}

			return str.
				replace('_START_', sStart).
				replace('_END_', sEnd).
				replace('_TOTAL_', sTotal).
				replace('_MAX_', sMax);
		}



		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnInitialise(oSettings) {
			var i, iLen, iAjaxStart = oSettings.iInitDisplayStart;

			/* Ensure that the table data is fully initialised */
			if (oSettings.bInitialised === false) {
				setTimeout(function () { _fnInitialise(oSettings); }, 200);
				return;
			}

			/* Show the display HTML options */
			_fnAddOptionsHtml(oSettings);

			/* Build and draw the header / footer for the table */
			_fnBuildHead(oSettings);
			_fnDrawHead(oSettings, oSettings.aoHeader);
			if (oSettings.nTFoot) {
				_fnDrawHead(oSettings, oSettings.aoFooter);
			}

			/* Okay to show that something is going on now */
			_fnProcessingDisplay(oSettings, true);

			/* Calculate sizes for columns */
			if (oSettings.oFeatures.bAutoWidth) {
				_fnCalculateColumnWidths(oSettings);
			}

			for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				if (oSettings.aoColumns[i].sWidth !== null) {
					oSettings.aoColumns[i].nTh.style.width = _fnStringToCss(oSettings.aoColumns[i].sWidth);
				}
			}

			/* If there is default sorting required - let's do it. The sort function will do the
			 * drawing for us. Otherwise we draw the table regardless of the Ajax source - this allows
			 * the table to look initialised for Ajax sourcing data (show 'loading' message possibly)
			 */
			if (oSettings.oFeatures.bSort) {
				_fnSort(oSettings);
			}
			else if (oSettings.oFeatures.bFilter) {
				_fnFilterComplete(oSettings, oSettings.oPreviousSearch);
			}
			else {
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				_fnCalculateEnd(oSettings);
				_fnDraw(oSettings);
			}

			/* if there is an ajax source load the data */
			if (oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide) {
				var aoData = [];
				_fnServerParams(oSettings, aoData);
				oSettings.fnServerData.call(oSettings.oInstance, oSettings.sAjaxSource, aoData, function (json) {
					var aData = (oSettings.sAjaxDataProp !== "") ?
						_fnGetObjectDataFn(oSettings.sAjaxDataProp)(json) : json;

					/* Got the data - add it to the table */
					for (i = 0; i < aData.length; i++) {
						_fnAddData(oSettings, aData[i]);
					}

					/* Reset the init display for cookie saving. We've already done a filter, and
					 * therefore cleared it before. So we need to make it appear 'fresh'
					 */
					oSettings.iInitDisplayStart = iAjaxStart;

					if (oSettings.oFeatures.bSort) {
						_fnSort(oSettings);
					}
					else {
						oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
						_fnCalculateEnd(oSettings);
						_fnDraw(oSettings);
					}

					_fnProcessingDisplay(oSettings, false);
					_fnInitComplete(oSettings, json);
				}, oSettings);
				return;
			}

			/* Server-side processing initialisation complete is done at the end of _fnDraw */
			if (!oSettings.oFeatures.bServerSide) {
				_fnProcessingDisplay(oSettings, false);
				_fnInitComplete(oSettings);
			}
		}


		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
		 *    with client-side processing (optional)
		 *  @memberof DataTable#oApi
		 */
		function _fnInitComplete(oSettings, json) {
			oSettings._bInitComplete = true;
			_fnCallbackFire(oSettings, 'aoInitComplete', 'init', [oSettings, json]);
		}


		/**
		 * Language compatibility - when certain options are given, and others aren't, we
		 * need to duplicate the values over, in order to provide backwards compatibility
		 * with older language files.
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnLanguageCompat(oLanguage) {
			var oDefaults = DataTable.defaults.oLanguage;

			/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
			 * sZeroRecords - assuming that is given.
			 */
			if (!oLanguage.sEmptyTable && oLanguage.sZeroRecords &&
				oDefaults.sEmptyTable === "No data available in table") {
				_fnMap(oLanguage, oLanguage, 'sZeroRecords', 'sEmptyTable');
			}

			/* Likewise with loading records */
			if (!oLanguage.sLoadingRecords && oLanguage.sZeroRecords &&
				oDefaults.sLoadingRecords === "Loading...") {
				_fnMap(oLanguage, oLanguage, 'sZeroRecords', 'sLoadingRecords');
			}
		}



		/**
		 * Generate the node required for user display length changing
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Display length feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlLength(oSettings) {
			if (oSettings.oScroll.bInfinite) {
				return null;
			}

			/* This can be overruled by not using the _MENU_ var/macro in the language variable */
			var sName = 'name="' + oSettings.sTableId + '_length"';
			var sStdMenu = '<select size="1" ' + sName + '>';
			var i, iLen;
			var aLengthMenu = oSettings.aLengthMenu;

			if (aLengthMenu.length == 2 && typeof aLengthMenu[0] === 'object' &&
				typeof aLengthMenu[1] === 'object') {
				for (i = 0, iLen = aLengthMenu[0].length; i < iLen; i++) {
					sStdMenu += '<option value="' + aLengthMenu[0][i] + '">' + aLengthMenu[1][i] + '</option>';
				}
			}
			else {
				for (i = 0, iLen = aLengthMenu.length; i < iLen; i++) {
					sStdMenu += '<option value="' + aLengthMenu[i] + '">' + aLengthMenu[i] + '</option>';
				}
			}
			sStdMenu += '</select>';

			var nLength = document.createElement('div');
			if (!oSettings.aanFeatures.l) {
				nLength.id = oSettings.sTableId + '_length';
			}
			nLength.className = oSettings.oClasses.sLength;
			nLength.innerHTML = '<label>' + oSettings.oLanguage.sLengthMenu.replace('_MENU_', sStdMenu) + '</label>';

			/*
			 * Set the length to the current display length - thanks to Andrea Pavlovic for this fix,
			 * and Stefan Skopnik for fixing the fix!
			 */
			$('select option[value="' + oSettings._iDisplayLength + '"]', nLength).attr("selected", true);

			$('select', nLength).bind('change.DT', function (e) {
				var iVal = $(this).val();

				/* Update all other length options for the new display */
				var n = oSettings.aanFeatures.l;
				for (i = 0, iLen = n.length; i < iLen; i++) {
					if (n[i] != this.parentNode) {
						$('select', n[i]).val(iVal);
					}
				}

				/* Redraw the table */
				oSettings._iDisplayLength = parseInt(iVal, 10);
				_fnCalculateEnd(oSettings);

				/* If we have space to show extra rows (backing up from the end point - then do so */
				if (oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay()) {
					oSettings._iDisplayStart = oSettings.fnDisplayEnd() - oSettings._iDisplayLength;
					if (oSettings._iDisplayStart < 0) {
						oSettings._iDisplayStart = 0;
					}
				}

				if (oSettings._iDisplayLength == -1) {
					oSettings._iDisplayStart = 0;
				}

				_fnDraw(oSettings);
			});


			$('select', nLength).attr('aria-controls', oSettings.sTableId);

			return nLength;
		}


		/**
		 * Recalculate the end point based on the start point
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnCalculateEnd(oSettings) {
			if (oSettings.oFeatures.bPaginate === false) {
				oSettings._iDisplayEnd = oSettings.aiDisplay.length;
			}
			else {
				/* Set the end point of the display - based on how many elements there are
				 * still to display
				 */
				if (oSettings._iDisplayStart + oSettings._iDisplayLength > oSettings.aiDisplay.length ||
					oSettings._iDisplayLength == -1) {
					oSettings._iDisplayEnd = oSettings.aiDisplay.length;
				}
				else {
					oSettings._iDisplayEnd = oSettings._iDisplayStart + oSettings._iDisplayLength;
				}
			}
		}



		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Note that most of the paging logic is done in 
		 * DataTable.ext.oPagination
		 */

		/**
		 * Generate the node required for default pagination
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Pagination feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlPaginate(oSettings) {
			if (oSettings.oScroll.bInfinite) {
				return null;
			}

			var nPaginate = document.createElement('div');
			nPaginate.className = oSettings.oClasses.sPaging + oSettings.sPaginationType;

			DataTable.ext.oPagination[oSettings.sPaginationType].fnInit(oSettings, nPaginate,
				function (oSettings) {
					_fnCalculateEnd(oSettings);
					_fnDraw(oSettings);
				}
			);

			/* Add a draw callback for the pagination on first instance, to update the paging display */
			if (!oSettings.aanFeatures.p) {
				oSettings.aoDrawCallback.push({
					"fn": function (oSettings) {
						DataTable.ext.oPagination[oSettings.sPaginationType].fnUpdate(oSettings, function (oSettings) {
							_fnCalculateEnd(oSettings);
							_fnDraw(oSettings);
						});
					},
					"sName": "pagination"
				});
			}
			return nPaginate;
		}


		/**
		 * Alter the display settings to change the page
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer)
		 *  @returns {bool} true page has changed, false - no change (no effect) eg 'first' on page 1
		 *  @memberof DataTable#oApi
		 */
		function _fnPageChange(oSettings, mAction) {
			var iOldStart = oSettings._iDisplayStart;

			if (typeof mAction === "number") {
				oSettings._iDisplayStart = mAction * oSettings._iDisplayLength;
				if (oSettings._iDisplayStart > oSettings.fnRecordsDisplay()) {
					oSettings._iDisplayStart = 0;
				}
			}
			else if (mAction == "first") {
				oSettings._iDisplayStart = 0;
			}
			else if (mAction == "previous") {
				oSettings._iDisplayStart = oSettings._iDisplayLength >= 0 ?
					oSettings._iDisplayStart - oSettings._iDisplayLength :
					0;

				/* Correct for under-run */
				if (oSettings._iDisplayStart < 0) {
					oSettings._iDisplayStart = 0;
				}
			}
			else if (mAction == "next") {
				if (oSettings._iDisplayLength >= 0) {
					/* Make sure we are not over running the display array */
					if (oSettings._iDisplayStart + oSettings._iDisplayLength < oSettings.fnRecordsDisplay()) {
						oSettings._iDisplayStart += oSettings._iDisplayLength;
					}
				}
				else {
					oSettings._iDisplayStart = 0;
				}
			}
			else if (mAction == "last") {
				if (oSettings._iDisplayLength >= 0) {
					var iPages = parseInt((oSettings.fnRecordsDisplay() - 1) / oSettings._iDisplayLength, 10) + 1;
					oSettings._iDisplayStart = (iPages - 1) * oSettings._iDisplayLength;
				}
				else {
					oSettings._iDisplayStart = 0;
				}
			}
			else {
				_fnLog(oSettings, 0, "Unknown paging action: " + mAction);
			}
			$(oSettings.oInstance).trigger('page', oSettings);

			return iOldStart != oSettings._iDisplayStart;
		}



		/**
		 * Generate the node required for the processing node
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Processing element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlProcessing(oSettings) {
			var nProcessing = document.createElement('div');

			if (!oSettings.aanFeatures.r) {
				nProcessing.id = oSettings.sTableId + '_processing';
			}
			nProcessing.innerHTML = oSettings.oLanguage.sProcessing;
			nProcessing.className = oSettings.oClasses.sProcessing;
			oSettings.nTable.parentNode.insertBefore(nProcessing, oSettings.nTable);

			return nProcessing;
		}


		/**
		 * Display or hide the processing indicator
		 *  @param {object} oSettings dataTables settings object
		 *  @param {bool} bShow Show the processing indicator (true) or not (false)
		 *  @memberof DataTable#oApi
		 */
		function _fnProcessingDisplay(oSettings, bShow) {
			if (oSettings.oFeatures.bProcessing) {
				var an = oSettings.aanFeatures.r;
				for (var i = 0, iLen = an.length; i < iLen; i++) {
					an[i].style.visibility = bShow ? "visible" : "hidden";
				}
			}

			$(oSettings.oInstance).trigger('processing', [oSettings, bShow]);
		}



		/**
		 * Add any control elements for the table - specifically scrolling
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Node to add to the DOM
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlTable(oSettings) {
			/* Check if scrolling is enabled or not - if not then leave the DOM unaltered */
			if (oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "") {
				return oSettings.nTable;
			}

			/*
			 * The HTML structure that we want to generate in this function is:
			 *  div - nScroller
			 *    div - nScrollHead
			 *      div - nScrollHeadInner
			 *        table - nScrollHeadTable
			 *          thead - nThead
			 *    div - nScrollBody
			 *      table - oSettings.nTable
			 *        thead - nTheadSize
			 *        tbody - nTbody
			 *    div - nScrollFoot
			 *      div - nScrollFootInner
			 *        table - nScrollFootTable
			 *          tfoot - nTfoot
			 */
			var
				nScroller = document.createElement('div'),
				nScrollHead = document.createElement('div'),
				nScrollHeadInner = document.createElement('div'),
				nScrollBody = document.createElement('div'),
				nScrollFoot = document.createElement('div'),
				nScrollFootInner = document.createElement('div'),
				nScrollHeadTable = oSettings.nTable.cloneNode(false),
				nScrollFootTable = oSettings.nTable.cloneNode(false),
				nThead = oSettings.nTable.getElementsByTagName('thead')[0],
				nTfoot = oSettings.nTable.getElementsByTagName('tfoot').length === 0 ? null :
					oSettings.nTable.getElementsByTagName('tfoot')[0],
				oClasses = oSettings.oClasses;

			nScrollHead.appendChild(nScrollHeadInner);
			nScrollFoot.appendChild(nScrollFootInner);
			nScrollBody.appendChild(oSettings.nTable);
			nScroller.appendChild(nScrollHead);
			nScroller.appendChild(nScrollBody);
			nScrollHeadInner.appendChild(nScrollHeadTable);
			nScrollHeadTable.appendChild(nThead);
			if (nTfoot !== null) {
				nScroller.appendChild(nScrollFoot);
				nScrollFootInner.appendChild(nScrollFootTable);
				nScrollFootTable.appendChild(nTfoot);
			}

			nScroller.className = oClasses.sScrollWrapper;
			nScrollHead.className = oClasses.sScrollHead;
			nScrollHeadInner.className = oClasses.sScrollHeadInner;
			nScrollBody.className = oClasses.sScrollBody;
			nScrollFoot.className = oClasses.sScrollFoot;
			nScrollFootInner.className = oClasses.sScrollFootInner;

			if (oSettings.oScroll.bAutoCss) {
				nScrollHead.style.overflow = "hidden";
				nScrollHead.style.position = "relative";
				nScrollFoot.style.overflow = "hidden";
				nScrollBody.style.overflow = "auto";
			}

			nScrollHead.style.border = "0";
			nScrollHead.style.width = "100%";
			nScrollFoot.style.border = "0";
			nScrollHeadInner.style.width = oSettings.oScroll.sXInner !== "" ?
				oSettings.oScroll.sXInner : "100%"; /* will be overwritten */

			/* Modify attributes to respect the clones */
			nScrollHeadTable.removeAttribute('id');
			nScrollHeadTable.style.marginLeft = "0";
			oSettings.nTable.style.marginLeft = "0";
			if (nTfoot !== null) {
				nScrollFootTable.removeAttribute('id');
				nScrollFootTable.style.marginLeft = "0";
			}

			/* Move caption elements from the body to the header, footer or leave where it is
			 * depending on the configuration. Note that the DTD says there can be only one caption */
			var nCaption = $(oSettings.nTable).children('caption');
			if (nCaption.length > 0) {
				nCaption = nCaption[0];
				if (nCaption._captionSide === "top") {
					nScrollHeadTable.appendChild(nCaption);
				}
				else if (nCaption._captionSide === "bottom" && nTfoot) {
					nScrollFootTable.appendChild(nCaption);
				}
			}

			/*
			 * Sizing
			 */
			/* When x-scrolling add the width and a scroller to move the header with the body */
			if (oSettings.oScroll.sX !== "") {
				nScrollHead.style.width = _fnStringToCss(oSettings.oScroll.sX);
				nScrollBody.style.width = _fnStringToCss(oSettings.oScroll.sX);

				if (nTfoot !== null) {
					nScrollFoot.style.width = _fnStringToCss(oSettings.oScroll.sX);
				}

				/* When the body is scrolled, then we also want to scroll the headers */
				$(nScrollBody).scroll(function (e) {
					nScrollHead.scrollLeft = this.scrollLeft;

					if (nTfoot !== null) {
						nScrollFoot.scrollLeft = this.scrollLeft;
					}
				});
			}

			/* When yscrolling, add the height */
			if (oSettings.oScroll.sY !== "") {
				nScrollBody.style.height = _fnStringToCss(oSettings.oScroll.sY);
			}

			/* Redraw - align columns across the tables */
			oSettings.aoDrawCallback.push({
				"fn": _fnScrollDraw,
				"sName": "scrolling"
			});

			/* Infinite scrolling event handlers */
			if (oSettings.oScroll.bInfinite) {
				$(nScrollBody).scroll(function () {
					/* Use a blocker to stop scrolling from loading more data while other data is still loading */
					if (!oSettings.bDrawing && $(this).scrollTop() !== 0) {
						/* Check if we should load the next data set */
						if ($(this).scrollTop() + $(this).height() >
							$(oSettings.nTable).height() - oSettings.oScroll.iLoadGap) {
							/* Only do the redraw if we have to - we might be at the end of the data */
							if (oSettings.fnDisplayEnd() < oSettings.fnRecordsDisplay()) {
								_fnPageChange(oSettings, 'next');
								_fnCalculateEnd(oSettings);
								_fnDraw(oSettings);
							}
						}
					}
				});
			}

			oSettings.nScrollHead = nScrollHead;
			oSettings.nScrollFoot = nScrollFoot;

			return nScroller;
		}


		/**
		 * Update the various tables for resizing. It's a bit of a pig this function, but
		 * basically the idea to:
		 *   1. Re-create the table inside the scrolling div
		 *   2. Take live measurements from the DOM
		 *   3. Apply the measurements
		 *   4. Clean up
		 *  @param {object} o dataTables settings object
		 *  @returns {node} Node to add to the DOM
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollDraw(o) {
			var
				nScrollHeadInner = o.nScrollHead.getElementsByTagName('div')[0],
				nScrollHeadTable = nScrollHeadInner.getElementsByTagName('table')[0],
				nScrollBody = o.nTable.parentNode,
				i, iLen, j, jLen, anHeadToSize, anHeadSizers, anFootSizers, anFootToSize, oStyle, iVis,
				nTheadSize, nTfootSize,
				iWidth, aApplied = [], iSanityWidth,
				nScrollFootInner = (o.nTFoot !== null) ? o.nScrollFoot.getElementsByTagName('div')[0] : null,
				nScrollFootTable = (o.nTFoot !== null) ? nScrollFootInner.getElementsByTagName('table')[0] : null,
				ie67 = o.oBrowser.bScrollOversize;

			/*
			 * 1. Re-create the table inside the scrolling div
			 */

			/* Remove the old minimised thead and tfoot elements in the inner table */
			$(o.nTable).children('thead, tfoot').remove();

			/* Clone the current header and footer elements and then place it into the inner table */
			nTheadSize = $(o.nTHead).clone()[0];
			o.nTable.insertBefore(nTheadSize, o.nTable.childNodes[0]);

			if (o.nTFoot !== null) {
				nTfootSize = $(o.nTFoot).clone()[0];
				o.nTable.insertBefore(nTfootSize, o.nTable.childNodes[1]);
			}

			/*
			 * 2. Take live measurements from the DOM - do not alter the DOM itself!
			 */

			/* Remove old sizing and apply the calculated column widths
			 * Get the unique column headers in the newly created (cloned) header. We want to apply the
			 * calculated sizes to this header
			 */
			if (o.oScroll.sX === "") {
				nScrollBody.style.width = '100%';
				nScrollHeadInner.parentNode.style.width = '100%';
			}

			var nThs = _fnGetUniqueThs(o, nTheadSize);
			for (i = 0, iLen = nThs.length; i < iLen; i++) {
				iVis = _fnVisibleToColumnIndex(o, i);
				nThs[i].style.width = o.aoColumns[iVis].sWidth;
			}

			if (o.nTFoot !== null) {
				_fnApplyToChildren(function (n) {
					n.style.width = "";
				}, nTfootSize.getElementsByTagName('tr'));
			}

			// If scroll collapse is enabled, when we put the headers back into the body for sizing, we
			// will end up forcing the scrollbar to appear, making our measurements wrong for when we
			// then hide it (end of this function), so add the header height to the body scroller.
			if (o.oScroll.bCollapse && o.oScroll.sY !== "") {
				nScrollBody.style.height = (nScrollBody.offsetHeight + o.nTHead.offsetHeight) + "px";
			}

			/* Size the table as a whole */
			iSanityWidth = $(o.nTable).outerWidth();
			if (o.oScroll.sX === "") {
				/* No x scrolling */
				o.nTable.style.width = "100%";

				/* I know this is rubbish - but IE7 will make the width of the table when 100% include
				 * the scrollbar - which is shouldn't. When there is a scrollbar we need to take this
				 * into account.
				 */
				if (ie67 && ($('tbody', nScrollBody).height() > nScrollBody.offsetHeight ||
					$(nScrollBody).css('overflow-y') == "scroll")) {
					o.nTable.style.width = _fnStringToCss($(o.nTable).outerWidth() - o.oScroll.iBarWidth);
				}
			}
			else {
				if (o.oScroll.sXInner !== "") {
					/* x scroll inner has been given - use it */
					o.nTable.style.width = _fnStringToCss(o.oScroll.sXInner);
				}
				else if (iSanityWidth == $(nScrollBody).width() &&
					$(nScrollBody).height() < $(o.nTable).height()) {
					/* There is y-scrolling - try to take account of the y scroll bar */
					o.nTable.style.width = _fnStringToCss(iSanityWidth - o.oScroll.iBarWidth);
					if ($(o.nTable).outerWidth() > iSanityWidth - o.oScroll.iBarWidth) {
						/* Not possible to take account of it */
						o.nTable.style.width = _fnStringToCss(iSanityWidth);
					}
				}
				else {
					/* All else fails */
					o.nTable.style.width = _fnStringToCss(iSanityWidth);
				}
			}

			/* Recalculate the sanity width - now that we've applied the required width, before it was
			 * a temporary variable. This is required because the column width calculation is done
			 * before this table DOM is created.
			 */
			iSanityWidth = $(o.nTable).outerWidth();

			/* We want the hidden header to have zero height, so remove padding and borders. Then
			 * set the width based on the real headers
			 */
			anHeadToSize = o.nTHead.getElementsByTagName('tr');
			anHeadSizers = nTheadSize.getElementsByTagName('tr');

			_fnApplyToChildren(function (nSizer, nToSize) {
				oStyle = nSizer.style;
				oStyle.paddingTop = "0";
				oStyle.paddingBottom = "0";
				oStyle.borderTopWidth = "0";
				oStyle.borderBottomWidth = "0";
				oStyle.height = 0;

				iWidth = $(nSizer).width();
				nToSize.style.width = _fnStringToCss(iWidth);
				aApplied.push(iWidth);
			}, anHeadSizers, anHeadToSize);
			$(anHeadSizers).height(0);

			if (o.nTFoot !== null) {
				/* Clone the current footer and then place it into the body table as a "hidden header" */
				anFootSizers = nTfootSize.getElementsByTagName('tr');
				anFootToSize = o.nTFoot.getElementsByTagName('tr');

				_fnApplyToChildren(function (nSizer, nToSize) {
					oStyle = nSizer.style;
					oStyle.paddingTop = "0";
					oStyle.paddingBottom = "0";
					oStyle.borderTopWidth = "0";
					oStyle.borderBottomWidth = "0";
					oStyle.height = 0;

					iWidth = $(nSizer).width();
					nToSize.style.width = _fnStringToCss(iWidth);
					aApplied.push(iWidth);
				}, anFootSizers, anFootToSize);
				$(anFootSizers).height(0);
			}

			/*
			 * 3. Apply the measurements
			 */

			/* "Hide" the header and footer that we used for the sizing. We want to also fix their width
			 * to what they currently are
			 */
			_fnApplyToChildren(function (nSizer) {
				nSizer.innerHTML = "";
				nSizer.style.width = _fnStringToCss(aApplied.shift());
			}, anHeadSizers);

			if (o.nTFoot !== null) {
				_fnApplyToChildren(function (nSizer) {
					nSizer.innerHTML = "";
					nSizer.style.width = _fnStringToCss(aApplied.shift());
				}, anFootSizers);
			}

			/* Sanity check that the table is of a sensible width. If not then we are going to get
			 * misalignment - try to prevent this by not allowing the table to shrink below its min width
			 */
			if ($(o.nTable).outerWidth() < iSanityWidth) {
				/* The min width depends upon if we have a vertical scrollbar visible or not */
				var iCorrection = ((nScrollBody.scrollHeight > nScrollBody.offsetHeight ||
					$(nScrollBody).css('overflow-y') == "scroll")) ?
					iSanityWidth + o.oScroll.iBarWidth : iSanityWidth;

				/* IE6/7 are a law unto themselves... */
				if (ie67 && (nScrollBody.scrollHeight >
					nScrollBody.offsetHeight || $(nScrollBody).css('overflow-y') == "scroll")) {
					o.nTable.style.width = _fnStringToCss(iCorrection - o.oScroll.iBarWidth);
				}

				/* Apply the calculated minimum width to the table wrappers */
				nScrollBody.style.width = _fnStringToCss(iCorrection);
				nScrollHeadInner.parentNode.style.width = _fnStringToCss(iCorrection);

				if (o.nTFoot !== null) {
					nScrollFootInner.parentNode.style.width = _fnStringToCss(iCorrection);
				}

				/* And give the user a warning that we've stopped the table getting too small */
				if (o.oScroll.sX === "") {
					_fnLog(o, 1, "The table cannot fit into the current element which will cause column" +
						" misalignment. The table has been drawn at its minimum possible width.");
				}
				else if (o.oScroll.sXInner !== "") {
					_fnLog(o, 1, "The table cannot fit into the current element which will cause column" +
						" misalignment. Increase the sScrollXInner value or remove it to allow automatic" +
						" calculation");
				}
			}
			else {
				nScrollBody.style.width = _fnStringToCss('100%');
				nScrollHeadInner.parentNode.style.width = _fnStringToCss('100%');

				if (o.nTFoot !== null) {
					nScrollFootInner.parentNode.style.width = _fnStringToCss('100%');
				}
			}


			/*
			 * 4. Clean up
			 */
			if (o.oScroll.sY === "") {
				/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
				 * the scrollbar height from the visible display, rather than adding it on. We need to
				 * set the height in order to sort this. Don't want to do it in any other browsers.
				 */
				if (ie67) {
					nScrollBody.style.height = _fnStringToCss(o.nTable.offsetHeight + o.oScroll.iBarWidth);
				}
			}

			if (o.oScroll.sY !== "" && o.oScroll.bCollapse) {
				nScrollBody.style.height = _fnStringToCss(o.oScroll.sY);

				var iExtra = (o.oScroll.sX !== "" && o.nTable.offsetWidth > nScrollBody.offsetWidth) ?
					o.oScroll.iBarWidth : 0;
				if (o.nTable.offsetHeight < nScrollBody.offsetHeight) {
					nScrollBody.style.height = _fnStringToCss(o.nTable.offsetHeight + iExtra);
				}
			}

			/* Finally set the width's of the header and footer tables */
			var iOuterWidth = $(o.nTable).outerWidth();
			nScrollHeadTable.style.width = _fnStringToCss(iOuterWidth);
			nScrollHeadInner.style.width = _fnStringToCss(iOuterWidth);

			// Figure out if there are scrollbar present - if so then we need a the header and footer to
			// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
			var bScrolling = $(o.nTable).height() > nScrollBody.clientHeight || $(nScrollBody).css('overflow-y') == "scroll";
			nScrollHeadInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth + "px" : "0px";

			if (o.nTFoot !== null) {
				nScrollFootTable.style.width = _fnStringToCss(iOuterWidth);
				nScrollFootInner.style.width = _fnStringToCss(iOuterWidth);
				nScrollFootInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth + "px" : "0px";
			}

			/* Adjust the position of the header in case we loose the y-scrollbar */
			$(nScrollBody).scroll();

			/* If sorting or filtering has occurred, jump the scrolling back to the top */
			if (o.bSorted || o.bFiltered) {
				nScrollBody.scrollTop = 0;
			}
		}


		/**
		 * Apply a given function to the display child nodes of an element array (typically
		 * TD children of TR rows
		 *  @param {function} fn Method to apply to the objects
		 *  @param array {nodes} an1 List of elements to look through for display children
		 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyToChildren(fn, an1, an2) {
			for (var i = 0, iLen = an1.length; i < iLen; i++) {
				for (var j = 0, jLen = an1[i].childNodes.length; j < jLen; j++) {
					if (an1[i].childNodes[j].nodeType == 1) {
						if (an2) {
							fn(an1[i].childNodes[j], an2[i].childNodes[j]);
						}
						else {
							fn(an1[i].childNodes[j]);
						}
					}
				}
			}
		}



		/**
		 * Convert a CSS unit width to pixels (e.g. 2em)
		 *  @param {string} sWidth width to be converted
		 *  @param {node} nParent parent to get the with for (required for relative widths) - optional
		 *  @returns {int} iWidth width in pixels
		 *  @memberof DataTable#oApi
		 */
		function _fnConvertToWidth(sWidth, nParent) {
			if (!sWidth || sWidth === null || sWidth === '') {
				return 0;
			}

			if (!nParent) {
				nParent = document.getElementsByTagName('body')[0];
			}

			var iWidth;
			var nTmp = document.createElement("div");
			nTmp.style.width = _fnStringToCss(sWidth);

			nParent.appendChild(nTmp);
			iWidth = nTmp.offsetWidth;
			nParent.removeChild(nTmp);

			return (iWidth);
		}


		/**
		 * Calculate the width of columns for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnCalculateColumnWidths(oSettings) {
			var iTableWidth = oSettings.nTable.offsetWidth;
			var iUserInputs = 0;
			var iTmpWidth;
			var iVisibleColumns = 0;
			var iColums = oSettings.aoColumns.length;
			var i, iIndex, iCorrector, iWidth;
			var oHeaders = $('th', oSettings.nTHead);
			var widthAttr = oSettings.nTable.getAttribute('width');

			/* Convert any user input sizes into pixel sizes */
			for (i = 0; i < iColums; i++) {
				if (oSettings.aoColumns[i].bVisible) {
					iVisibleColumns++;

					if (oSettings.aoColumns[i].sWidth !== null) {
						iTmpWidth = _fnConvertToWidth(oSettings.aoColumns[i].sWidthOrig,
							oSettings.nTable.parentNode);
						if (iTmpWidth !== null) {
							oSettings.aoColumns[i].sWidth = _fnStringToCss(iTmpWidth);
						}

						iUserInputs++;
					}
				}
			}

			/* If the number of columns in the DOM equals the number that we have to process in 
			 * DataTables, then we can use the offsets that are created by the web-browser. No custom 
			 * sizes can be set in order for this to happen, nor scrolling used
			 */
			if (iColums == oHeaders.length && iUserInputs === 0 && iVisibleColumns == iColums &&
				oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "") {
				for (i = 0; i < oSettings.aoColumns.length; i++) {
					iTmpWidth = $(oHeaders[i]).width();
					if (iTmpWidth !== null) {
						oSettings.aoColumns[i].sWidth = _fnStringToCss(iTmpWidth);
					}
				}
			}
			else {
				/* Otherwise we are going to have to do some calculations to get the width of each column.
				 * Construct a 1 row table with the widest node in the data, and any user defined widths,
				 * then insert it into the DOM and allow the browser to do all the hard work of
				 * calculating table widths.
				 */
				var
					nCalcTmp = oSettings.nTable.cloneNode(false),
					nTheadClone = oSettings.nTHead.cloneNode(true),
					nBody = document.createElement('tbody'),
					nTr = document.createElement('tr'),
					nDivSizing;

				nCalcTmp.removeAttribute("id");
				nCalcTmp.appendChild(nTheadClone);
				if (oSettings.nTFoot !== null) {
					nCalcTmp.appendChild(oSettings.nTFoot.cloneNode(true));
					_fnApplyToChildren(function (n) {
						n.style.width = "";
					}, nCalcTmp.getElementsByTagName('tr'));
				}

				nCalcTmp.appendChild(nBody);
				nBody.appendChild(nTr);

				/* Remove any sizing that was previously applied by the styles */
				var jqColSizing = $('thead th', nCalcTmp);
				if (jqColSizing.length === 0) {
					jqColSizing = $('tbody tr:eq(0)>td', nCalcTmp);
				}

				/* Apply custom sizing to the cloned header */
				var nThs = _fnGetUniqueThs(oSettings, nTheadClone);
				iCorrector = 0;
				for (i = 0; i < iColums; i++) {
					var oColumn = oSettings.aoColumns[i];
					if (oColumn.bVisible && oColumn.sWidthOrig !== null && oColumn.sWidthOrig !== "") {
						nThs[i - iCorrector].style.width = _fnStringToCss(oColumn.sWidthOrig);
					}
					else if (oColumn.bVisible) {
						nThs[i - iCorrector].style.width = "";
					}
					else {
						iCorrector++;
					}
				}

				/* Find the biggest td for each column and put it into the table */
				for (i = 0; i < iColums; i++) {
					if (oSettings.aoColumns[i].bVisible) {
						var nTd = _fnGetWidestNode(oSettings, i);
						if (nTd !== null) {
							nTd = nTd.cloneNode(true);
							if (oSettings.aoColumns[i].sContentPadding !== "") {
								nTd.innerHTML += oSettings.aoColumns[i].sContentPadding;
							}
							nTr.appendChild(nTd);
						}
					}
				}

				/* Build the table and 'display' it */
				var nWrapper = oSettings.nTable.parentNode;
				nWrapper.appendChild(nCalcTmp);

				/* When scrolling (X or Y) we want to set the width of the table as appropriate. However,
				 * when not scrolling leave the table width as it is. This results in slightly different,
				 * but I think correct behaviour
				 */
				if (oSettings.oScroll.sX !== "" && oSettings.oScroll.sXInner !== "") {
					nCalcTmp.style.width = _fnStringToCss(oSettings.oScroll.sXInner);
				}
				else if (oSettings.oScroll.sX !== "") {
					nCalcTmp.style.width = "";
					if ($(nCalcTmp).width() < nWrapper.offsetWidth) {
						nCalcTmp.style.width = _fnStringToCss(nWrapper.offsetWidth);
					}
				}
				else if (oSettings.oScroll.sY !== "") {
					nCalcTmp.style.width = _fnStringToCss(nWrapper.offsetWidth);
				}
				else if (widthAttr) {
					nCalcTmp.style.width = _fnStringToCss(widthAttr);
				}
				nCalcTmp.style.visibility = "hidden";

				/* Scrolling considerations */
				_fnScrollingWidthAdjust(oSettings, nCalcTmp);

				/* Read the width's calculated by the browser and store them for use by the caller. We
				 * first of all try to use the elements in the body, but it is possible that there are
				 * no elements there, under which circumstances we use the header elements
				 */
				var oNodes = $("tbody tr:eq(0)", nCalcTmp).children();
				if (oNodes.length === 0) {
					oNodes = _fnGetUniqueThs(oSettings, $('thead', nCalcTmp)[0]);
				}

				/* Browsers need a bit of a hand when a width is assigned to any columns when 
				 * x-scrolling as they tend to collapse the table to the min-width, even if
				 * we sent the column widths. So we need to keep track of what the table width
				 * should be by summing the user given values, and the automatic values
				 */
				if (oSettings.oScroll.sX !== "") {
					var iTotal = 0;
					iCorrector = 0;
					for (i = 0; i < oSettings.aoColumns.length; i++) {
						if (oSettings.aoColumns[i].bVisible) {
							if (oSettings.aoColumns[i].sWidthOrig === null) {
								iTotal += $(oNodes[iCorrector]).outerWidth();
							}
							else {
								iTotal += parseInt(oSettings.aoColumns[i].sWidth.replace('px', ''), 10) +
									($(oNodes[iCorrector]).outerWidth() - $(oNodes[iCorrector]).width());
							}
							iCorrector++;
						}
					}

					nCalcTmp.style.width = _fnStringToCss(iTotal);
					oSettings.nTable.style.width = _fnStringToCss(iTotal);
				}

				iCorrector = 0;
				for (i = 0; i < oSettings.aoColumns.length; i++) {
					if (oSettings.aoColumns[i].bVisible) {
						iWidth = $(oNodes[iCorrector]).width();
						if (iWidth !== null && iWidth > 0) {
							oSettings.aoColumns[i].sWidth = _fnStringToCss(iWidth);
						}
						iCorrector++;
					}
				}

				var cssWidth = $(nCalcTmp).css('width');
				oSettings.nTable.style.width = (cssWidth.indexOf('%') !== -1) ?
					cssWidth : _fnStringToCss($(nCalcTmp).outerWidth());
				nCalcTmp.parentNode.removeChild(nCalcTmp);
			}

			if (widthAttr) {
				oSettings.nTable.style.width = _fnStringToCss(widthAttr);
			}
		}


		/**
		 * Adjust a table's width to take account of scrolling
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} n table node
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollingWidthAdjust(oSettings, n) {
			if (oSettings.oScroll.sX === "" && oSettings.oScroll.sY !== "") {
				/* When y-scrolling only, we want to remove the width of the scroll bar so the table
				 * + scroll bar will fit into the area avaialble.
				 */
				var iOrigWidth = $(n).width();
				n.style.width = _fnStringToCss($(n).outerWidth() - oSettings.oScroll.iBarWidth);
			}
			else if (oSettings.oScroll.sX !== "") {
				/* When x-scrolling both ways, fix the table at it's current size, without adjusting */
				n.style.width = _fnStringToCss($(n).outerWidth());
			}
		}


		/**
		 * Get the widest node
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column of interest
		 *  @returns {string} max string length for each column
		 *  @memberof DataTable#oApi
		 */
		function _fnGetWidestNode(oSettings, iCol) {
			var iMaxIndex = _fnGetMaxLenString(oSettings, iCol);
			if (iMaxIndex < 0) {
				return null;
			}

			if (oSettings.aoData[iMaxIndex].nTr === null) {
				var n = document.createElement('td');
				n.innerHTML = _fnGetCellData(oSettings, iMaxIndex, iCol, '');
				return n;
			}
			return _fnGetTdNodes(oSettings, iMaxIndex)[iCol];
		}


		/**
		 * Get the maximum strlen for each data column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column of interest
		 *  @returns {string} max string length for each column
		 *  @memberof DataTable#oApi
		 */
		function _fnGetMaxLenString(oSettings, iCol) {
			var iMax = -1;
			var iMaxIndex = -1;

			for (var i = 0; i < oSettings.aoData.length; i++) {
				var s = _fnGetCellData(oSettings, i, iCol, 'display') + "";
				s = s.replace(/<.*?>/g, "");
				if (s.length > iMax) {
					iMax = s.length;
					iMaxIndex = i;
				}
			}

			return iMaxIndex;
		}


		/**
		 * Append a CSS unit (only if required) to a string
		 *  @param {array} aArray1 first array
		 *  @param {array} aArray2 second array
		 *  @returns {int} 0 if match, 1 if length is different, 2 if no match
		 *  @memberof DataTable#oApi
		 */
		function _fnStringToCss(s) {
			if (s === null) {
				return "0px";
			}

			if (typeof s == 'number') {
				if (s < 0) {
					return "0px";
				}
				return s + "px";
			}

			/* Check if the last character is not 0-9 */
			var c = s.charCodeAt(s.length - 1);
			if (c < 0x30 || c > 0x39) {
				return s;
			}
			return s + "px";
		}


		/**
		 * Get the width of a scroll bar in this browser being used
		 *  @returns {int} width in pixels
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollBarWidth() {
			var inner = document.createElement('p');
			var style = inner.style;
			style.width = "100%";
			style.height = "200px";
			style.padding = "0px";

			var outer = document.createElement('div');
			style = outer.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = "0px";
			style.visibility = "hidden";
			style.width = "200px";
			style.height = "150px";
			style.padding = "0px";
			style.overflow = "hidden";
			outer.appendChild(inner);

			document.body.appendChild(outer);
			var w1 = inner.offsetWidth;
			outer.style.overflow = 'scroll';
			var w2 = inner.offsetWidth;
			if (w1 == w2) {
				w2 = outer.clientWidth;
			}

			document.body.removeChild(outer);
			return (w1 - w2);
		}



		/**
		 * Change the order of the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {bool} bApplyClasses optional - should we apply classes or not
		 *  @memberof DataTable#oApi
		 */
		function _fnSort(oSettings, bApplyClasses) {
			var
				i, iLen, j, jLen, k, kLen,
				sDataType, nTh,
				aaSort = [],
				aiOrig = [],
				oSort = DataTable.ext.oSort,
				aoData = oSettings.aoData,
				aoColumns = oSettings.aoColumns,
				oAria = oSettings.oLanguage.oAria;

			/* No sorting required if server-side or no sorting array */
			if (!oSettings.oFeatures.bServerSide &&
				(oSettings.aaSorting.length !== 0 || oSettings.aaSortingFixed !== null)) {
				aaSort = (oSettings.aaSortingFixed !== null) ?
					oSettings.aaSortingFixed.concat(oSettings.aaSorting) :
					oSettings.aaSorting.slice();

				/* If there is a sorting data type, and a function belonging to it, then we need to
				 * get the data from the developer's function and apply it for this column
				 */
				for (i = 0; i < aaSort.length; i++) {
					var iColumn = aaSort[i][0];
					var iVisColumn = _fnColumnIndexToVisible(oSettings, iColumn);
					sDataType = oSettings.aoColumns[iColumn].sSortDataType;
					if (DataTable.ext.afnSortData[sDataType]) {
						var aData = DataTable.ext.afnSortData[sDataType].call(
							oSettings.oInstance, oSettings, iColumn, iVisColumn
						);
						if (aData.length === aoData.length) {
							for (j = 0, jLen = aoData.length; j < jLen; j++) {
								_fnSetCellData(oSettings, j, iColumn, aData[j]);
							}
						}
						else {
							_fnLog(oSettings, 0, "Returned data sort array (col " + iColumn + ") is the wrong length");
						}
					}
				}

				/* Create a value - key array of the current row positions such that we can use their
				 * current position during the sort, if values match, in order to perform stable sorting
				 */
				for (i = 0, iLen = oSettings.aiDisplayMaster.length; i < iLen; i++) {
					aiOrig[oSettings.aiDisplayMaster[i]] = i;
				}

				/* Build an internal data array which is specific to the sort, so we can get and prep
				 * the data to be sorted only once, rather than needing to do it every time the sorting
				 * function runs. This make the sorting function a very simple comparison
				 */
				var iSortLen = aaSort.length;
				var fnSortFormat, aDataSort;
				for (i = 0, iLen = aoData.length; i < iLen; i++) {
					for (j = 0; j < iSortLen; j++) {
						aDataSort = aoColumns[aaSort[j][0]].aDataSort;

						for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
							sDataType = aoColumns[aDataSort[k]].sType;
							fnSortFormat = oSort[(sDataType ? sDataType : 'string') + "-pre"];

							aoData[i]._aSortData[aDataSort[k]] = fnSortFormat ?
								fnSortFormat(_fnGetCellData(oSettings, i, aDataSort[k], 'sort')) :
								_fnGetCellData(oSettings, i, aDataSort[k], 'sort');
						}
					}
				}

				/* Do the sort - here we want multi-column sorting based on a given data source (column)
				 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
				 * follow on it's own, but this is what we want (example two column sorting):
				 *  fnLocalSorting = function(a,b){
				 *  	var iTest;
				 *  	iTest = oSort['string-asc']('data11', 'data12');
				 *  	if (iTest !== 0)
				 *  		return iTest;
				 *    iTest = oSort['numeric-desc']('data21', 'data22');
				 *    if (iTest !== 0)
				 *  		return iTest;
				 *  	return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
				 *  }
				 * Basically we have a test for each sorting column, if the data in that column is equal,
				 * test the next column. If all columns match, then we use a numeric sort on the row 
				 * positions in the original data array to provide a stable sort.
				 */
				oSettings.aiDisplayMaster.sort(function (a, b) {
					var k, l, lLen, iTest, aDataSort, sDataType;
					for (k = 0; k < iSortLen; k++) {
						aDataSort = aoColumns[aaSort[k][0]].aDataSort;

						for (l = 0, lLen = aDataSort.length; l < lLen; l++) {
							sDataType = aoColumns[aDataSort[l]].sType;

							iTest = oSort[(sDataType ? sDataType : 'string') + "-" + aaSort[k][1]](
								aoData[a]._aSortData[aDataSort[l]],
								aoData[b]._aSortData[aDataSort[l]]
							);

							if (iTest !== 0) {
								return iTest;
							}
						}
					}

					return oSort['numeric-asc'](aiOrig[a], aiOrig[b]);
				});
			}

			/* Alter the sorting classes to take account of the changes */
			if ((bApplyClasses === undefined || bApplyClasses) && !oSettings.oFeatures.bDeferRender) {
				_fnSortingClasses(oSettings);
			}

			for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				var sTitle = aoColumns[i].sTitle.replace(/<.*?>/g, "");
				nTh = aoColumns[i].nTh;
				nTh.removeAttribute('aria-sort');
				nTh.removeAttribute('aria-label');

				/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
				if (aoColumns[i].bSortable) {
					if (aaSort.length > 0 && aaSort[0][0] == i) {
						nTh.setAttribute('aria-sort', aaSort[0][1] == "asc" ? "ascending" : "descending");

						var nextSort = (aoColumns[i].asSorting[aaSort[0][2] + 1]) ?
							aoColumns[i].asSorting[aaSort[0][2] + 1] : aoColumns[i].asSorting[0];
						nTh.setAttribute('aria-label', sTitle +
							(nextSort == "asc" ? oAria.sSortAscending : oAria.sSortDescending));
					}
					else {
						nTh.setAttribute('aria-label', sTitle +
							(aoColumns[i].asSorting[0] == "asc" ? oAria.sSortAscending : oAria.sSortDescending));
					}
				}
				else {
					nTh.setAttribute('aria-label', sTitle);
				}
			}

			/* Tell the draw function that we have sorted the data */
			oSettings.bSorted = true;
			$(oSettings.oInstance).trigger('sort', oSettings);

			/* Copy the master data into the draw array and re-draw */
			if (oSettings.oFeatures.bFilter) {
				/* _fnFilter() will redraw the table for us */
				_fnFilterComplete(oSettings, oSettings.oPreviousSearch, 1);
			}
			else {
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				oSettings._iDisplayStart = 0; /* reset display back to page 0 */
				_fnCalculateEnd(oSettings);
				_fnDraw(oSettings);
			}
		}


		/**
		 * Attach a sort handler (click) to a node
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nNode node to attach the handler to
		 *  @param {int} iDataIndex column sorting index
		 *  @param {function} [fnCallback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortAttachListener(oSettings, nNode, iDataIndex, fnCallback) {
			_fnBindAction(nNode, {}, function (e) {
				/* If the column is not sortable - don't to anything */
				if (oSettings.aoColumns[iDataIndex].bSortable === false) {
					return;
				}

				/*
				 * This is a little bit odd I admit... I declare a temporary function inside the scope of
				 * _fnBuildHead and the click handler in order that the code presented here can be used 
				 * twice - once for when bProcessing is enabled, and another time for when it is 
				 * disabled, as we need to perform slightly different actions.
				 *   Basically the issue here is that the Javascript engine in modern browsers don't 
				 * appear to allow the rendering engine to update the display while it is still executing
				 * it's thread (well - it does but only after long intervals). This means that the 
				 * 'processing' display doesn't appear for a table sort. To break the js thread up a bit
				 * I force an execution break by using setTimeout - but this breaks the expected 
				 * thread continuation for the end-developer's point of view (their code would execute
				 * too early), so we only do it when we absolutely have to.
				 */
				var fnInnerSorting = function () {
					var iColumn, iNextSort;

					/* If the shift key is pressed then we are multiple column sorting */
					if (e.shiftKey) {
						/* Are we already doing some kind of sort on this column? */
						var bFound = false;
						for (var i = 0; i < oSettings.aaSorting.length; i++) {
							if (oSettings.aaSorting[i][0] == iDataIndex) {
								bFound = true;
								iColumn = oSettings.aaSorting[i][0];
								iNextSort = oSettings.aaSorting[i][2] + 1;

								if (!oSettings.aoColumns[iColumn].asSorting[iNextSort]) {
									/* Reached the end of the sorting options, remove from multi-col sort */
									oSettings.aaSorting.splice(i, 1);
								}
								else {
									/* Move onto next sorting direction */
									oSettings.aaSorting[i][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
									oSettings.aaSorting[i][2] = iNextSort;
								}
								break;
							}
						}

						/* No sort yet - add it in */
						if (bFound === false) {
							oSettings.aaSorting.push([iDataIndex,
								oSettings.aoColumns[iDataIndex].asSorting[0], 0]);
						}
					}
					else {
						/* If no shift key then single column sort */
						if (oSettings.aaSorting.length == 1 && oSettings.aaSorting[0][0] == iDataIndex) {
							iColumn = oSettings.aaSorting[0][0];
							iNextSort = oSettings.aaSorting[0][2] + 1;
							if (!oSettings.aoColumns[iColumn].asSorting[iNextSort]) {
								iNextSort = 0;
							}
							oSettings.aaSorting[0][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
							oSettings.aaSorting[0][2] = iNextSort;
						}
						else {
							oSettings.aaSorting.splice(0, oSettings.aaSorting.length);
							oSettings.aaSorting.push([iDataIndex,
								oSettings.aoColumns[iDataIndex].asSorting[0], 0]);
						}
					}

					/* Run the sort */
					_fnSort(oSettings);
				}; /* /fnInnerSorting */

				if (!oSettings.oFeatures.bProcessing) {
					fnInnerSorting();
				}
				else {
					_fnProcessingDisplay(oSettings, true);
					setTimeout(function () {
						fnInnerSorting();
						if (!oSettings.oFeatures.bServerSide) {
							_fnProcessingDisplay(oSettings, false);
						}
					}, 0);
				}

				/* Call the user specified callback function - used for async user interaction */
				if (typeof fnCallback == 'function') {
					fnCallback(oSettings);
				}
			});
		}


		/**
		 * Set the sorting classes on the header, Note: it is safe to call this function 
		 * when bSort and bSortClasses are false
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSortingClasses(oSettings) {
			var i, iLen, j, jLen, iFound;
			var aaSort, sClass;
			var iColumns = oSettings.aoColumns.length;
			var oClasses = oSettings.oClasses;

			for (i = 0; i < iColumns; i++) {
				if (oSettings.aoColumns[i].bSortable) {
					$(oSettings.aoColumns[i].nTh).removeClass(oClasses.sSortAsc + " " + oClasses.sSortDesc +
						" " + oSettings.aoColumns[i].sSortingClass);
				}
			}

			if (oSettings.aaSortingFixed !== null) {
				aaSort = oSettings.aaSortingFixed.concat(oSettings.aaSorting);
			}
			else {
				aaSort = oSettings.aaSorting.slice();
			}

			/* Apply the required classes to the header */
			for (i = 0; i < oSettings.aoColumns.length; i++) {
				if (oSettings.aoColumns[i].bSortable) {
					sClass = oSettings.aoColumns[i].sSortingClass;
					iFound = -1;
					for (j = 0; j < aaSort.length; j++) {
						if (aaSort[j][0] == i) {
							sClass = (aaSort[j][1] == "asc") ?
								oClasses.sSortAsc : oClasses.sSortDesc;
							iFound = j;
							break;
						}
					}
					$(oSettings.aoColumns[i].nTh).addClass(sClass);

					if (oSettings.bJUI) {
						/* jQuery UI uses extra markup */
						var jqSpan = $("span." + oClasses.sSortIcon, oSettings.aoColumns[i].nTh);
						jqSpan.removeClass(oClasses.sSortJUIAsc + " " + oClasses.sSortJUIDesc + " " +
							oClasses.sSortJUI + " " + oClasses.sSortJUIAscAllowed + " " + oClasses.sSortJUIDescAllowed);

						var sSpanClass;
						if (iFound == -1) {
							sSpanClass = oSettings.aoColumns[i].sSortingClassJUI;
						}
						else if (aaSort[iFound][1] == "asc") {
							sSpanClass = oClasses.sSortJUIAsc;
						}
						else {
							sSpanClass = oClasses.sSortJUIDesc;
						}

						jqSpan.addClass(sSpanClass);
					}
				}
				else {
					/* No sorting on this column, so add the base class. This will have been assigned by
					 * _fnAddColumn
					 */
					$(oSettings.aoColumns[i].nTh).addClass(oSettings.aoColumns[i].sSortingClass);
				}
			}

			/* 
			 * Apply the required classes to the table body
			 * Note that this is given as a feature switch since it can significantly slow down a sort
			 * on large data sets (adding and removing of classes is always slow at the best of times..)
			 * Further to this, note that this code is admittedly fairly ugly. It could be made a lot 
			 * simpler using jQuery selectors and add/removeClass, but that is significantly slower
			 * (on the order of 5 times slower) - hence the direct DOM manipulation here.
			 * Note that for deferred drawing we do use jQuery - the reason being that taking the first
			 * row found to see if the whole column needs processed can miss classes since the first
			 * column might be new.
			 */
			sClass = oClasses.sSortColumn;

			if (oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses) {
				var nTds = _fnGetTdNodes(oSettings);

				/* Remove the old classes */
				if (oSettings.oFeatures.bDeferRender) {
					$(nTds).removeClass(sClass + '1 ' + sClass + '2 ' + sClass + '3');
				}
				else if (nTds.length >= iColumns) {
					for (i = 0; i < iColumns; i++) {
						if (nTds[i].className.indexOf(sClass + "1") != -1) {
							for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
								nTds[(iColumns * j) + i].className =
									$.trim(nTds[(iColumns * j) + i].className.replace(sClass + "1", ""));
							}
						}
						else if (nTds[i].className.indexOf(sClass + "2") != -1) {
							for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
								nTds[(iColumns * j) + i].className =
									$.trim(nTds[(iColumns * j) + i].className.replace(sClass + "2", ""));
							}
						}
						else if (nTds[i].className.indexOf(sClass + "3") != -1) {
							for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
								nTds[(iColumns * j) + i].className =
									$.trim(nTds[(iColumns * j) + i].className.replace(" " + sClass + "3", ""));
							}
						}
					}
				}

				/* Add the new classes to the table */
				var iClass = 1, iTargetCol;
				for (i = 0; i < aaSort.length; i++) {
					iTargetCol = parseInt(aaSort[i][0], 10);
					for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
						nTds[(iColumns * j) + iTargetCol].className += " " + sClass + iClass;
					}

					if (iClass < 3) {
						iClass++;
					}
				}
			}
		}



		/**
		 * Save the state of a table in a cookie such that the page can be reloaded
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSaveState(oSettings) {
			if (!oSettings.oFeatures.bStateSave || oSettings.bDestroying) {
				return;
			}

			/* Store the interesting variables */
			var i, iLen, bInfinite = oSettings.oScroll.bInfinite;
			var oState = {
				"iCreate": new Date().getTime(),
				"iStart": (bInfinite ? 0 : oSettings._iDisplayStart),
				"iEnd": (bInfinite ? oSettings._iDisplayLength : oSettings._iDisplayEnd),
				"iLength": oSettings._iDisplayLength,
				"aaSorting": $.extend(true, [], oSettings.aaSorting),
				"oSearch": $.extend(true, {}, oSettings.oPreviousSearch),
				"aoSearchCols": $.extend(true, [], oSettings.aoPreSearchCols),
				"abVisCols": []
			};

			for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				oState.abVisCols.push(oSettings.aoColumns[i].bVisible);
			}

			_fnCallbackFire(oSettings, "aoStateSaveParams", 'stateSaveParams', [oSettings, oState]);

			oSettings.fnStateSave.call(oSettings.oInstance, oSettings, oState);
		}


		/**
		 * Attempt to load a saved table state from a cookie
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oInit DataTables init object so we can override settings
		 *  @memberof DataTable#oApi
		 */
		function _fnLoadState(oSettings, oInit) {
			if (!oSettings.oFeatures.bStateSave) {
				return;
			}

			var oData = oSettings.fnStateLoad.call(oSettings.oInstance, oSettings);
			if (!oData) {
				return;
			}

			/* Allow custom and plug-in manipulation functions to alter the saved data set and
			 * cancelling of loading by returning false
			 */
			var abStateLoad = _fnCallbackFire(oSettings, 'aoStateLoadParams', 'stateLoadParams', [oSettings, oData]);
			if ($.inArray(false, abStateLoad) !== -1) {
				return;
			}

			/* Store the saved state so it might be accessed at any time */
			oSettings.oLoadedState = $.extend(true, {}, oData);

			/* Restore key features */
			oSettings._iDisplayStart = oData.iStart;
			oSettings.iInitDisplayStart = oData.iStart;
			oSettings._iDisplayEnd = oData.iEnd;
			oSettings._iDisplayLength = oData.iLength;
			oSettings.aaSorting = oData.aaSorting.slice();
			oSettings.saved_aaSorting = oData.aaSorting.slice();

			/* Search filtering  */
			$.extend(oSettings.oPreviousSearch, oData.oSearch);
			$.extend(true, oSettings.aoPreSearchCols, oData.aoSearchCols);

			/* Column visibility state
			 * Pass back visibility settings to the init handler, but to do not here override
			 * the init object that the user might have passed in
			 */
			oInit.saved_aoColumns = [];
			for (var i = 0; i < oData.abVisCols.length; i++) {
				oInit.saved_aoColumns[i] = {};
				oInit.saved_aoColumns[i].bVisible = oData.abVisCols[i];
			}

			_fnCallbackFire(oSettings, 'aoStateLoaded', 'stateLoaded', [oSettings, oData]);
		}


		/**
		 * Create a new cookie with a value to store the state of a table
		 *  @param {string} sName name of the cookie to create
		 *  @param {string} sValue the value the cookie should take
		 *  @param {int} iSecs duration of the cookie
		 *  @param {string} sBaseName sName is made up of the base + file name - this is the base
		 *  @param {function} fnCallback User definable function to modify the cookie
		 *  @memberof DataTable#oApi
		 */
		function _fnCreateCookie(sName, sValue, iSecs, sBaseName, fnCallback) {
			var date = new Date();
			date.setTime(date.getTime() + (iSecs * 1000));

			/* 
			 * Shocking but true - it would appear IE has major issues with having the path not having
			 * a trailing slash on it. We need the cookie to be available based on the path, so we
			 * have to append the file name to the cookie name. Appalling. Thanks to vex for adding the
			 * patch to use at least some of the path
			 */
			var aParts = window.location.pathname.split('/');
			var sNameFile = sName + '_' + aParts.pop().replace(/[\/:]/g, "").toLowerCase();
			var sFullCookie, oData;

			if (fnCallback !== null) {
				oData = (typeof $.parseJSON === 'function') ?
					$.parseJSON(sValue) : eval('(' + sValue + ')');
				sFullCookie = fnCallback(sNameFile, oData, date.toGMTString(),
					aParts.join('/') + "/");
			}
			else {
				sFullCookie = sNameFile + "=" + encodeURIComponent(sValue) +
					"; expires=" + date.toGMTString() + "; path=" + aParts.join('/') + "/";
			}

			/* Are we going to go over the cookie limit of 4KiB? If so, try to delete a cookies
			 * belonging to DataTables. This is FAR from bullet proof
			 */
			var sOldName = "", iOldTime = 9999999999999;
			var iLength = _fnReadCookie(sNameFile) !== null ? document.cookie.length :
				sFullCookie.length + document.cookie.length;

			if (iLength + 10 > 4096) /* Magic 10 for padding */ {
				var aCookies = document.cookie.split(';');
				for (var i = 0, iLen = aCookies.length; i < iLen; i++) {
					if (aCookies[i].indexOf(sBaseName) != -1) {
						/* It's a DataTables cookie, so eval it and check the time stamp */
						var aSplitCookie = aCookies[i].split('=');
						try { oData = eval('(' + decodeURIComponent(aSplitCookie[1]) + ')'); }
						catch (e) { continue; }

						if (oData.iCreate && oData.iCreate < iOldTime) {
							sOldName = aSplitCookie[0];
							iOldTime = oData.iCreate;
						}
					}
				}

				if (sOldName !== "") {
					document.cookie = sOldName + "=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=" +
						aParts.join('/') + "/";
				}
			}

			document.cookie = sFullCookie;
		}


		/**
		 * Read an old cookie to get a cookie with an old table state
		 *  @param {string} sName name of the cookie to read
		 *  @returns {string} contents of the cookie - or null if no cookie with that name found
		 *  @memberof DataTable#oApi
		 */
		function _fnReadCookie(sName) {
			var
				aParts = window.location.pathname.split('/'),
				sNameEQ = sName + '_' + aParts[aParts.length - 1].replace(/[\/:]/g, "").toLowerCase() + '=',
				sCookieContents = document.cookie.split(';');

			for (var i = 0; i < sCookieContents.length; i++) {
				var c = sCookieContents[i];

				while (c.charAt(0) == ' ') {
					c = c.substring(1, c.length);
				}

				if (c.indexOf(sNameEQ) === 0) {
					return decodeURIComponent(c.substring(sNameEQ.length, c.length));
				}
			}
			return null;
		}



		/**
		 * Return the settings object for a particular table
		 *  @param {node} nTable table we are using as a dataTable
		 *  @returns {object} Settings object - or null if not found
		 *  @memberof DataTable#oApi
		 */
		function _fnSettingsFromNode(nTable) {
			for (var i = 0; i < DataTable.settings.length; i++) {
				if (DataTable.settings[i].nTable === nTable) {
					return DataTable.settings[i];
				}
			}

			return null;
		}


		/**
		 * Return an array with the TR nodes for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {array} TR array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetTrNodes(oSettings) {
			var aNodes = [];
			var aoData = oSettings.aoData;
			for (var i = 0, iLen = aoData.length; i < iLen; i++) {
				if (aoData[i].nTr !== null) {
					aNodes.push(aoData[i].nTr);
				}
			}
			return aNodes;
		}


		/**
		 * Return an flat array with all TD nodes for the table, or row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} [iIndividualRow] aoData index to get the nodes for - optional 
		 *    if not given then the return array will contain all nodes for the table
		 *  @returns {array} TD array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetTdNodes(oSettings, iIndividualRow) {
			var anReturn = [];
			var iCorrector;
			var anTds;
			var iRow, iRows = oSettings.aoData.length,
				iColumn, iColumns, oData, sNodeName, iStart = 0, iEnd = iRows;

			/* Allow the collection to be limited to just one row */
			if (iIndividualRow !== undefined) {
				iStart = iIndividualRow;
				iEnd = iIndividualRow + 1;
			}

			for (iRow = iStart; iRow < iEnd; iRow++) {
				oData = oSettings.aoData[iRow];
				if (oData.nTr !== null) {
					/* get the TD child nodes - taking into account text etc nodes */
					anTds = [];
					for (iColumn = 0, iColumns = oData.nTr.childNodes.length; iColumn < iColumns; iColumn++) {
						sNodeName = oData.nTr.childNodes[iColumn].nodeName.toLowerCase();
						if (sNodeName == 'td' || sNodeName == 'th') {
							anTds.push(oData.nTr.childNodes[iColumn]);
						}
					}

					iCorrector = 0;
					for (iColumn = 0, iColumns = oSettings.aoColumns.length; iColumn < iColumns; iColumn++) {
						if (oSettings.aoColumns[iColumn].bVisible) {
							anReturn.push(anTds[iColumn - iCorrector]);
						}
						else {
							anReturn.push(oData._anHidden[iColumn]);
							iCorrector++;
						}
					}
				}
			}

			return anReturn;
		}


		/**
		 * Log an error message
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iLevel log error messages, or display them to the user
		 *  @param {string} sMesg error message
		 *  @memberof DataTable#oApi
		 */
		function _fnLog(oSettings, iLevel, sMesg) {
			var sAlert = (oSettings === null) ?
				"DataTables warning: " + sMesg :
				"DataTables warning (table id = '" + oSettings.sTableId + "'): " + sMesg;

			if (iLevel === 0) {
				if (DataTable.ext.sErrMode == 'alert') {
					alert(sAlert);
				}
				else {
					throw new Error(sAlert);
				}
				return;
			}
			else if (window.console && console.log) {
				console.log(sAlert);
			}
		}


		/**
		 * See if a property is defined on one object, if so assign it to the other object
		 *  @param {object} oRet target object
		 *  @param {object} oSrc source object
		 *  @param {string} sName property
		 *  @param {string} [sMappedName] name to map too - optional, sName used if not given
		 *  @memberof DataTable#oApi
		 */
		function _fnMap(oRet, oSrc, sName, sMappedName) {
			if (sMappedName === undefined) {
				sMappedName = sName;
			}
			if (oSrc[sName] !== undefined) {
				oRet[sMappedName] = oSrc[sName];
			}
		}


		/**
		 * Extend objects - very similar to jQuery.extend, but deep copy objects, and shallow
		 * copy arrays. The reason we need to do this, is that we don't want to deep copy array
		 * init values (such as aaSorting) since the dev wouldn't be able to override them, but
		 * we do want to deep copy arrays.
		 *  @param {object} oOut Object to extend
		 *  @param {object} oExtender Object from which the properties will be applied to oOut
		 *  @returns {object} oOut Reference, just for convenience - oOut === the return.
		 *  @memberof DataTable#oApi
		 *  @todo This doesn't take account of arrays inside the deep copied objects.
		 */
		function _fnExtend(oOut, oExtender) {
			var val;

			for (var prop in oExtender) {
				if (oExtender.hasOwnProperty(prop)) {
					val = oExtender[prop];

					if (typeof oInit[prop] === 'object' && val !== null && $.isArray(val) === false) {
						$.extend(true, oOut[prop], val);
					}
					else {
						oOut[prop] = val;
					}
				}
			}

			return oOut;
		}


		/**
		 * Bind an event handers to allow a click or return key to activate the callback.
		 * This is good for accessibility since a return on the keyboard will have the
		 * same effect as a click, if the element has focus.
		 *  @param {element} n Element to bind the action to
		 *  @param {object} oData Data object to pass to the triggered function
		 *  @param {function} fn Callback function for when the event is triggered
		 *  @memberof DataTable#oApi
		 */
		function _fnBindAction(n, oData, fn) {
			$(n)
				.bind('click.DT', oData, function (e) {
					n.blur(); // Remove focus outline for mouse users
					fn(e);
				})
				.bind('keypress.DT', oData, function (e) {
					if (e.which === 13) {
						fn(e);
					}
				})
				.bind('selectstart.DT', function () {
					/* Take the brutal approach to cancelling text selection */
					return false;
				});
		}


		/**
		 * Register a callback function. Easily allows a callback function to be added to
		 * an array store of callback functions that can then all be called together.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
		 *  @param {function} fn Function to be called back
		 *  @param {string} sName Identifying name for the callback (i.e. a label)
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackReg(oSettings, sStore, fn, sName) {
			if (fn) {
				oSettings[sStore].push({
					"fn": fn,
					"sName": sName
				});
			}
		}


		/**
		 * Fire callback functions and trigger events. Note that the loop over the callback
		 * array store is done backwards! Further note that you do not want to fire off triggers
		 * in time sensitive applications (for example cell creation) as its slow.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
		 *  @param {string} sTrigger Name of the jQuery custom event to trigger. If null no trigger
		 *    is fired
		 *  @param {array} aArgs Array of arguments to pass to the callback function / trigger
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackFire(oSettings, sStore, sTrigger, aArgs) {
			var aoStore = oSettings[sStore];
			var aRet = [];

			for (var i = aoStore.length - 1; i >= 0; i--) {
				aRet.push(aoStore[i].fn.apply(oSettings.oInstance, aArgs));
			}

			if (sTrigger !== null) {
				$(oSettings.oInstance).trigger(sTrigger, aArgs);
			}

			return aRet;
		}


		/**
		 * JSON stringify. If JSON.stringify it provided by the browser, json2.js or any other
		 * library, then we use that as it is fast, safe and accurate. If the function isn't 
		 * available then we need to built it ourselves - the inspiration for this function comes
		 * from Craig Buckler ( http://www.sitepoint.com/javascript-json-serialization/ ). It is
		 * not perfect and absolutely should not be used as a replacement to json2.js - but it does
		 * do what we need, without requiring a dependency for DataTables.
		 *  @param {object} o JSON object to be converted
		 *  @returns {string} JSON string
		 *  @memberof DataTable#oApi
		 */
		var _fnJsonString = (window.JSON) ? JSON.stringify : function (o) {
			/* Not an object or array */
			var sType = typeof o;
			if (sType !== "object" || o === null) {
				// simple data type
				if (sType === "string") {
					o = '"' + o + '"';
				}
				return o + "";
			}

			/* If object or array, need to recurse over it */
			var
				sProp, mValue,
				json = [],
				bArr = $.isArray(o);

			for (sProp in o) {
				mValue = o[sProp];
				sType = typeof mValue;

				if (sType === "string") {
					mValue = '"' + mValue + '"';
				}
				else if (sType === "object" && mValue !== null) {
					mValue = _fnJsonString(mValue);
				}

				json.push((bArr ? "" : '"' + sProp + '":') + mValue);
			}

			return (bArr ? "[" : "{") + json + (bArr ? "]" : "}");
		};


		/**
		 * From some browsers (specifically IE6/7) we need special handling to work around browser
		 * bugs - this function is used to detect when these workarounds are needed.
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBrowserDetect(oSettings) {
			/* IE6/7 will oversize a width 100% element inside a scrolling element, to include the
			 * width of the scrollbar, while other browsers ensure the inner element is contained
			 * without forcing scrolling
			 */
			var n = $(
				'<div style="position:absolute; top:0; left:0; height:1px; width:1px; overflow:hidden">' +
				'<div style="position:absolute; top:1px; left:1px; width:100px; height:50px; overflow:scroll;">' +
				'<div id="DT_BrowserTest" style="width:100%; height:10px;"></div>' +
				'</div>' +
				'</div>')[0];

			document.body.appendChild(n);
			oSettings.oBrowser.bScrollOversize = $('#DT_BrowserTest', n)[0].offsetWidth === 100 ? true : false;
			document.body.removeChild(n);
		}




		/**
		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion ("applied") or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be 
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"filter": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
		 */
		this.$ = function (sSelector, oOpts) {
			var i, iLen, a = [], tr;
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			var aoData = oSettings.aoData;
			var aiDisplay = oSettings.aiDisplay;
			var aiDisplayMaster = oSettings.aiDisplayMaster;

			if (!oOpts) {
				oOpts = {};
			}

			oOpts = $.extend({}, {
				"filter": "none", // applied
				"order": "current", // "original"
				"page": "all" // current
			}, oOpts);

			// Current page implies that order=current and fitler=applied, since it is fairly
			// senseless otherwise
			if (oOpts.page == 'current') {
				for (i = oSettings._iDisplayStart, iLen = oSettings.fnDisplayEnd(); i < iLen; i++) {
					tr = aoData[aiDisplay[i]].nTr;
					if (tr) {
						a.push(tr);
					}
				}
			}
			else if (oOpts.order == "current" && oOpts.filter == "none") {
				for (i = 0, iLen = aiDisplayMaster.length; i < iLen; i++) {
					tr = aoData[aiDisplayMaster[i]].nTr;
					if (tr) {
						a.push(tr);
					}
				}
			}
			else if (oOpts.order == "current" && oOpts.filter == "applied") {
				for (i = 0, iLen = aiDisplay.length; i < iLen; i++) {
					tr = aoData[aiDisplay[i]].nTr;
					if (tr) {
						a.push(tr);
					}
				}
			}
			else if (oOpts.order == "original" && oOpts.filter == "none") {
				for (i = 0, iLen = aoData.length; i < iLen; i++) {
					tr = aoData[i].nTr;
					if (tr) {
						a.push(tr);
					}
				}
			}
			else if (oOpts.order == "original" && oOpts.filter == "applied") {
				for (i = 0, iLen = aoData.length; i < iLen; i++) {
					tr = aoData[i].nTr;
					if ($.inArray(i, aiDisplay) !== -1 && tr) {
						a.push(tr);
					}
				}
			}
			else {
				_fnLog(oSettings, 1, "Unknown selection options");
			}

			/* We need to filter on the TR elements and also 'find' in their descendants
			 * to make the selector act like it would in a full table - so we need
			 * to build both results and then combine them together
			 */
			var jqA = $(a);
			var jqTRs = jqA.filter(sSelector);
			var jqDescendants = jqA.find(sSelector);

			return $([].concat($.makeArray(jqTRs), $.makeArray(jqDescendants)));
		};


		/**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any descendants, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to  
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful in-combination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion ("applied") or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be 
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null 
		 *    entry in the array.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for 
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"filter": "applied"});
		 *      
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the filter" );
		 *    } );
		 */
		this._ = function (sSelector, oOpts) {
			var aOut = [];
			var i, iLen, iIndex;
			var aTrs = this.$(sSelector, oOpts);

			for (i = 0, iLen = aTrs.length; i < iLen; i++) {
				aOut.push(this.fnGetData(aTrs[i]));
			}

			return aOut;
		};


		/**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using 
		 * server-side processing (i.e. "bServerSide": true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} mData The data to be added to the table. This can be:
		 *    <ul>
		 *      <li>1D array of data - add a single row with the data provided</li>
		 *      <li>2D array of arrays - add multiple rows in a single call</li>
		 *      <li>object - data object when using <i>mData</i></li>
		 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
		 *    </ul>
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in 
		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to 
		 *    the table.
		 *  @dtopt API
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *    
		 *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
		 *    
		 *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *        
		 *      giCount++;
		 *    }
		 */
		this.fnAddData = function (mData, bRedraw) {
			if (mData.length === 0) {
				return [];
			}

			var aiReturn = [];
			var iTest;

			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

			/* Check if we want to add multiple rows or not */
			if (typeof mData[0] === "object" && mData[0] !== null) {
				for (var i = 0; i < mData.length; i++) {
					iTest = _fnAddData(oSettings, mData[i]);
					if (iTest == -1) {
						return aiReturn;
					}
					aiReturn.push(iTest);
				}
			}
			else {
				iTest = _fnAddData(oSettings, mData);
				if (iTest == -1) {
					return aiReturn;
				}
				aiReturn.push(iTest);
			}

			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

			if (bRedraw === undefined || bRedraw) {
				_fnReDraw(oSettings);
			}
			return aiReturn;
		};


		/**
		 * This function will make DataTables recalculate the column sizes, based on the data 
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or 
		 * through the sWidth parameter). This can be useful when the width of the table's 
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      $(window).bind('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
		this.fnAdjustColumnSizing = function (bRedraw) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			_fnAdjustColumnSizing(oSettings);

			if (bRedraw === undefined || bRedraw) {
				this.fnDraw(false);
			}
			else if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				this.oApi._fnScrollDraw(oSettings);
			}
		};


		/**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
		this.fnClearTable = function (bRedraw) {
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			_fnClearTable(oSettings);

			if (bRedraw === undefined || bRedraw) {
				_fnDraw(oSettings);
			}
		};


		/**
		 * The exact opposite of 'opening' a row, this function will close any rows which 
		 * are currently 'open'.
		 *  @param {node} nTr the table row to 'close'
		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnClose = function (nTr) {
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

			for (var i = 0; i < oSettings.aoOpenRows.length; i++) {
				if (oSettings.aoOpenRows[i].nParent == nTr) {
					var nTrParent = oSettings.aoOpenRows[i].nTr.parentNode;
					if (nTrParent) {
						/* Remove it if it is currently on display */
						nTrParent.removeChild(oSettings.aoOpenRows[i].nTr);
					}
					oSettings.aoOpenRows.splice(i, 1);
					return 0;
				}
			}
			return 1;
		};


		/**
		 * Remove a row for the table
		 *  @param {mixed} mTarget The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [fnCallBack] Callback function
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
		this.fnDeleteRow = function (mTarget, fnCallBack, bRedraw) {
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			var i, iLen, iAODataIndex;

			iAODataIndex = (typeof mTarget === 'object') ?
				_fnNodeToDataIndex(oSettings, mTarget) : mTarget;

			/* Return the data array from this row */
			var oData = oSettings.aoData.splice(iAODataIndex, 1);

			/* Update the _DT_RowIndex parameter */
			for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
				if (oSettings.aoData[i].nTr !== null) {
					oSettings.aoData[i].nTr._DT_RowIndex = i;
				}
			}

			/* Remove the target row from the search array */
			var iDisplayIndex = $.inArray(iAODataIndex, oSettings.aiDisplay);
			oSettings.asDataSearch.splice(iDisplayIndex, 1);

			/* Delete from the display arrays */
			_fnDeleteIndex(oSettings.aiDisplayMaster, iAODataIndex);
			_fnDeleteIndex(oSettings.aiDisplay, iAODataIndex);

			/* If there is a user callback function - call it */
			if (typeof fnCallBack === "function") {
				fnCallBack.call(this, oSettings, oData);
			}

			/* Check for an 'overflow' they case for displaying the table */
			if (oSettings._iDisplayStart >= oSettings.fnRecordsDisplay()) {
				oSettings._iDisplayStart -= oSettings._iDisplayLength;
				if (oSettings._iDisplayStart < 0) {
					oSettings._iDisplayStart = 0;
				}
			}

			if (bRedraw === undefined || bRedraw) {
				_fnCalculateEnd(oSettings);
				_fnDraw(oSettings);
			}

			return oData;
		};


		/**
		 * Restore the table to it's original state in the DOM by removing all of DataTables 
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [bRemove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
		this.fnDestroy = function (bRemove) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			var nOrig = oSettings.nTableWrapper.parentNode;
			var nBody = oSettings.nTBody;
			var i, iLen;

			bRemove = (bRemove === undefined) ? false : true;

			/* Flag to note that the table is currently being destroyed - no action should be taken */
			oSettings.bDestroying = true;

			/* Fire off the destroy callbacks for plug-ins etc */
			_fnCallbackFire(oSettings, "aoDestroyCallback", "destroy", [oSettings]);

			/* Restore hidden columns */
			for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				if (oSettings.aoColumns[i].bVisible === false) {
					this.fnSetColumnVis(i, true);
				}
			}

			/* Blitz all DT events */
			$(oSettings.nTableWrapper).find('*').andSelf().unbind('.DT');

			/* If there is an 'empty' indicator row, remove it */
			$('tbody>tr>td.' + oSettings.oClasses.sRowEmpty, oSettings.nTable).parent().remove();

			/* When scrolling we had to break the table up - restore it */
			if (oSettings.nTable != oSettings.nTHead.parentNode) {
				$(oSettings.nTable).children('thead').remove();
				oSettings.nTable.appendChild(oSettings.nTHead);
			}

			if (oSettings.nTFoot && oSettings.nTable != oSettings.nTFoot.parentNode) {
				$(oSettings.nTable).children('tfoot').remove();
				oSettings.nTable.appendChild(oSettings.nTFoot);
			}

			/* Remove the DataTables generated nodes, events and classes */
			oSettings.nTable.parentNode.removeChild(oSettings.nTable);
			$(oSettings.nTableWrapper).remove();

			oSettings.aaSorting = [];
			oSettings.aaSortingFixed = [];
			_fnSortingClasses(oSettings);

			$(_fnGetTrNodes(oSettings)).removeClass(oSettings.asStripeClasses.join(' '));

			$('th, td', oSettings.nTHead).removeClass([
				oSettings.oClasses.sSortable,
				oSettings.oClasses.sSortableAsc,
				oSettings.oClasses.sSortableDesc,
				oSettings.oClasses.sSortableNone].join(' ')
			);
			if (oSettings.bJUI) {
				$('th span.' + oSettings.oClasses.sSortIcon
					+ ', td span.' + oSettings.oClasses.sSortIcon, oSettings.nTHead).remove();

				$('th, td', oSettings.nTHead).each(function () {
					var jqWrapper = $('div.' + oSettings.oClasses.sSortJUIWrapper, this);
					var kids = jqWrapper.contents();
					$(this).append(kids);
					jqWrapper.remove();
				});
			}

			/* Add the TR elements back into the table in their original order */
			if (!bRemove && oSettings.nTableReinsertBefore) {
				nOrig.insertBefore(oSettings.nTable, oSettings.nTableReinsertBefore);
			}
			else if (!bRemove) {
				nOrig.appendChild(oSettings.nTable);
			}

			for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
				if (oSettings.aoData[i].nTr !== null) {
					nBody.appendChild(oSettings.aoData[i].nTr);
				}
			}

			/* Restore the width of the original table */
			if (oSettings.oFeatures.bAutoWidth === true) {
				oSettings.nTable.style.width = _fnStringToCss(oSettings.sDestroyWidth);
			}

			/* If the were originally odd/even type classes - then we add them back here. Note
			 * this is not fool proof (for example if not all rows as odd/even classes - but 
			 * it's a good effort without getting carried away
			 */
			$(nBody).children('tr:even').addClass(oSettings.asDestroyStripes[0]);
			$(nBody).children('tr:odd').addClass(oSettings.asDestroyStripes[1]);

			/* Remove the settings object from the settings array */
			for (i = 0, iLen = DataTable.settings.length; i < iLen; i++) {
				if (DataTable.settings[i] == oSettings) {
					DataTable.settings.splice(i, 1);
				}
			}

			/* End it all */
			oSettings = null;
		};


		/**
		 * Redraw the table
		 *  @param {bool} [bComplete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
		this.fnDraw = function (bComplete) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			if (bComplete === false) {
				_fnCalculateEnd(oSettings);
				_fnDraw(oSettings);
			}
			else {
				_fnReDraw(oSettings);
			}
		};


		/**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
		 */
		this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

			if (!oSettings.oFeatures.bFilter) {
				return;
			}

			if (bRegex === undefined || bRegex === null) {
				bRegex = false;
			}

			if (bSmart === undefined || bSmart === null) {
				bSmart = true;
			}

			if (bShowGlobal === undefined || bShowGlobal === null) {
				bShowGlobal = true;
			}

			if (bCaseInsensitive === undefined || bCaseInsensitive === null) {
				bCaseInsensitive = true;
			}

			if (iColumn === undefined || iColumn === null) {
				/* Global filter */
				_fnFilterComplete(oSettings, {
					"sSearch": sInput + "",
					"bRegex": bRegex,
					"bSmart": bSmart,
					"bCaseInsensitive": bCaseInsensitive
				}, 1);

				if (bShowGlobal && oSettings.aanFeatures.f) {
					var n = oSettings.aanFeatures.f;
					for (var i = 0, iLen = n.length; i < iLen; i++) {
						$(n[i]._DT_Input).val(sInput);
					}
				}
			}
			else {
				/* Single column filter */
				$.extend(oSettings.aoPreSearchCols[iColumn], {
					"sSearch": sInput + "",
					"bRegex": bRegex,
					"bSmart": bSmart,
					"bCaseInsensitive": bCaseInsensitive
				});
				_fnFilterComplete(oSettings, oSettings.oPreviousSearch, 1);
			}
		};


		/**
		 * Get the data for the whole table, an individual row or an individual cell based on the 
		 * provided parameters.
		 *  @param {int|node} [mRow] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [iCol] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
		 */
		this.fnGetData = function (mRow, iCol) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

			if (mRow !== undefined) {
				var iRow = mRow;
				if (typeof mRow === 'object') {
					var sNode = mRow.nodeName.toLowerCase();
					if (sNode === "tr") {
						iRow = _fnNodeToDataIndex(oSettings, mRow);
					}
					else if (sNode === "td") {
						iRow = _fnNodeToDataIndex(oSettings, mRow.parentNode);
						iCol = _fnNodeToColumnIndex(oSettings, iRow, mRow);
					}
				}

				if (iCol !== undefined) {
					return _fnGetCellData(oSettings, iRow, iCol, '');
				}
				return (oSettings.aoData[iRow] !== undefined) ?
					oSettings.aoData[iRow]._aData : null;
			}
			return _fnGetDataMaster(oSettings);
		};


		/**
		 * Get an array of the TR nodes that are used in the table's body. Note that you will 
		 * typically want to use the '$' API method in preference to this as it is more 
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table's body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
		this.fnGetNodes = function (iRow) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

			if (iRow !== undefined) {
				return (oSettings.aoData[iRow] !== undefined) ?
					oSettings.aoData[iRow].nTr : null;
			}
			return _fnGetTrNodes(oSettings);
		};


		/**
		 * Get the array indexes of a particular cell from it's DOM element
		 * and column index including hidden columns
		 *  @param {node} nNode this can either be a TR, TD or TH in the table's body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible)] is given.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *        
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *        
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *      
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnGetPosition = function (nNode) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			var sNodeName = nNode.nodeName.toUpperCase();

			if (sNodeName == "TR") {
				return _fnNodeToDataIndex(oSettings, nNode);
			}
			else if (sNodeName == "TD" || sNodeName == "TH") {
				var iDataIndex = _fnNodeToDataIndex(oSettings, nNode.parentNode);
				var iColumnIndex = _fnNodeToColumnIndex(oSettings, iDataIndex, nNode);
				return [iDataIndex, _fnColumnIndexToVisible(oSettings, iColumnIndex), iColumnIndex];
			}
			return null;
		};


		/**
		 * Check to see if a row is 'open' or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnIsOpen = function (nTr) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			var aoOpenRows = oSettings.aoOpenRows;

			for (var i = 0; i < oSettings.aoOpenRows.length; i++) {
				if (oSettings.aoOpenRows[i].nParent == nTr) {
					return true;
				}
			}
			return false;
		};


		/**
		 * This function will place a new row directly after a row which is currently 
		 * on display on the page, with the HTML contents that is passed into the 
		 * function. This can be used, for example, to ask for confirmation that a 
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to 'open'
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnOpen = function (nTr, mHtml, sClass) {
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

			/* Check that the row given is in the table */
			var nTableRows = _fnGetTrNodes(oSettings);
			if ($.inArray(nTr, nTableRows) === -1) {
				return;
			}

			/* the old open one if there is one */
			this.fnClose(nTr);

			var nNewRow = document.createElement("tr");
			var nNewCell = document.createElement("td");
			nNewRow.appendChild(nNewCell);
			nNewCell.className = sClass;
			nNewCell.colSpan = _fnVisbleColumns(oSettings);

			if (typeof mHtml === "string") {
				nNewCell.innerHTML = mHtml;
			}
			else {
				$(nNewCell).html(mHtml);
			}

			/* If the nTr isn't on the page at the moment - then we don't insert at the moment */
			var nTrs = $('tr', oSettings.nTBody);
			if ($.inArray(nTr, nTrs) != -1) {
				$(nNewRow).insertAfter(nTr);
			}

			oSettings.aoOpenRows.push({
				"nTr": nNewRow,
				"nParent": nTr
			});

			return nNewRow;
		};


		/**
		 * Change the pagination - provides the internal logic for pagination in a simple API 
		 * function. With this function you can have a DataTables table go to the next, 
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
		 */
		this.fnPageChange = function (mAction, bRedraw) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			_fnPageChange(oSettings, mAction);
			_fnCalculateEnd(oSettings);

			if (bRedraw === undefined || bRedraw) {
				_fnDraw(oSettings);
			}
		};


		/**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
		this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			var i, iLen;
			var aoColumns = oSettings.aoColumns;
			var aoData = oSettings.aoData;
			var nTd, bAppend, iBefore;

			/* No point in doing anything if we are requesting what is already true */
			if (aoColumns[iCol].bVisible == bShow) {
				return;
			}

			/* Show the column */
			if (bShow) {
				var iInsert = 0;
				for (i = 0; i < iCol; i++) {
					if (aoColumns[i].bVisible) {
						iInsert++;
					}
				}

				/* Need to decide if we should use appendChild or insertBefore */
				bAppend = (iInsert >= _fnVisbleColumns(oSettings));

				/* Which coloumn should we be inserting before? */
				if (!bAppend) {
					for (i = iCol; i < aoColumns.length; i++) {
						if (aoColumns[i].bVisible) {
							iBefore = i;
							break;
						}
					}
				}

				for (i = 0, iLen = aoData.length; i < iLen; i++) {
					if (aoData[i].nTr !== null) {
						if (bAppend) {
							aoData[i].nTr.appendChild(
								aoData[i]._anHidden[iCol]
							);
						}
						else {
							aoData[i].nTr.insertBefore(
								aoData[i]._anHidden[iCol],
								_fnGetTdNodes(oSettings, i)[iBefore]);
						}
					}
				}
			}
			else {
				/* Remove a column from display */
				for (i = 0, iLen = aoData.length; i < iLen; i++) {
					if (aoData[i].nTr !== null) {
						nTd = _fnGetTdNodes(oSettings, i)[iCol];
						aoData[i]._anHidden[iCol] = nTd;
						nTd.parentNode.removeChild(nTd);
					}
				}
			}

			/* Clear to set the visible flag */
			aoColumns[iCol].bVisible = bShow;

			/* Redraw the header and footer based on the new column visibility */
			_fnDrawHead(oSettings, oSettings.aoHeader);
			if (oSettings.nTFoot) {
				_fnDrawHead(oSettings, oSettings.aoFooter);
			}

			/* If there are any 'open' rows, then we need to alter the colspan for this col change */
			for (i = 0, iLen = oSettings.aoOpenRows.length; i < iLen; i++) {
				oSettings.aoOpenRows[i].nTr.colSpan = _fnVisbleColumns(oSettings);
			}

			/* Do a redraw incase anything depending on the table columns needs it 
			 * (built-in: scrolling) 
			 */
			if (bRedraw === undefined || bRedraw) {
				_fnAdjustColumnSizing(oSettings);
				_fnDraw(oSettings);
			}

			_fnSaveState(oSettings);
		};


		/**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See 
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *      
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
		this.fnSettings = function () {
			return _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
		};


		/**
		 * Sort the table by a particular column
		 *  @param {int} iCol the data index to sort on. Note that this will not match the 
		 *    'display index' if you have hidden data entries
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
		 */
		this.fnSort = function (aaSort) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			oSettings.aaSorting = aaSort;
			_fnSort(oSettings);
		};


		/**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
		 */
		this.fnSortListener = function (nNode, iColumn, fnCallback) {
			_fnSortAttachListener(_fnSettingsFromNode(this[DataTable.ext.iApiIndex]), nNode, iColumn,
				fnCallback);
		};


		/**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update (not used of mData is an array or object)
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform pre-draw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], 1, 0 ); // Row
		 *    } );
		 */
		this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			var i, iLen, sDisplay;
			var iRow = (typeof mRow === 'object') ?
				_fnNodeToDataIndex(oSettings, mRow) : mRow;

			if ($.isArray(mData) && iColumn === undefined) {
				/* Array update - update the whole row */
				oSettings.aoData[iRow]._aData = mData.slice();

				/* Flag to the function that we are recursing */
				for (i = 0; i < oSettings.aoColumns.length; i++) {
					this.fnUpdate(_fnGetCellData(oSettings, iRow, i), iRow, i, false, false);
				}
			}
			else if ($.isPlainObject(mData) && iColumn === undefined) {
				/* Object update - update the whole row - assume the developer gets the object right */
				oSettings.aoData[iRow]._aData = $.extend(true, {}, mData);

				for (i = 0; i < oSettings.aoColumns.length; i++) {
					this.fnUpdate(_fnGetCellData(oSettings, iRow, i), iRow, i, false, false);
				}
			}
			else {
				/* Individual cell update */
				_fnSetCellData(oSettings, iRow, iColumn, mData);
				sDisplay = _fnGetCellData(oSettings, iRow, iColumn, 'display');

				var oCol = oSettings.aoColumns[iColumn];
				if (oCol.fnRender !== null) {
					sDisplay = _fnRender(oSettings, iRow, iColumn);
					if (oCol.bUseRendered) {
						_fnSetCellData(oSettings, iRow, iColumn, sDisplay);
					}
				}

				if (oSettings.aoData[iRow].nTr !== null) {
					/* Do the actual HTML update */
					_fnGetTdNodes(oSettings, iRow)[iColumn].innerHTML = sDisplay;
				}
			}

			/* Modify the search index for this row (strictly this is likely not needed, since fnReDraw
			 * will rebuild the search array - however, the redraw might be disabled by the user)
			 */
			var iDisplayIndex = $.inArray(iRow, oSettings.aiDisplay);
			oSettings.asDataSearch[iDisplayIndex] = _fnBuildSearchRow(
				oSettings,
				_fnGetRowData(oSettings, iRow, 'filter', _fnGetColumns(oSettings, 'bSearchable'))
			);

			/* Perform pre-draw actions */
			if (bAction === undefined || bAction) {
				_fnAdjustColumnSizing(oSettings);
			}

			/* Redraw the table */
			if (bRedraw === undefined || bRedraw) {
				_fnReDraw(oSettings);
			}
			return 0;
		};


		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
		 *    formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		this.fnVersionCheck = DataTable.ext.fnVersionCheck;


		/*
		 * This is really a good bit rubbish this method of exposing the internal methods
		 * publicly... - To be fixed in 2.0 using methods on the prototype
		 */


		/**
		 * Create a wrapper function for exporting an internal functions to an external API.
		 *  @param {string} sFunc API function name
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#oApi
		 */
		function _fnExternApiFunc(sFunc) {
			return function () {
				var aArgs = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
					Array.prototype.slice.call(arguments));
				return DataTable.ext.oApi[sFunc].apply(this, aArgs);
			};
		}


		/**
		 * Reference to internal functions for use by plug-in developers. Note that these
		 * methods are references to internal functions and are considered to be private.
		 * If you use these methods, be aware that they are liable to change between versions
		 * (check the upgrade notes).
		 *  @namespace
		 */
		this.oApi = {
			"_fnExternApiFunc": _fnExternApiFunc,
			"_fnInitialise": _fnInitialise,
			"_fnInitComplete": _fnInitComplete,
			"_fnLanguageCompat": _fnLanguageCompat,
			"_fnAddColumn": _fnAddColumn,
			"_fnColumnOptions": _fnColumnOptions,
			"_fnAddData": _fnAddData,
			"_fnCreateTr": _fnCreateTr,
			"_fnGatherData": _fnGatherData,
			"_fnBuildHead": _fnBuildHead,
			"_fnDrawHead": _fnDrawHead,
			"_fnDraw": _fnDraw,
			"_fnReDraw": _fnReDraw,
			"_fnAjaxUpdate": _fnAjaxUpdate,
			"_fnAjaxParameters": _fnAjaxParameters,
			"_fnAjaxUpdateDraw": _fnAjaxUpdateDraw,
			"_fnServerParams": _fnServerParams,
			"_fnAddOptionsHtml": _fnAddOptionsHtml,
			"_fnFeatureHtmlTable": _fnFeatureHtmlTable,
			"_fnScrollDraw": _fnScrollDraw,
			"_fnAdjustColumnSizing": _fnAdjustColumnSizing,
			"_fnFeatureHtmlFilter": _fnFeatureHtmlFilter,
			"_fnFilterComplete": _fnFilterComplete,
			"_fnFilterCustom": _fnFilterCustom,
			"_fnFilterColumn": _fnFilterColumn,
			"_fnFilter": _fnFilter,
			"_fnBuildSearchArray": _fnBuildSearchArray,
			"_fnBuildSearchRow": _fnBuildSearchRow,
			"_fnFilterCreateSearch": _fnFilterCreateSearch,
			"_fnDataToSearch": _fnDataToSearch,
			"_fnSort": _fnSort,
			"_fnSortAttachListener": _fnSortAttachListener,
			"_fnSortingClasses": _fnSortingClasses,
			"_fnFeatureHtmlPaginate": _fnFeatureHtmlPaginate,
			"_fnPageChange": _fnPageChange,
			"_fnFeatureHtmlInfo": _fnFeatureHtmlInfo,
			"_fnUpdateInfo": _fnUpdateInfo,
			"_fnFeatureHtmlLength": _fnFeatureHtmlLength,
			"_fnFeatureHtmlProcessing": _fnFeatureHtmlProcessing,
			"_fnProcessingDisplay": _fnProcessingDisplay,
			"_fnVisibleToColumnIndex": _fnVisibleToColumnIndex,
			"_fnColumnIndexToVisible": _fnColumnIndexToVisible,
			"_fnNodeToDataIndex": _fnNodeToDataIndex,
			"_fnVisbleColumns": _fnVisbleColumns,
			"_fnCalculateEnd": _fnCalculateEnd,
			"_fnConvertToWidth": _fnConvertToWidth,
			"_fnCalculateColumnWidths": _fnCalculateColumnWidths,
			"_fnScrollingWidthAdjust": _fnScrollingWidthAdjust,
			"_fnGetWidestNode": _fnGetWidestNode,
			"_fnGetMaxLenString": _fnGetMaxLenString,
			"_fnStringToCss": _fnStringToCss,
			"_fnDetectType": _fnDetectType,
			"_fnSettingsFromNode": _fnSettingsFromNode,
			"_fnGetDataMaster": _fnGetDataMaster,
			"_fnGetTrNodes": _fnGetTrNodes,
			"_fnGetTdNodes": _fnGetTdNodes,
			"_fnEscapeRegex": _fnEscapeRegex,
			"_fnDeleteIndex": _fnDeleteIndex,
			"_fnReOrderIndex": _fnReOrderIndex,
			"_fnColumnOrdering": _fnColumnOrdering,
			"_fnLog": _fnLog,
			"_fnClearTable": _fnClearTable,
			"_fnSaveState": _fnSaveState,
			"_fnLoadState": _fnLoadState,
			"_fnCreateCookie": _fnCreateCookie,
			"_fnReadCookie": _fnReadCookie,
			"_fnDetectHeader": _fnDetectHeader,
			"_fnGetUniqueThs": _fnGetUniqueThs,
			"_fnScrollBarWidth": _fnScrollBarWidth,
			"_fnApplyToChildren": _fnApplyToChildren,
			"_fnMap": _fnMap,
			"_fnGetRowData": _fnGetRowData,
			"_fnGetCellData": _fnGetCellData,
			"_fnSetCellData": _fnSetCellData,
			"_fnGetObjectDataFn": _fnGetObjectDataFn,
			"_fnSetObjectDataFn": _fnSetObjectDataFn,
			"_fnApplyColumnDefs": _fnApplyColumnDefs,
			"_fnBindAction": _fnBindAction,
			"_fnExtend": _fnExtend,
			"_fnCallbackReg": _fnCallbackReg,
			"_fnCallbackFire": _fnCallbackFire,
			"_fnJsonString": _fnJsonString,
			"_fnRender": _fnRender,
			"_fnNodeToColumnIndex": _fnNodeToColumnIndex,
			"_fnInfoMacros": _fnInfoMacros,
			"_fnBrowserDetect": _fnBrowserDetect,
			"_fnGetColumns": _fnGetColumns
		};

		$.extend(DataTable.ext.oApi, this.oApi);

		for (var sFunc in DataTable.ext.oApi) {
			if (sFunc) {
				this[sFunc] = _fnExternApiFunc(sFunc);
			}
		}


		var _that = this;
		return this.each(function () {

			var i = 0, iLen, j, jLen, k, kLen;
			var sId = this.getAttribute('id');
			var bInitHandedOff = false;
			var bUsePassedData = false;


			/* Sanity check */
			if (this.nodeName.toLowerCase() != 'table') {
				_fnLog(null, 0, "Attempted to initialise DataTables on a node which is not a " +
					"table: " + this.nodeName);
				return;
			}

			/* Check to see if we are re-initialising a table */
			for (i = 0, iLen = DataTable.settings.length; i < iLen; i++) {
				/* Base check on table node */
				if (DataTable.settings[i].nTable == this) {
					if (oInit === undefined || oInit.bRetrieve) {
						return DataTable.settings[i].oInstance;
					}
					else if (oInit.bDestroy) {
						DataTable.settings[i].oInstance.fnDestroy();
						break;
					}
					else {
						_fnLog(DataTable.settings[i], 0, "Cannot reinitialise DataTable.\n\n" +
							"To retrieve the DataTables object for this table, pass no arguments or see " +
							"the docs for bRetrieve and bDestroy");
						return;
					}
				}

				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if (DataTable.settings[i].sTableId == this.id) {
					DataTable.settings.splice(i, 1);
					break;
				}
			}

			/* Ensure the table has an ID - required for accessibility */
			if (sId === null || sId === "") {
				sId = "DataTables_Table_" + (DataTable.ext._oExternConfig.iNextUnique++);
				this.id = sId;
			}

			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
				"nTable": this,
				"oApi": _that.oApi,
				"oInit": oInit,
				"sDestroyWidth": $(this).width(),
				"sInstance": sId,
				"sTableId": sId
			});
			DataTable.settings.push(oSettings);

			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = (_that.length === 1) ? _that : $(this).dataTable();

			/* Setting up the initialisation object */
			if (!oInit) {
				oInit = {};
			}

			// Backwards compatibility, before we apply all the defaults
			if (oInit.oLanguage) {
				_fnLanguageCompat(oInit.oLanguage);
			}

			oInit = _fnExtend($.extend(true, {}, DataTable.defaults), oInit);

			// Map the initialisation options onto the settings object
			_fnMap(oSettings.oFeatures, oInit, "bPaginate");
			_fnMap(oSettings.oFeatures, oInit, "bLengthChange");
			_fnMap(oSettings.oFeatures, oInit, "bFilter");
			_fnMap(oSettings.oFeatures, oInit, "bSort");
			_fnMap(oSettings.oFeatures, oInit, "bInfo");
			_fnMap(oSettings.oFeatures, oInit, "bProcessing");
			_fnMap(oSettings.oFeatures, oInit, "bAutoWidth");
			_fnMap(oSettings.oFeatures, oInit, "bSortClasses");
			_fnMap(oSettings.oFeatures, oInit, "bServerSide");
			_fnMap(oSettings.oFeatures, oInit, "bDeferRender");
			_fnMap(oSettings.oScroll, oInit, "sScrollX", "sX");
			_fnMap(oSettings.oScroll, oInit, "sScrollXInner", "sXInner");
			_fnMap(oSettings.oScroll, oInit, "sScrollY", "sY");
			_fnMap(oSettings.oScroll, oInit, "bScrollCollapse", "bCollapse");
			_fnMap(oSettings.oScroll, oInit, "bScrollInfinite", "bInfinite");
			_fnMap(oSettings.oScroll, oInit, "iScrollLoadGap", "iLoadGap");
			_fnMap(oSettings.oScroll, oInit, "bScrollAutoCss", "bAutoCss");
			_fnMap(oSettings, oInit, "asStripeClasses");
			_fnMap(oSettings, oInit, "asStripClasses", "asStripeClasses"); // legacy
			_fnMap(oSettings, oInit, "fnServerData");
			_fnMap(oSettings, oInit, "fnFormatNumber");
			_fnMap(oSettings, oInit, "sServerMethod");
			_fnMap(oSettings, oInit, "aaSorting");
			_fnMap(oSettings, oInit, "aaSortingFixed");
			_fnMap(oSettings, oInit, "aLengthMenu");
			_fnMap(oSettings, oInit, "sPaginationType");
			_fnMap(oSettings, oInit, "sAjaxSource");
			_fnMap(oSettings, oInit, "sAjaxDataProp");
			_fnMap(oSettings, oInit, "iCookieDuration");
			_fnMap(oSettings, oInit, "sCookiePrefix");
			_fnMap(oSettings, oInit, "sDom");
			_fnMap(oSettings, oInit, "bSortCellsTop");
			_fnMap(oSettings, oInit, "iTabIndex");
			_fnMap(oSettings, oInit, "oSearch", "oPreviousSearch");
			_fnMap(oSettings, oInit, "aoSearchCols", "aoPreSearchCols");
			_fnMap(oSettings, oInit, "iDisplayLength", "_iDisplayLength");
			_fnMap(oSettings, oInit, "bJQueryUI", "bJUI");
			_fnMap(oSettings, oInit, "fnCookieCallback");
			_fnMap(oSettings, oInit, "fnStateLoad");
			_fnMap(oSettings, oInit, "fnStateSave");
			_fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");

			/* Callback functions which are array driven */
			_fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
			_fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
			_fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
			_fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
			_fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
			_fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
			_fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
			_fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
			_fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
			_fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
			_fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

			if (oSettings.oFeatures.bServerSide && oSettings.oFeatures.bSort &&
				oSettings.oFeatures.bSortClasses) {
				/* Enable sort classes for server-side processing. Safe to do it here, since server-side
				 * processing must be enabled by the developer
				 */
				_fnCallbackReg(oSettings, 'aoDrawCallback', _fnSortingClasses, 'server_side_sort_classes');
			}
			else if (oSettings.oFeatures.bDeferRender) {
				_fnCallbackReg(oSettings, 'aoDrawCallback', _fnSortingClasses, 'defer_sort_classes');
			}

			if (oInit.bJQueryUI) {
				/* Use the JUI classes object for display. You could clone the oStdClasses object if 
				 * you want to have multiple tables with multiple independent classes 
				 */
				$.extend(oSettings.oClasses, DataTable.ext.oJUIClasses);

				if (oInit.sDom === DataTable.defaults.sDom && DataTable.defaults.sDom === "lfrtip") {
					/* Set the DOM to use a layout suitable for jQuery UI's theming */
					oSettings.sDom = '<"H"lfr>t<"F"ip>';
				}
			}
			else {
				$.extend(oSettings.oClasses, DataTable.ext.oStdClasses);
			}
			$(this).addClass(oSettings.oClasses.sTable);

			/* Calculate the scroll bar width and cache it for use later on */
			if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
				oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
			}

			if (oSettings.iInitDisplayStart === undefined) {
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}

			/* Must be done after everything which can be overridden by a cookie! */
			if (oInit.bStateSave) {
				oSettings.oFeatures.bStateSave = true;
				_fnLoadState(oSettings, oInit);
				_fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
			}

			if (oInit.iDeferLoading !== null) {
				oSettings.bDeferLoading = true;
				var tmp = $.isArray(oInit.iDeferLoading);
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
			}

			if (oInit.aaData !== null) {
				bUsePassedData = true;
			}

			/* Language definitions */
			if (oInit.oLanguage.sUrl !== "") {
				/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that 
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
				oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
				$.getJSON(oSettings.oLanguage.sUrl, null, function (json) {
					_fnLanguageCompat(json);
					$.extend(true, oSettings.oLanguage, oInit.oLanguage, json);
					_fnInitialise(oSettings);
				});
				bInitHandedOff = true;
			}
			else {
				$.extend(true, oSettings.oLanguage, oInit.oLanguage);
			}


			/*
			 * Stripes
			 */
			if (oInit.asStripeClasses === null) {
				oSettings.asStripeClasses = [
					oSettings.oClasses.sStripeOdd,
					oSettings.oClasses.sStripeEven
				];
			}

			/* Remove row stripe classes if they are already on the table row */
			var bStripeRemove = false;
			var anRows = $(this).children('tbody').children('tr');
			for (i = 0, iLen = oSettings.asStripeClasses.length; i < iLen; i++) {
				if (anRows.filter(":lt(2)").hasClass(oSettings.asStripeClasses[i])) {
					bStripeRemove = true;
					break;
				}
			}

			if (bStripeRemove) {
				/* Store the classes which we are about to remove so they can be re-added on destroy */
				oSettings.asDestroyStripes = ['', ''];
				if ($(anRows[0]).hasClass(oSettings.oClasses.sStripeOdd)) {
					oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeOdd + " ";
				}
				if ($(anRows[0]).hasClass(oSettings.oClasses.sStripeEven)) {
					oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeEven;
				}
				if ($(anRows[1]).hasClass(oSettings.oClasses.sStripeOdd)) {
					oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeOdd + " ";
				}
				if ($(anRows[1]).hasClass(oSettings.oClasses.sStripeEven)) {
					oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeEven;
				}

				anRows.removeClass(oSettings.asStripeClasses.join(' '));
			}


			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName('thead');
			if (nThead.length !== 0) {
				_fnDetectHeader(oSettings.aoHeader, nThead[0]);
				anThs = _fnGetUniqueThs(oSettings);
			}

			/* If not given a column array, generate one with nulls */
			if (oInit.aoColumns === null) {
				aoColumnsInit = [];
				for (i = 0, iLen = anThs.length; i < iLen; i++) {
					aoColumnsInit.push(null);
				}
			}
			else {
				aoColumnsInit = oInit.aoColumns;
			}

			/* Add the columns */
			for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
				/* Short cut - use the loop to check if we have column visibility state to restore */
				if (oInit.saved_aoColumns !== undefined && oInit.saved_aoColumns.length == iLen) {
					if (aoColumnsInit[i] === null) {
						aoColumnsInit[i] = {};
					}
					aoColumnsInit[i].bVisible = oInit.saved_aoColumns[i].bVisible;
				}

				_fnAddColumn(oSettings, anThs ? anThs[i] : null);
			}

			/* Apply the column definitions */
			_fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions(oSettings, iCol, oDef);
			});


			/*
			 * Sorting
			 * Check the aaSorting array
			 */
			for (i = 0, iLen = oSettings.aaSorting.length; i < iLen; i++) {
				if (oSettings.aaSorting[i][0] >= oSettings.aoColumns.length) {
					oSettings.aaSorting[i][0] = 0;
				}
				var oColumn = oSettings.aoColumns[oSettings.aaSorting[i][0]];

				/* Add a default sorting index */
				if (oSettings.aaSorting[i][2] === undefined) {
					oSettings.aaSorting[i][2] = 0;
				}

				/* If aaSorting is not defined, then we use the first indicator in asSorting */
				if (oInit.aaSorting === undefined && oSettings.saved_aaSorting === undefined) {
					oSettings.aaSorting[i][1] = oColumn.asSorting[0];
				}

				/* Set the current sorting index based on aoColumns.asSorting */
				for (j = 0, jLen = oColumn.asSorting.length; j < jLen; j++) {
					if (oSettings.aaSorting[i][1] == oColumn.asSorting[j]) {
						oSettings.aaSorting[i][2] = j;
						break;
					}
				}
			}

			/* Do a first pass on the sorting classes (allows any size changes to be taken into
			 * account, and also will apply sorting disabled classes if disabled
			 */
			_fnSortingClasses(oSettings);


			/*
			 * Final init
			 * Cache the header, body and footer as required, creating them if needed
			 */

			/* Browser support detection */
			_fnBrowserDetect(oSettings);

			// Work around for Webkit bug 83867 - store the caption-side before removing from doc
			var captions = $(this).children('caption').each(function () {
				this._captionSide = $(this).css('caption-side');
			});

			var thead = $(this).children('thead');
			if (thead.length === 0) {
				thead = [document.createElement('thead')];
				this.appendChild(thead[0]);
			}
			oSettings.nTHead = thead[0];

			var tbody = $(this).children('tbody');
			if (tbody.length === 0) {
				tbody = [document.createElement('tbody')];
				this.appendChild(tbody[0]);
			}
			oSettings.nTBody = tbody[0];
			oSettings.nTBody.setAttribute("role", "alert");
			oSettings.nTBody.setAttribute("aria-live", "polite");
			oSettings.nTBody.setAttribute("aria-relevant", "all");

			var tfoot = $(this).children('tfoot');
			if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
				// If we are a scrolling table, and no footer has been given, then we need to create
				// a tfoot element for the caption element to be appended to
				tfoot = [document.createElement('tfoot')];
				this.appendChild(tfoot[0]);
			}

			if (tfoot.length > 0) {
				oSettings.nTFoot = tfoot[0];
				_fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
			}

			/* Check if there is data passing into the constructor */
			if (bUsePassedData) {
				for (i = 0; i < oInit.aaData.length; i++) {
					_fnAddData(oSettings, oInit.aaData[i]);
				}
			}
			else {
				/* Grab the data from the page */
				_fnGatherData(oSettings);
			}

			/* Copy the data index array */
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

			/* Initialisation complete - table can be drawn */
			oSettings.bInitialised = true;

			/* Check if we need to initialise the table (it might not have been handed off to the
			 * language processor)
			 */
			if (bInitHandedOff === false) {
				_fnInitialise(oSettings);
			}
		});
	};



	/**
	 * Provide a common method for plug-ins to check the version of DataTables being used, in order
	 * to ensure compatibility.
	 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
	 *    formats "X" and "X.Y" are also acceptable.
	 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
	 *    version, or false if this version of DataTales is not suitable
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    alert( $.fn.dataTable.fnVersionCheck( '1.9.0' ) );
	 */
	DataTable.fnVersionCheck = function (sVersion) {
		/* This is cheap, but effective */
		var fnZPad = function (Zpad, count) {
			while (Zpad.length < count) {
				Zpad += '0';
			}
			return Zpad;
		};
		var aThis = DataTable.ext.sVersion.split('.');
		var aThat = sVersion.split('.');
		var sThis = '', sThat = '';

		for (var i = 0, iLen = aThat.length; i < iLen; i++) {
			sThis += fnZPad(aThis[i], 3);
			sThat += fnZPad(aThat[i], 3);
		}

		return parseInt(sThis, 10) >= parseInt(sThat, 10);
	};


	/**
	 * Check if a TABLE node is a DataTable table already or not.
	 *  @param {node} nTable The TABLE node to check if it is a DataTable or not (note that other
	 *    node types can be passed in, but will always return false).
	 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    var ex = document.getElementById('example');
	 *    if ( ! $.fn.DataTable.fnIsDataTable( ex ) ) {
	 *      $(ex).dataTable();
	 *    }
	 */
	DataTable.fnIsDataTable = function (nTable) {
		var o = DataTable.settings;

		for (var i = 0; i < o.length; i++) {
			if (o[i].nTable === nTable || o[i].nScrollHead === nTable || o[i].nScrollFoot === nTable) {
				return true;
			}
		}

		return false;
	};


	/**
	 * Get all DataTable tables that have been initialised - optionally you can select to
	 * get only currently visible tables.
	 *  @param {boolean} [bVisible=false] Flag to indicate if you want all (default) or 
	 *    visible tables only.
	 *  @returns {array} Array of TABLE nodes (not DataTable instances) which are DataTables
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    var table = $.fn.dataTable.fnTables(true);
	 *    if ( table.length > 0 ) {
	 *      $(table).dataTable().fnAdjustColumnSizing();
	 *    }
	 */
	DataTable.fnTables = function (bVisible) {
		var out = [];

		jQuery.each(DataTable.settings, function (i, o) {
			if (!bVisible || (bVisible === true && $(o.nTable).is(':visible'))) {
				out.push(o.nTable);
			}
		});

		return out;
	};


	/**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
	 * e are optional
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
	DataTable.version = "1.9.3";

	/**
	 * Private data store, containing all of the settings objects that are created for the
	 * tables on a given page.
	 * 
	 * Note that the <i>DataTable.settings</i> object is aliased to <i>jQuery.fn.dataTableExt</i> 
	 * through which it may be accessed and manipulated, or <i>jQuery.fn.dataTable.settings</i>.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
	DataTable.settings = [];

	/**
	 * Object models container, for the various models that DataTables has available
	 * to it. These models define the objects that are used to hold the active state 
	 * and configuration of the table.
	 *  @namespace
	 */
	DataTable.models = {};


	/**
	 * DataTables extension options and plug-ins. This namespace acts as a collection "area"
	 * for plug-ins that can be used to extend the default DataTables behaviour - indeed many
	 * of the build in methods use this method to provide their own capabilities (sorting methods
	 * for example).
	 * 
	 * Note that this namespace is aliased to jQuery.fn.dataTableExt so it can be readily accessed
	 * and modified by plug-ins.
	 *  @namespace
	 */
	DataTable.models.ext = {
		/**
		 * Plug-in filtering functions - this method of filtering is complimentary to the default
		 * type based filtering, and a lot more comprehensive as it allows you complete control
		 * over the filtering logic. Each element in this array is a function (parameters
		 * described below) that is called for every row in the table, and your logic decides if
		 * it should be included in the filtered data set or not.
		 *   <ul>
		 *     <li>
		 *       Function input parameters:
		 *       <ul>
		 *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *         <li>{array|object} Data for the row to be processed (same as the original format
		 *           that was passed in as the data source, or an array from a DOM data source</li>
		 *         <li>{int} Row index in aoData ({@link DataTable.models.oSettings.aoData}), which can
		 *           be useful to retrieve the TR element if you need DOM interaction.</li>
		 *       </ul>
		 *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{boolean} Include the row in the filtered result set (true) or not (false)</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type array
		 *  @default []
		 *
		 *  @example
		 *    // The following example shows custom filtering being applied to the fourth column (i.e.
		 *    // the aData[3] index) based on two input values from the end-user, matching the data in 
		 *    // a certain range.
		 *    $.fn.dataTableExt.afnFiltering.push(
		 *      function( oSettings, aData, iDataIndex ) {
		 *        var iMin = document.getElementById('min').value * 1;
		 *        var iMax = document.getElementById('max').value * 1;
		 *        var iVersion = aData[3] == "-" ? 0 : aData[3]*1;
		 *        if ( iMin == "" && iMax == "" ) {
		 *          return true;
		 *        }
		 *        else if ( iMin == "" && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && "" == iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
		 *    );
		 */
		"afnFiltering": [],


		/**
		 * Plug-in sorting functions - this method of sorting is complimentary to the default type
		 * based sorting that DataTables does automatically, allowing much greater control over the
		 * the data that is being used to sort a column. This is useful if you want to do sorting
		 * based on live data (for example the contents of an 'input' element) rather than just the
		 * static string that DataTables knows of. The way these plug-ins work is that you create
		 * an array of the values you wish to be sorted for the column in question and then return
		 * that array. Which pre-sorting function is run here depends on the sSortDataType parameter
		 * that is used for the column (if any). This is the corollary of <i>ofnSearch</i> for sort 
		 * data.
		 *   <ul>
		 *     <li>
		 *       Function input parameters:
		 *       <ul>
		 *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *         <li>{int} Target column index</li>
		 *       </ul>
		 *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{array} Data for the column to be sorted upon</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  
		 * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
		 * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
		 * used as a function will give you a 'type' (sorting, filtering etc) that you can use to 
		 * prepare the data as required for the different types. As such, this method is deprecated.
		 *  @type array
		 *  @default []
		 *  @deprecated
		 *
		 *  @example
		 *    // Updating the cached sorting information with user entered values in HTML input elements
		 *    jQuery.fn.dataTableExt.afnSortData['dom-text'] = function ( oSettings, iColumn )
		 *    {
		 *      var aData = [];
		 *      $( 'td:eq('+iColumn+') input', oSettings.oApi._fnGetTrNodes(oSettings) ).each( function () {
		 *        aData.push( this.value );
		 *      } );
		 *      return aData;
		 *    }
		 */
		"afnSortData": [],


		/**
		 * Feature plug-ins - This is an array of objects which describe the feature plug-ins that are
		 * available to DataTables. These feature plug-ins are accessible through the sDom initialisation
		 * option. As such, each feature plug-in must describe a function that is used to initialise
		 * itself (fnInit), a character so the feature can be enabled by sDom (cFeature) and the name
		 * of the feature (sFeature). Thus the objects attached to this method must provide:
		 *   <ul>
		 *     <li>{function} fnInit Initialisation of the plug-in
		 *       <ul>
		 *         <li>
		 *           Function input parameters:
		 *           <ul>
		 *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *           </ul>
		 *         </li>
		 *         <li>
		 *           Function return:
		 *           <ul>
		 *             <li>{node|null} The element which contains your feature. Note that the return
		 *                may also be void if your plug-in does not require to inject any DOM elements 
		 *                into DataTables control (sDom) - for example this might be useful when 
		 *                developing a plug-in which allows table control via keyboard entry.</li>
		 *           </ul>
		 *         </il>
		 *       </ul>
		 *     </li>
		 *     <li>{character} cFeature Character that will be matched in sDom - case sensitive</li>
		 *     <li>{string} sFeature Feature name</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 * 
		 *  @example
		 *    // How TableTools initialises itself.
		 *    $.fn.dataTableExt.aoFeatures.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T",
		 *      "sFeature": "TableTools"
		 *    } );
		 */
		"aoFeatures": [],


		/**
		 * Type detection plug-in functions - DataTables utilises types to define how sorting and
		 * filtering behave, and types can be either  be defined by the developer (sType for the
		 * column) or they can be automatically detected by the methods in this array. The functions
		 * defined in the array are quite simple, taking a single parameter (the data to analyse) 
		 * and returning the type if it is a known type, or null otherwise.
		 *   <ul>
		 *     <li>
		 *       Function input parameters:
		 *       <ul>
		 *         <li>{*} Data from the column cell to be analysed</li>
		 *       </ul>
		 *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{string|null} Data type detected, or null if unknown (and thus pass it
		 *           on to the other type detection functions.</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type array
		 *  @default []
		 *  
		 *  @example
		 *    // Currency type detection plug-in:
		 *    jQuery.fn.dataTableExt.aTypes.push(
		 *      function ( sData ) {
		 *        var sValidChars = "0123456789.-";
		 *        var Char;
		 *        
		 *        // Check the numeric part
		 *        for ( i=1 ; i<sData.length ; i++ ) {
		 *          Char = sData.charAt(i); 
		 *          if (sValidChars.indexOf(Char) == -1) {
		 *            return null;
		 *          }
		 *        }
		 *        
		 *        // Check prefixed by currency
		 *        if ( sData.charAt(0) == '$' || sData.charAt(0) == '&pound;' ) {
		 *          return 'currency';
		 *        }
		 *        return null;
		 *      }
		 *    );
		 */
		"aTypes": [],


		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, 
		 * in order to ensure compatibility.
		 *  @type function
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note 
		 *    that the formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the 
		 *    required version, or false if this version of DataTales is not suitable
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		"fnVersionCheck": DataTable.fnVersionCheck,


		/**
		 * Index for what 'this' index API functions should use
		 *  @type int
		 *  @default 0
		 */
		"iApiIndex": 0,


		/**
		 * Pre-processing of filtering data plug-ins - When you assign the sType for a column
		 * (or have it automatically detected for you by DataTables or a type detection plug-in), 
		 * you will typically be using this for custom sorting, but it can also be used to provide 
		 * custom filtering by allowing you to pre-processing the data and returning the data in
		 * the format that should be filtered upon. This is done by adding functions this object 
		 * with a parameter name which matches the sType for that target column. This is the
		 * corollary of <i>afnSortData</i> for filtering data.
		 *   <ul>
		 *     <li>
		 *       Function input parameters:
		 *       <ul>
		 *         <li>{*} Data from the column cell to be prepared for filtering</li>
		 *       </ul>
		 *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{string|null} Formatted string that will be used for the filtering.</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 * 
		 * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
		 * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
		 * used as a function will give you a 'type' (sorting, filtering etc) that you can use to 
		 * prepare the data as required for the different types. As such, this method is deprecated.
		 *  @type object
		 *  @default {}
		 *  @deprecated
		 *
		 *  @example
		 *    $.fn.dataTableExt.ofnSearch['title-numeric'] = function ( sData ) {
		 *      return sData.replace(/\n/g," ").replace( /<.*?>/g, "" );
		 *    }
		 */
		"ofnSearch": {},


		/**
		 * Container for all private functions in DataTables so they can be exposed externally
		 *  @type object
		 *  @default {}
		 */
		"oApi": {},


		/**
		 * Storage for the various classes that DataTables uses
		 *  @type object
		 *  @default {}
		 */
		"oStdClasses": {},


		/**
		 * Storage for the various classes that DataTables uses - jQuery UI suitable
		 *  @type object
		 *  @default {}
		 */
		"oJUIClasses": {},


		/**
		 * Pagination plug-in methods - The style and controls of the pagination can significantly 
		 * impact on how the end user interacts with the data in your table, and DataTables allows 
		 * the addition of pagination controls by extending this object, which can then be enabled
		 * through the <i>sPaginationType</i> initialisation parameter. Each pagination type that
		 * is added is an object (the property name of which is what <i>sPaginationType</i> refers
		 * to) that has two properties, both methods that are used by DataTables to update the
		 * control's state.
		 *   <ul>
		 *     <li>
		 *       fnInit -  Initialisation of the paging controls. Called only during initialisation 
		 *         of the table. It is expected that this function will add the required DOM elements 
		 *         to the page for the paging controls to work. The element pointer 
		 *         'oSettings.aanFeatures.p' array is provided by DataTables to contain the paging 
		 *         controls (note that this is a 2D array to allow for multiple instances of each 
		 *         DataTables DOM element). It is suggested that you add the controls to this element 
		 *         as children
		 *       <ul>
		 *         <li>
		 *           Function input parameters:
		 *           <ul>
		 *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *             <li>{node} Container into which the pagination controls must be inserted</li>
		 *             <li>{function} Draw callback function - whenever the controls cause a page
		 *               change, this method must be called to redraw the table.</li>
		 *           </ul>
		 *         </li>
		 *         <li>
		 *           Function return:
		 *           <ul>
		 *             <li>No return required</li>
		 *           </ul>
		 *         </il>
		 *       </ul>
		 *     </il>
		 *     <li>
		 *       fnInit -  This function is called whenever the paging status of the table changes and is
		 *         typically used to update classes and/or text of the paging controls to reflex the new 
		 *         status.
		 *       <ul>
		 *         <li>
		 *           Function input parameters:
		 *           <ul>
		 *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *             <li>{function} Draw callback function - in case you need to redraw the table again
		 *               or attach new event listeners</li>
		 *           </ul>
		 *         </li>
		 *         <li>
		 *           Function return:
		 *           <ul>
		 *             <li>No return required</li>
		 *           </ul>
		 *         </il>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    $.fn.dataTableExt.oPagination.four_button = {
		 *      "fnInit": function ( oSettings, nPaging, fnCallbackDraw ) {
		 *        nFirst = document.createElement( 'span' );
		 *        nPrevious = document.createElement( 'span' );
		 *        nNext = document.createElement( 'span' );
		 *        nLast = document.createElement( 'span' );
		 *        
		 *        nFirst.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sFirst ) );
		 *        nPrevious.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sPrevious ) );
		 *        nNext.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sNext ) );
		 *        nLast.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sLast ) );
		 *        
		 *        nFirst.className = "paginate_button first";
		 *        nPrevious.className = "paginate_button previous";
		 *        nNext.className="paginate_button next";
		 *        nLast.className = "paginate_button last";
		 *        
		 *        nPaging.appendChild( nFirst );
		 *        nPaging.appendChild( nPrevious );
		 *        nPaging.appendChild( nNext );
		 *        nPaging.appendChild( nLast );
		 *        
		 *        $(nFirst).click( function () {
		 *          oSettings.oApi._fnPageChange( oSettings, "first" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nPrevious).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "previous" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nNext).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "next" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nLast).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "last" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nFirst).bind( 'selectstart', function () { return false; } );
		 *        $(nPrevious).bind( 'selectstart', function () { return false; } );
		 *        $(nNext).bind( 'selectstart', function () { return false; } );
		 *        $(nLast).bind( 'selectstart', function () { return false; } );
		 *      },
		 *      
		 *      "fnUpdate": function ( oSettings, fnCallbackDraw ) {
		 *        if ( !oSettings.aanFeatures.p ) {
		 *          return;
		 *        }
		 *        
		 *        // Loop over each instance of the pager
		 *        var an = oSettings.aanFeatures.p;
		 *        for ( var i=0, iLen=an.length ; i<iLen ; i++ ) {
		 *          var buttons = an[i].getElementsByTagName('span');
		 *          if ( oSettings._iDisplayStart === 0 ) {
		 *            buttons[0].className = "paginate_disabled_previous";
		 *            buttons[1].className = "paginate_disabled_previous";
		 *          }
		 *          else {
		 *            buttons[0].className = "paginate_enabled_previous";
		 *            buttons[1].className = "paginate_enabled_previous";
		 *          }
		 *          
		 *          if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) {
		 *            buttons[2].className = "paginate_disabled_next";
		 *            buttons[3].className = "paginate_disabled_next";
		 *          }
		 *          else {
		 *            buttons[2].className = "paginate_enabled_next";
		 *            buttons[3].className = "paginate_enabled_next";
		 *          }
		 *        }
		 *      }
		 *    };
		 */
		"oPagination": {},


		/**
		 * Sorting plug-in methods - Sorting in DataTables is based on the detected type of the
		 * data column (you can add your own type detection functions, or override automatic 
		 * detection using sType). With this specific type given to the column, DataTables will 
		 * apply the required sort from the functions in the object. Each sort type must provide
		 * two mandatory methods, one each for ascending and descending sorting, and can optionally
		 * provide a pre-formatting method that will help speed up sorting by allowing DataTables
		 * to pre-format the sort data only once (rather than every time the actual sort functions
		 * are run). The two sorting functions are typical Javascript sort methods:
		 *   <ul>
		 *     <li>
		 *       Function input parameters:
		 *       <ul>
		 *         <li>{*} Data to compare to the second parameter</li>
		 *         <li>{*} Data to compare to the first parameter</li>
		 *       </ul>
		 *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{int} Sorting match: <0 if first parameter should be sorted lower than
		 *           the second parameter, ===0 if the two parameters are equal and >0 if
		 *           the first parameter should be sorted height than the second parameter.</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Case-sensitive string sorting, with no pre-formatting method
		 *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-case-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-case-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
		 *
		 *  @example
		 *    // Case-insensitive string sorting, with pre-formatting
		 *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-pre": function(x) {
		 *        return x.toLowerCase();
		 *      },
		 *      "string-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
		 */
		"oSort": {},


		/**
		 * Version string for plug-ins to check compatibility. Allowed format is
		 * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
		 * e are optional
		 *  @type string
		 *  @default Version number
		 */
		"sVersion": DataTable.version,


		/**
		 * How should DataTables report an error. Can take the value 'alert' or 'throw'
		 *  @type string
		 *  @default alert
		 */
		"sErrMode": "alert",


		/**
		 * Store information for DataTables to access globally about other instances
		 *  @namespace
		 *  @private
		 */
		"_oExternConfig": {
			/* int:iNextUnique - next unique number for an instance */
			"iNextUnique": 0
		}
	};




	/**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
	DataTable.models.oSearch = {
		/**
		 * Flag to indicate if the filtering should be case insensitive or not
		 *  @type boolean
		 *  @default true
		 */
		"bCaseInsensitive": true,

		/**
		 * Applied search term
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sSearch": "",

		/**
		 * Flag to indicate if the search term should be interpreted as a
		 * regular expression (true) or not (false) and therefore and special
		 * regex characters escaped.
		 *  @type boolean
		 *  @default false
		 */
		"bRegex": false,

		/**
		 * Flag to indicate if DataTables is to use its smart filtering or not.
		 *  @type boolean
		 *  @default true
		 */
		"bSmart": true
	};




	/**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings 
	 * aoData array.
	 *  @namespace
	 */
	DataTable.models.oRow = {
		/**
		 * TR element for the row
		 *  @type node
		 *  @default null
		 */
		"nTr": null,

		/**
		 * Data object from the original data source for the row. This is either
		 * an array if using the traditional form of DataTables, or an object if
		 * using mData options. The exact type will depend on the passed in
		 * data from the data source, or will be an array if using DOM a data 
		 * source.
		 *  @type array|object
		 *  @default []
		 */
		"_aData": [],

		/**
		 * Sorting data cache - this array is ostensibly the same length as the
		 * number of columns (although each index is generated only as it is 
		 * needed), and holds the data that is used for sorting each column in the
		 * row. We do this cache generation at the start of the sort in order that
		 * the formatting of the sort data need be done only once for each cell
		 * per sort. This array should not be read from or written to by anything
		 * other than the master sorting methods.
		 *  @type array
		 *  @default []
		 *  @private
		 */
		"_aSortData": [],

		/**
		 * Array of TD elements that are cached for hidden rows, so they can be
		 * reinserted into the table if a column is made visible again (or to act
		 * as a store if a column is made hidden). Only hidden columns have a 
		 * reference in the array. For non-hidden columns the value is either
		 * undefined or null.
		 *  @type array nodes
		 *  @default []
		 *  @private
		 */
		"_anHidden": [],

		/**
		 * Cache of the class name that DataTables has applied to the row, so we
		 * can quickly look at this variable rather than needing to do a DOM check
		 * on className for the nTr property.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @private
		 */
		"_sRowStripe": ""
	};



	/**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 * 
	 * Note that this object is related to {@link DataTable.defaults.columns} 
	 * but this one is the internal data store for DataTables's cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
	DataTable.models.oColumn = {
		/**
		 * A list of the columns that sorting should occur on when this column
		 * is sorted. That this property is an array allows multi-column sorting
		 * to be defined for a column (for example first name / last name columns
		 * would benefit from this). The values are integers pointing to the
		 * columns to be sorted on (typically it will be a single integer pointing
		 * at itself, but that doesn't need to be the case).
		 *  @type array
		 */
		"aDataSort": null,

		/**
		 * Define the sorting directions that are applied to the column, in sequence
		 * as the column is repeatedly sorted upon - i.e. the first value is used
		 * as the sorting direction when the column if first sorted (clicked on).
		 * Sort it again (click again) and it will move on to the next index.
		 * Repeat until loop.
		 *  @type array
		 */
		"asSorting": null,

		/**
		 * Flag to indicate if the column is searchable, and thus should be included
		 * in the filtering or not.
		 *  @type boolean
		 */
		"bSearchable": null,

		/**
		 * Flag to indicate if the column is sortable or not.
		 *  @type boolean
		 */
		"bSortable": null,

		/**
		 * When using fnRender, you have two options for what to do with the data,
		 * and this property serves as the switch. Firstly, you can have the sorting
		 * and filtering use the rendered value (true - default), or you can have
		 * the sorting and filtering us the original value (false).
		 * 
		 * *NOTE* It is it is advisable now to use mData as a function and make 
		 * use of the 'type' that it gives, allowing (potentially) different data to
		 * be used for sorting, filtering, display and type detection.
		 *  @type boolean
		 *  @deprecated
		 */
		"bUseRendered": null,

		/**
		 * Flag to indicate if the column is currently visible in the table or not
		 *  @type boolean
		 */
		"bVisible": null,

		/**
		 * Flag to indicate to the type detection method if the automatic type
		 * detection should be used, or if a column type (sType) has been specified
		 *  @type boolean
		 *  @default true
		 *  @private
		 */
		"_bAutoType": true,

		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to fnRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available (since it is not when fnRender is called).
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @default null
		 */
		"fnCreatedCell": null,

		/**
		 * Function to get data from a cell in a column. You should <b>never</b>
		 * access data directly through _aData internally in DataTables - always use
		 * the method attached to this property. It allows mData to function as
		 * required. This function is automatically assigned by the column 
		 * initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array 
		 *    (i.e. aoData[]._aData)
		 *  @param {string} sSpecific The specific data type you want to get - 
		 *    'display', 'type' 'filter' 'sort'
		 *  @returns {*} The data for the cell from the given row's data
		 *  @default null
		 */
		"fnGetData": null,

		/**
		 * Custom display function that will be called for the display of each cell 
		 * in this column.
		 *  @type function
		 *  @param {object} o Object with the following parameters:
		 *  @param {int}    o.iDataRow The row in aoData
		 *  @param {int}    o.iDataColumn The column in question
		 *  @param {array}  o.aData The data for the row in question
		 *  @param {object} o.oSettings The settings object for this DataTables instance
		 *  @returns {string} The string you which to use in the display
		 *  @default null
		 */
		"fnRender": null,

		/**
		 * Function to set data for a cell in the column. You should <b>never</b> 
		 * set the data directly to _aData internally in DataTables - always use
		 * this method. It allows mData to function as required. This function
		 * is automatically assigned by the column initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array 
		 *    (i.e. aoData[]._aData)
		 *  @param {*} sValue Value to set
		 *  @default null
		 */
		"fnSetData": null,

		/**
		 * Property to read the value for the cells in the column from the data 
		 * source array / object. If null, then the default content is used, if a
		 * function is given then the return from the function is used.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mData": null,

		/**
		 * Partner property to mData which is used (only when defined) to get
		 * the data - i.e. it is basically the same as mData, but without the
		 * 'set' option, and also the data fed to it is the result from mData.
		 * This is the rendering method to match the data method of mData.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mRender": null,

		/**
		 * Unique header TH/TD element for this column - this is what the sorting
		 * listener is attached to (if sorting is enabled.)
		 *  @type node
		 *  @default null
		 */
		"nTh": null,

		/**
		 * Unique footer TH/TD element for this column (if there is one). Not used 
		 * in DataTables as such, but can be used for plug-ins to reference the 
		 * footer for each column.
		 *  @type node
		 *  @default null
		 */
		"nTf": null,

		/**
		 * The class to apply to all TD elements in the table's TBODY for the column
		 *  @type string
		 *  @default null
		 */
		"sClass": null,

		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer 
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 *  @type string
		 */
		"sContentPadding": null,

		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mData
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 */
		"sDefaultContent": null,

		/**
		 * Name for the column, allowing reference to the column by name as well as
		 * by index (needs a lookup to work by name).
		 *  @type string
		 */
		"sName": null,

		/**
		 * Custom sorting data type - defines which of the available plug-ins in
		 * afnSortData the custom sorting will use - if any is defined.
		 *  @type string
		 *  @default std
		 */
		"sSortDataType": 'std',

		/**
		 * Class to be applied to the header element when sorting on this column
		 *  @type string
		 *  @default null
		 */
		"sSortingClass": null,

		/**
		 * Class to be applied to the header element when sorting on this column -
		 * when jQuery UI theming is used.
		 *  @type string
		 *  @default null
		 */
		"sSortingClassJUI": null,

		/**
		 * Title of the column - what is seen in the TH element (nTh).
		 *  @type string
		 */
		"sTitle": null,

		/**
		 * Column sorting and filtering type
		 *  @type string
		 *  @default null
		 */
		"sType": null,

		/**
		 * Width of the column
		 *  @type string
		 *  @default null
		 */
		"sWidth": null,

		/**
		 * Width of the column when it was first "encountered"
		 *  @type string
		 *  @default null
		 */
		"sWidthOrig": null
	};



	/**
	 * Initialisation options that can be given to DataTables at initialisation 
	 * time.
	 *  @namespace
	 */
	DataTable.defaults = {
		/**
		 * An array of data to use for the table, passed in at initialisation which 
		 * will be used in preference to any data which is already in the DOM. This is
		 * particularly useful for constructing tables purely in Javascript, for
		 * example with a custom Ajax call.
		 *  @type array
		 *  @default null
		 *  @dtopt Option
		 * 
		 *  @example
		 *    // Using a 2D array data source
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine" },
		 *          { "sTitle": "Browser" },
		 *          { "sTitle": "Platform" },
		 *          { "sTitle": "Version" },
		 *          { "sTitle": "Grade" }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using an array of objects as a data source (mData)
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine",   "mData": "engine" },
		 *          { "sTitle": "Browser",  "mData": "browser" },
		 *          { "sTitle": "Platform", "mData": "platform" },
		 *          { "sTitle": "Version",  "mData": "version" },
		 *          { "sTitle": "Grade",    "mData": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"aaData": null,


		/**
		 * If sorting is enabled, then DataTables will perform a first pass sort on 
		 * initialisation. You can define which column(s) the sort is performed upon, 
		 * and the sorting direction, with this variable. The aaSorting array should 
		 * contain an array for each column to be sorted initially containing the 
		 * column's index and a direction string ('asc' or 'desc').
		 *  @type array
		 *  @default [[0,'asc']]
		 *  @dtopt Option
		 * 
		 *  @example
		 *    // Sort by 3rd column first, and then 4th column
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
		 *    
		 *    // No initial sorting
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": []
		 *      } );
		 *    } );
		 */
		"aaSorting": [[0, 'asc']],


		/**
		 * This parameter is basically identical to the aaSorting parameter, but 
		 * cannot be overridden by user interaction with the table. What this means 
		 * is that you could have a column (visible or hidden) which the sorting will 
		 * always be forced on first - any sorting after that (from the user) will 
		 * then be performed as required. This can be useful for grouping rows 
		 * together.
		 *  @type array
		 *  @default null
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSortingFixed": [[0,'asc']]
		 *      } );
		 *    } )
		 */
		"aaSortingFixed": null,


		/**
		 * This parameter allows you to readily specify the entries in the length drop
		 * down menu that DataTables shows when pagination is enabled. It can be 
		 * either a 1D array of options which will be used for both the displayed 
		 * option and the value, or a 2D array which will use the array in the first 
		 * position as the value, and the array in the second position as the 
		 * displayed options (useful for language strings such as 'All').
		 *  @type array
		 *  @default [ 10, 25, 50, 100 ]
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aLengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
		 *  
		 *  @example
		 *    // Setting the default display length as well as length menu
		 *    // This is likely to be wanted if you remove the '10' option which
		 *    // is the iDisplayLength default.
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 25,
		 *        "aLengthMenu": [[25, 50, 100, -1], [25, 50, 100, "All"]]
		 *      } );
		 *    } );
		 */
		"aLengthMenu": [10, 25, 50, 100],


		/**
		 * The aoColumns option in the initialisation parameter allows you to define
		 * details about the way individual columns behave. For a full list of
		 * column options that can be set, please see 
		 * {@link DataTable.defaults.columns}. Note that if you use aoColumns to
		 * define your columns, you must have an entry in the array for every single
		 * column that you have in your table (these can be null if you don't which
		 * to specify any options).
		 *  @member
		 */
		"aoColumns": null,

		/**
		 * Very similar to aoColumns, aoColumnDefs allows you to target a specific 
		 * column, multiple columns, or all columns, using the aTargets property of 
		 * each object in the array. This allows great flexibility when creating 
		 * tables, as the aoColumnDefs arrays can be of any length, targeting the 
		 * columns you specifically want. aoColumnDefs may use any of the column 
		 * options available: {@link DataTable.defaults.columns}, but it _must_
		 * have aTargets defined in each object in the array. Values in the aTargets
		 * array may be:
		 *   <ul>
		 *     <li>a string - class name will be matched on the TH for the column</li>
		 *     <li>0 or a positive integer - column index counting from the left</li>
		 *     <li>a negative integer - column index counting from the right</li>
		 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
		 *   </ul>
		 *  @member
		 */
		"aoColumnDefs": null,


		/**
		 * Basically the same as oSearch, this parameter defines the individual column
		 * filtering state at initialisation time. The array must be of the same size 
		 * as the number of columns, and each element be an object with the parameters
		 * "sSearch" and "bEscapeRegex" (the latter is optional). 'null' is also
		 * accepted and the default will be used.
		 *  @type array
		 *  @default []
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoSearchCols": [
		 *          null,
		 *          { "sSearch": "My filter" },
		 *          null,
		 *          { "sSearch": "^[0-9]", "bEscapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
		 */
		"aoSearchCols": [],


		/**
		 * An array of CSS classes that should be applied to displayed rows. This 
		 * array may be of any length, and DataTables will apply each class 
		 * sequentially, looping when required.
		 *  @type array
		 *  @default null <i>Will take the values determined by the oClasses.sStripe*
		 *    options</i>
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "asStripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
		 */
		"asStripeClasses": null,


		/**
		 * Enable or disable automatic column width calculation. This can be disabled
		 * as an optimisation (it takes some time to calculate the widths) if the
		 * tables widths are passed in using aoColumns.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bAutoWidth": false
		 *      } );
		 *    } );
		 */
		"bAutoWidth": true,


		/**
		 * Deferred rendering can provide DataTables with a huge speed boost when you
		 * are using an Ajax or JS data source for the table. This option, when set to
		 * true, will cause DataTables to defer the creation of the table elements for
		 * each row until they are needed for a draw - saving a significant amount of
		 * time.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/arrays.txt",
		 *        "bDeferRender": true
		 *      } );
		 *    } );
		 */
		"bDeferRender": false,


		/**
		 * Replace a DataTable which matches the given selector and replace it with 
		 * one which has the properties of the new initialisation object passed. If no
		 * table matches the selector, then the new DataTable will be constructed as
		 * per normal.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "bFilter": false,
		 *        "bDestroy": true
		 *      } );
		 *    } );
		 */
		"bDestroy": false,


		/**
		 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
		 * that it allows the end user to input multiple words (space separated) and
		 * will match a row containing those words, even if not in the order that was
		 * specified (this allow matching across multiple columns). Note that if you
		 * wish to use filtering in DataTables this must remain 'true' - to remove the
		 * default filtering input box and retain filtering abilities, please use
		 * {@link DataTable.defaults.sDom}.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bFilter": false
		 *      } );
		 *    } );
		 */
		"bFilter": true,


		/**
		 * Enable or disable the table information display. This shows information 
		 * about the data that is currently visible on the page, including information
		 * about filtered data if that action is being performed.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bInfo": false
		 *      } );
		 *    } );
		 */
		"bInfo": true,


		/**
		 * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
		 * slightly different and additional mark-up from what DataTables has
		 * traditionally used).
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bJQueryUI": true
		 *      } );
		 *    } );
		 */
		"bJQueryUI": false,


		/**
		 * Allows the end user to select the size of a formatted page from a select
		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (bPaginate).
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bLengthChange": false
		 *      } );
		 *    } );
		 */
		"bLengthChange": true,


		/**
		 * Enable or disable pagination.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bPaginate": false
		 *      } );
		 *    } );
		 */
		"bPaginate": true,


		/**
		 * Enable or disable the display of a 'processing' indicator when the table is
		 * being processed (e.g. a sort). This is particularly useful for tables with
		 * large amounts of data where it can take a noticeable amount of time to sort
		 * the entries.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true
		 *      } );
		 *    } );
		 */
		"bProcessing": false,


		/**
		 * Retrieve the DataTables object for the given selector. Note that if the
		 * table has already been initialised, this parameter will cause DataTables
		 * to simply return the object that has already been set up - it will not take
		 * account of any changes you might have made to the initialisation object
		 * passed to DataTables (setting this parameter to true is an acknowledgement
		 * that you understand this). bDestroy can be used to reinitialise a table if
		 * you need.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
		 *    
		 *    function initTable ()
		 *    {
		 *      return $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false,
		 *        "bRetrieve": true
		 *      } );
		 *    }
		 *    
		 *    function tableActions ()
		 *    {
		 *      var oTable = initTable();
		 *      // perform API operations with oTable 
		 *    }
		 */
		"bRetrieve": false,


		/**
		 * Indicate if DataTables should be allowed to set the padding / margin
		 * etc for the scrolling header elements or not. Typically you will want
		 * this.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollAutoCss": false,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
		 */
		"bScrollAutoCss": true,


		/**
		 * When vertical (y) scrolling is enabled, DataTables will force the height of
		 * the table's viewport to the given height at all times (useful for layout).
		 * However, this can look odd when filtering data down to a small data set,
		 * and the footer is left "floating" further down. This parameter (when
		 * enabled) will cause DataTables to collapse the table's viewport down when
		 * the result set will fit within the given Y height.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
		 */
		"bScrollCollapse": false,


		/**
		 * Enable infinite scrolling for DataTables (to be used in combination with
		 * sScrollY). Infinite scrolling means that DataTables will continually load
		 * data as a user scrolls through a table, which is very useful for large
		 * dataset. This cannot be used with pagination, which is automatically
		 * disabled. Note - the Scroller extra for DataTables is recommended in
		 * in preference to this option.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
		 */
		"bScrollInfinite": false,


		/**
		 * Configure DataTables to use server-side processing. Note that the
		 * sAjaxSource parameter must also be given in order to give DataTables a
		 * source to obtain the required data for each draw.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php"
		 *      } );
		 *    } );
		 */
		"bServerSide": false,


		/**
		 * Enable or disable sorting of columns. Sorting of individual columns can be
		 * disabled by the "bSortable" option for each column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSort": false
		 *      } );
		 *    } );
		 */
		"bSort": true,


		/**
		 * Allows control over whether DataTables should use the top (true) unique
		 * cell that is found for a single column, or the bottom (false - default).
		 * This is useful when using complex headers.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bSortCellsTop": true
		 *      } );
		 *    } );
		 */
		"bSortCellsTop": false,


		/**
		 * Enable or disable the addition of the classes 'sorting_1', 'sorting_2' and
		 * 'sorting_3' to the columns which are currently being sorted on. This is
		 * presented as a feature switch as it can increase processing time (while
		 * classes are removed and added) so for large data sets you might want to
		 * turn this off.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSortClasses": false
		 *      } );
		 *    } );
		 */
		"bSortClasses": true,


		/**
		 * Enable or disable state saving. When enabled a cookie will be used to save
		 * table display information such as pagination information, display length,
		 * filtering and sorting. As such when the end user reloads the page the
		 * display display will match what thy had previously set up.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true
		 *      } );
		 *    } );
		 */
		"bStateSave": false,


		/**
		 * Customise the cookie and / or the parameters being stored when using
		 * DataTables with state saving enabled. This function is called whenever
		 * the cookie is modified, and it expects a fully formed cookie string to be
		 * returned. Note that the data object passed in is a Javascript object which
		 * must be converted to a string (JSON.stringify for example).
		 *  @type function
		 *  @param {string} sName Name of the cookie defined by DataTables
		 *  @param {object} oData Data to be stored in the cookie
		 *  @param {string} sExpires Cookie expires string
		 *  @param {string} sPath Path of the cookie to set
		 *  @returns {string} Cookie formatted string (which should be encoded by
		 *    using encodeURIComponent())
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "fnCookieCallback": function (sName, oData, sExpires, sPath) {
		 *          // Customise oData or sName or whatever else here
		 *          return sName + "="+JSON.stringify(oData)+"; expires=" + sExpires +"; path=" + sPath;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCookieCallback": null,


		/**
		 * This function is called when a TR element is created (and all TD child
		 * elements have been inserted), or registered if using a DOM source, allowing
		 * manipulation of the TR element (adding classes etc).
		 *  @type function
		 *  @param {node} nRow "TR" element for the current row
		 *  @param {array} aData Raw data array for this row
		 *  @param {int} iDataIndex The index of this row in aoData
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnCreatedRow": function( nRow, aData, iDataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCreatedRow": null,


		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify any aspect you want about the created DOM.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnDrawCallback": function( oSettings ) {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnDrawCallback": null,


		/**
		 * Identical to fnHeaderCallback() but for the table footer this function
		 * allows you to modify the table footer on every 'draw' even.
		 *  @type function
		 *  @param {node} nFoot "TR" element for the footer
		 *  @param {array} aData Full table data (as derived from the original HTML)
		 *  @param {int} iStart Index for the current display starting point in the 
		 *    display array
		 *  @param {int} iEnd Index for the current display ending point in the 
		 *    display array
		 *  @param {array int} aiDisplay Index array to translate the visual position
		 *    to the full data array
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnFooterCallback": function( nFoot, aData, iStart, iEnd, aiDisplay ) {
		 *          nFoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+iStart;
		 *        }
		 *      } );
		 *    } )
		 */
		"fnFooterCallback": null,


		/**
		 * When rendering large numbers in the information element for the table
		 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
		 * to have a comma separator for the 'thousands' units (e.g. 1 million is
		 * rendered as "1,000,000") to help readability for the end user. This
		 * function will override the default method DataTables uses.
		 *  @type function
		 *  @member
		 *  @param {int} iIn number to be formatted
		 *  @returns {string} formatted string for DataTables to show the number
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnFormatNumber": function ( iIn ) {
		 *          if ( iIn &lt; 1000 ) {
		 *            return iIn;
		 *          } else {
		 *            var 
		 *              s=(iIn+""), 
		 *              a=s.split(""), out="", 
		 *              iLen=s.length;
		 *            
		 *            for ( var i=0 ; i&lt;iLen ; i++ ) {
		 *              if ( i%3 === 0 &amp;&amp; i !== 0 ) {
		 *                out = "'"+out;
		 *              }
		 *              out = a[iLen-i-1]+out;
		 *            }
		 *          }
		 *          return out;
		 *        };
		 *      } );
		 *    } );
		 */
		"fnFormatNumber": function (iIn) {
			if (iIn < 1000) {
				// A small optimisation for what is likely to be the majority of use cases
				return iIn;
			}

			var s = (iIn + ""), a = s.split(""), out = "", iLen = s.length;

			for (var i = 0; i < iLen; i++) {
				if (i % 3 === 0 && i !== 0) {
					out = this.oLanguage.sInfoThousands + out;
				}
				out = a[iLen - i - 1] + out;
			}
			return out;
		},


		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify the header row. This can be used to calculate and
		 * display useful information about the table.
		 *  @type function
		 *  @param {node} nHead "TR" element for the header
		 *  @param {array} aData Full table data (as derived from the original HTML)
		 *  @param {int} iStart Index for the current display starting point in the
		 *    display array
		 *  @param {int} iEnd Index for the current display ending point in the
		 *    display array
		 *  @param {array int} aiDisplay Index array to translate the visual position
		 *    to the full data array
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnHeaderCallback": function( nHead, aData, iStart, iEnd, aiDisplay ) {
		 *          nHead.getElementsByTagName('th')[0].innerHTML = "Displaying "+(iEnd-iStart)+" records";
		 *        }
		 *      } );
		 *    } )
		 */
		"fnHeaderCallback": null,


		/**
		 * The information element can be used to convey information about the current
		 * state of the table. Although the internationalisation options presented by
		 * DataTables are quite capable of dealing with most customisations, there may
		 * be times where you wish to customise the string further. This callback
		 * allows you to do exactly that.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {int} iStart Starting position in data for the draw
		 *  @param {int} iEnd End position in data for the draw
		 *  @param {int} iMax Total number of rows in the table (regardless of
		 *    filtering)
		 *  @param {int} iTotal Total number of rows in the data set, after filtering
		 *  @param {string} sPre The string that DataTables has formatted using it's
		 *    own rules
		 *  @returns {string} The string to be displayed in the information element.
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $('#example').dataTable( {
		 *      "fnInfoCallback": function( oSettings, iStart, iEnd, iMax, iTotal, sPre ) {
		 *        return iStart +" to "+ iEnd;
		 *      }
		 *    } );
		 */
		"fnInfoCallback": null,


		/**
		 * Called when the table has been initialised. Normally DataTables will
		 * initialise sequentially and there will be no need for this function,
		 * however, this does not hold true when using external language information
		 * since that is obtained using an async XHR call.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnInitComplete": function(oSettings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
		 */
		"fnInitComplete": null,


		/**
		 * Called at the very start of each table draw and can be used to cancel the
		 * draw by returning false, any other return (including undefined) results in
		 * the full draw occurring).
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @returns {boolean} False will cancel the draw, anything else (including no
		 *    return) will allow it to complete.
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnPreDrawCallback": function( oSettings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnPreDrawCallback": null,


		/**
		 * This function allows you to 'post process' each row after it have been
		 * generated for each table draw, but before it is rendered on screen. This
		 * function might be used for setting the row class name etc.
		 *  @type function
		 *  @param {node} nRow "TR" element for the current row
		 *  @param {array} aData Raw data array for this row
		 *  @param {int} iDisplayIndex The display index for the current table draw
		 *  @param {int} iDisplayIndexFull The index of the data in the full list of
		 *    rows (after filtering)
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnRowCallback": function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnRowCallback": null,


		/**
		 * This parameter allows you to override the default function which obtains
		 * the data from the server ($.getJSON) so something more suitable for your
		 * application. For example you could use POST data, or pull information from
		 * a Gears or AIR database.
		 *  @type function
		 *  @member
		 *  @param {string} sSource HTTP source to obtain the data from (sAjaxSource)
		 *  @param {array} aoData A key/value pair object containing the data to send
		 *    to the server
		 *  @param {function} fnCallback to be called on completion of the data get
		 *    process that will draw the data on the page.
		 *  @param {object} oSettings DataTables settings object
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    // POST data to server
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php",
		 *        "fnServerData": function ( sSource, aoData, fnCallback, oSettings ) {
		 *          oSettings.jqXHR = $.ajax( {
		 *            "dataType": 'json', 
		 *            "type": "POST", 
		 *            "url": sSource, 
		 *            "data": aoData, 
		 *            "success": fnCallback
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnServerData": function (sUrl, aoData, fnCallback, oSettings) {
			oSettings.jqXHR = $.ajax({
				"url": sUrl,
				"data": aoData,
				"success": function (json) {
					if (json.sError) {
						oSettings.oApi._fnLog(oSettings, 0, json.sError);
					}

					$(oSettings.oInstance).trigger('xhr', [oSettings, json]);
					fnCallback(json);
				},
				"dataType": "json",
				"cache": false,
				"type": oSettings.sServerMethod,
				"error": function (xhr, error, thrown) {
					if (error == "parsererror") {
						oSettings.oApi._fnLog(oSettings, 0, "DataTables warning: JSON data from " +
							"server could not be parsed. This is caused by a JSON formatting error.");
					}
				}
			});
		},


		/**
		 * It is often useful to send extra data to the server when making an Ajax
		 * request - for example custom filtering information, and this callback
		 * function makes it trivial to send extra information to the server. The
		 * passed in parameter is the data set that has been constructed by
		 * DataTables, and you can add to this or modify it as you require.
		 *  @type function
		 *  @param {array} aoData Data array (array of objects which are name/value
		 *    pairs) that has been constructed by DataTables and will be sent to the
		 *    server. In the case of Ajax sourced data with server-side processing
		 *    this will be an empty array, for server-side processing there will be a
		 *    significant number of parameters!
		 *  @returns {undefined} Ensure that you modify the aoData array passed in,
		 *    as this is passed by reference.
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "fnServerParams": function ( aoData ) {
		 *          aoData.push( { "name": "more_data", "value": "my_value" } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnServerParams": null,


		/**
		 * Load the table state. With this function you can define from where, and how, the
		 * state of a table is loaded. By default DataTables will load from its state saving
		 * cookie, but you might wish to use local storage (HTML5) or a server-side database.
		 *  @type function
		 *  @member
		 *  @param {object} oSettings DataTables settings object
		 *  @return {object} The DataTables state object to be loaded
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoad": function (oSettings) {
		 *          var o;
		 *          
		 *          // Send an Ajax request to the server to get the data. Note that
		 *          // this is a synchronous request.
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "async": false,
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              o = json;
		 *            }
		 *          } );
		 *          
		 *          return o;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoad": function (oSettings) {
			var sData = this.oApi._fnReadCookie(oSettings.sCookiePrefix + oSettings.sInstance);
			var oData;

			try {
				oData = (typeof $.parseJSON === 'function') ?
					$.parseJSON(sData) : eval('(' + sData + ')');
			} catch (e) {
				oData = null;
			}

			return oData;
		},


		/**
		 * Callback which allows modification of the saved state prior to loading that state.
		 * This callback is called when the table is loading state from the stored data, but
		 * prior to the settings object being modified by the saved state. Note that for 
		 * plug-in authors, you should use the 'stateLoadParams' event to load parameters for 
		 * a plug-in.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object that is to be loaded
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    // Remove a saved filter, so filtering is never loaded
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          oData.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 * 
		 *  @example
		 *    // Disallow state loading by returning false
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadParams": null,


		/**
		 * Callback that is called when the state has been loaded from the state saving method
		 * and the DataTables settings object has been modified as a result of the loaded state.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object that was loaded
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    // Show an alert with the filtering value that was saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoaded": function (oSettings, oData) {
		 *          alert( 'Saved filter was: '+oData.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoaded": null,


		/**
		 * Save the table state. This function allows you to define where and how the state
		 * information for the table is stored - by default it will use a cookie, but you
		 * might want to use local storage (HTML5) or a server-side database.
		 *  @type function
		 *  @member
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object to be saved
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSave": function (oSettings, oData) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": oData,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSave": function (oSettings, oData) {
			this.oApi._fnCreateCookie(
				oSettings.sCookiePrefix + oSettings.sInstance,
				this.oApi._fnJsonString(oData),
				oSettings.iCookieDuration,
				oSettings.sCookiePrefix,
				oSettings.fnCookieCallback
			);
		},


		/**
		 * Callback which allows modification of the state to be saved. Called when the table 
		 * has changed state a new state save is required. This method allows modification of
		 * the state saving object prior to actually doing the save, including addition or 
		 * other state properties or modification. Note that for plug-in authors, you should 
		 * use the 'stateSaveParams' event to save parameters for a plug-in.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object to be saved
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    // Remove a saved filter, so filtering is never saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSaveParams": function (oSettings, oData) {
		 *          oData.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveParams": null,


		/**
		 * Duration of the cookie which is used for storing session information. This
		 * value is given in seconds.
		 *  @type int
		 *  @default 7200 <i>(2 hours)</i>
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iCookieDuration": 60*60*24; // 1 day
		 *      } );
		 *    } )
		 */
		"iCookieDuration": 7200,


		/**
		 * When enabled DataTables will not make a request to the server for the first
		 * page draw - rather it will use the data already on the page (no sorting etc
		 * will be applied to it), thus saving on an XHR at load time. iDeferLoading
		 * is used to indicate that deferred loading is required, but it is also used
		 * to tell DataTables how many records there are in the full table (allowing
		 * the information element and pagination to be displayed correctly). In the case
		 * where a filtering is applied to the table on initial load, this can be
		 * indicated by giving the parameter as an array, where the first element is
		 * the number of records available after filtering and the second element is the
		 * number of records without filtering (allowing the table information element
		 * to be shown correctly).
		 *  @type int | array
		 *  @default null
		 *  @dtopt Options
		 * 
		 *  @example
		 *    // 57 records available in the table, no filtering applied
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "iDeferLoading": 57
		 *      } );
		 *    } );
		 * 
		 *  @example
		 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "iDeferLoading": [ 57, 100 ],
		 *        "oSearch": {
		 *          "sSearch": "my_filter"
		 *        }
		 *      } );
		 *    } );
		 */
		"iDeferLoading": null,


		/**
		 * Number of rows to display on a single page when using pagination. If
		 * feature enabled (bLengthChange) then the end user will be able to override
		 * this to a custom setting using a pop-up menu.
		 *  @type int
		 *  @default 10
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 50
		 *      } );
		 *    } )
		 */
		"iDisplayLength": 10,


		/**
		 * Define the starting point for data display when using DataTables with
		 * pagination. Note that this parameter is the number of records, rather than
		 * the page number, so if you have 10 records per page and want to start on
		 * the third page, it should be "20".
		 *  @type int
		 *  @default 0
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayStart": 20
		 *      } );
		 *    } )
		 */
		"iDisplayStart": 0,


		/**
		 * The scroll gap is the amount of scrolling that is left to go before
		 * DataTables will load the next 'page' of data automatically. You typically
		 * want a gap which is big enough that the scrolling will be smooth for the
		 * user, while not so large that it will load more data than need.
		 *  @type int
		 *  @default 100
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px",
		 *        "iScrollLoadGap": 50
		 *      } );
		 *    } );
		 */
		"iScrollLoadGap": 100,


		/**
		 * By default DataTables allows keyboard navigation of the table (sorting, paging,
		 * and filtering) by adding a tabindex attribute to the required elements. This
		 * allows you to tab through the controls and press the enter key to activate them.
		 * The tabindex is default 0, meaning that the tab follows the flow of the document.
		 * You can overrule this using this parameter if you wish. Use a value of -1 to
		 * disable built-in keyboard navigation.
		 *  @type int
		 *  @default 0
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iTabIndex": 1
		 *      } );
		 *    } );
		 */
		"iTabIndex": 0,


		/**
		 * All strings that DataTables uses in the user interface that it creates
		 * are defined in this object, allowing you to modified them individually or
		 * completely replace them all as required.
		 *  @namespace
		 */
		"oLanguage": {
			/**
			 * Strings that are used for WAI-ARIA labels and controls only (these are not
			 * actually visible on the page, but will be read by screenreaders, and thus
			 * must be internationalised as well).
			 *  @namespace
			 */
			"oAria": {
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted ascending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortAscending": ": activate to sort column ascending",

				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted descending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortDescending": ": activate to sort column descending"
			},

			/**
			 * Pagination string used by DataTables for the two built-in pagination
			 * control types ("two_button" and "full_numbers")
			 *  @namespace
			 */
			"oPaginate": {
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the first page.
				 *  @type string
				 *  @default First
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sFirst": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sFirst": "First",


				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the last page.
				 *  @type string
				 *  @default Last
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sLast": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sLast": "Last",


				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the next page.
				 *  @type string
				 *  @default Next
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sNext": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sNext": "Next",


				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the previous page.
				 *  @type string
				 *  @default Previous
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sPrevious": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sPrevious": "Previous"
			},

			/**
			 * This string is shown in preference to sZeroRecords when the table is
			 * empty of data (regardless of filtering). Note that this is an optional
			 * parameter - if it is not given, the value of sZeroRecords will be used
			 * instead (either the default or given value).
			 *  @type string
			 *  @default No data available in table
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sEmptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sEmptyTable": "No data available in table",


			/**
			 * This string gives information to the end user about the information that 
			 * is current on display on the page. The _START_, _END_ and _TOTAL_ 
			 * variables are all dynamically replaced as the table display updates, and 
			 * can be freely moved or removed as the language requirements change.
			 *  @type string
			 *  @default Showing _START_ to _END_ of _TOTAL_ entries
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfo": "Got a total of _TOTAL_ entries to show (_START_ to _END_)"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


			/**
			 * Display information string for when the table is empty. Typically the 
			 * format of this string should match sInfo.
			 *  @type string
			 *  @default Showing 0 to 0 of 0 entries
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoEmpty": "Showing 0 to 0 of 0 entries",


			/**
			 * When a user filters the information in a table, this string is appended 
			 * to the information (sInfo) to give an idea of how strong the filtering 
			 * is. The variable _MAX_ is dynamically updated.
			 *  @type string
			 *  @default (filtered from _MAX_ total entries)
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoFiltered": "(filtered from _MAX_ total entries)",


			/**
			 * If can be useful to append extra information to the info string at times,
			 * and this variable does exactly that. This information will be appended to
			 * the sInfo (sInfoEmpty and sInfoFiltered in whatever combination they are
			 * being used) at all times.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoPostFix": "",


			/**
			 * DataTables has a build in number formatter (fnFormatNumber) which is used
			 * to format large numbers that are used in the table information. By
			 * default a comma is used, but this can be trivially changed to any
			 * character you wish with this parameter.
			 *  @type string
			 *  @default ,
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoThousands": "'"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoThousands": ",",


			/**
			 * Detail the action that will be taken when the drop down menu for the
			 * pagination length option is changed. The '_MENU_' variable is replaced
			 * with a default select list of 10, 25, 50 and 100, and can be replaced
			 * with a custom select box if required.
			 *  @type string
			 *  @default Show _MENU_ entries
			 *  @dtopt Language
			 * 
			 *  @example
			 *    // Language change only
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
			 *    
			 *  @example
			 *    // Language and options change
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
			 */
			"sLengthMenu": "Show _MENU_ entries",


			/**
			 * When using Ajax sourced data and during the first draw when DataTables is
			 * gathering the data, this message is shown in an empty row in the table to
			 * indicate to the end user the the data is being loaded. Note that this
			 * parameter is not used when loading data by server-side processing, just
			 * Ajax sourced data with client-side processing.
			 *  @type string
			 *  @default Loading...
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLoadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
			 */
			"sLoadingRecords": "Loading...",


			/**
			 * Text which is displayed when the table is processing a user action
			 * (usually a sort command or similar).
			 *  @type string
			 *  @default Processing...
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sProcessing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
			 */
			"sProcessing": "Processing...",


			/**
			 * Details the actions that will be taken when the user types into the
			 * filtering input text box. The variable "_INPUT_", if used in the string,
			 * is replaced with the HTML text box for the filtering input allowing
			 * control over where it appears in the string. If "_INPUT_" is not given
			 * then the input box is appended to the string automatically.
			 *  @type string
			 *  @default Search:
			 *  @dtopt Language
			 * 
			 *  @example
			 *    // Input text box will be appended at the end automatically
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Filter records:"
			 *        }
			 *      } );
			 *    } );
			 *    
			 *  @example
			 *    // Specify where the filter should appear
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sSearch": '<span class="label label-info" style="font-size:14px;">簡易検索：</span>',


			/**
			 * All of the language information can be stored in a file on the
			 * server-side, which DataTables will look up if this parameter is passed.
			 * It must store the URL of the language file, which is in a JSON format,
			 * and the object has the same properties as the oLanguage object in the
			 * initialiser object (i.e. the above parameters). Please refer to one of
			 * the example language files to see how this works in action.
			 *  @type string
			 *  @default <i>Empty string - i.e. disabled</i>
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sUrl": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
			 */
			"sUrl": "",


			/**
			 * Text shown inside the table records when the is no information to be
			 * displayed after filtering. sEmptyTable is shown when there is simply no
			 * information in the table at all (regardless of filtering).
			 *  @type string
			 *  @default No matching records found
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sZeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
			 */
			"sZeroRecords": "No matching records found"
		},


		/**
		 * This parameter allows you to have define the global filtering state at
		 * initialisation time. As an object the "sSearch" parameter must be
		 * defined, but all other parameters are optional. When "bRegex" is true,
		 * the search string will be treated as a regular expression, when false
		 * (default) it will be treated as a straight string. When "bSmart"
		 * DataTables will use it's smart filtering methods (to word match at
		 * any point in the data), when false this will not be done.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "oSearch": {"sSearch": "Initial search"}
		 *      } );
		 *    } )
		 */
		"oSearch": $.extend({}, DataTable.models.oSearch),


		/**
		 * By default DataTables will look for the property 'aaData' when obtaining
		 * data from an Ajax source or for server-side processing - this parameter
		 * allows that property to be changed. You can use Javascript dotted object
		 * notation to get a data source for multiple levels of nesting.
		 *  @type string
		 *  @default aaData
		 *  @dtopt Options
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    // Get data from { "data": [...] }
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data"
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Get data from { "data": { "inner": [...] } }
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data.inner"
		 *      } );
		 *    } );
		 */
		"sAjaxDataProp": "aaData",


		/**
		 * You can instruct DataTables to load data from an external source using this
		 * parameter (use aData if you want to pass data in you already have). Simply
		 * provide a url a JSON object can be obtained from. This object must include
		 * the parameter 'aaData' which is the data source for the table.
		 *  @type string
		 *  @default null
		 *  @dtopt Options
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sAjaxSource": "http://www.sprymedia.co.uk/dataTables/json.php"
		 *      } );
		 *    } )
		 */
		"sAjaxSource": null,


		/**
		 * This parameter can be used to override the default prefix that DataTables
		 * assigns to a cookie when state saving is enabled.
		 *  @type string
		 *  @default SpryMedia_DataTables_
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sCookiePrefix": "my_datatable_",
		 *      } );
		 *    } );
		 */
		"sCookiePrefix": "SpryMedia_DataTables_",


		/**
		 * This initialisation variable allows you to specify exactly where in the
		 * DOM you want DataTables to inject the various controls it adds to the page
		 * (for example you might want the pagination controls at the top of the
		 * table). DIV elements (with or without a custom class) can also be added to
		 * aid styling. The follow syntax is used:
		 *   <ul>
		 *     <li>The following options are allowed:	
		 *       <ul>
		 *         <li>'l' - Length changing</li
		 *         <li>'f' - Filtering input</li>
		 *         <li>'t' - The table!</li>
		 *         <li>'i' - Information</li>
		 *         <li>'p' - Pagination</li>
		 *         <li>'r' - pRocessing</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following constants are allowed:
		 *       <ul>
		 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
		 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following syntax is expected:
		 *       <ul>
		 *         <li>'&lt;' and '&gt;' - div elements</li>
		 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
		 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
		 *       </ul>
		 *     </li>
		 *     <li>Examples:
		 *       <ul>
		 *         <li>'&lt;"wrapper"flipt&gt;'</li>
		 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
		 *       </ul>
		 *     </li>
		 *   </ul>
		 *  @type string
		 *  @default lfrtip <i>(when bJQueryUI is false)</i> <b>or</b> 
		 *    <"H"lfr>t<"F"ip> <i>(when bJQueryUI is true)</i>
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sDom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
		 *      } );
		 *    } );
		 */
		"sDom": "lfrtip",


		/**
		 * DataTables features two different built-in pagination interaction methods
		 * ('two_button' or 'full_numbers') which present different page controls to
		 * the end user. Further methods can be added using the API (see below).
		 *  @type string
		 *  @default two_button
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sPaginationType": "full_numbers"
		 *      } );
		 *    } )
		 */
		"sPaginationType": "two_button",


		/**
		 * Enable horizontal scrolling. When a table is too wide to fit into a certain
		 * layout, or you have a large number of columns in the table, you can enable
		 * x-scrolling to show the table in a viewport, which can be scrolled. This
		 * property can be any CSS unit, or a number (in which case it will be treated
		 * as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
		 */
		"sScrollX": "",


		/**
		 * This property can be used to force a DataTable to use more width than it
		 * might otherwise do when x-scrolling is enabled. For example if you have a
		 * table which requires to be well spaced, this parameter is useful for
		 * "over-sizing" the table, and thus forcing scrolling. This property can by
		 * any CSS unit, or a number (in which case it will be treated as a pixel
		 * measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "sScrollXInner": "110%"
		 *      } );
		 *    } );
		 */
		"sScrollXInner": "",


		/**
		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
		 * to the given height, and enable scrolling for any data which overflows the
		 * current viewport. This can be used as an alternative to paging to display
		 * a lot of data in a small area (although paging and scrolling can both be
		 * enabled at the same time). This property can be any CSS unit, or a number
		 * (in which case it will be treated as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *    } );
		 */
		"sScrollY": "",


		/**
		 * Set the HTTP method that is used to make the Ajax call for server-side
		 * processing or Ajax sourced data.
		 *  @type string
		 *  @default GET
		 *  @dtopt Options
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/post.php",
		 *        "sServerMethod": "POST"
		 *      } );
		 *    } );
		 */
		"sServerMethod": "GET"
	};



	/**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
	DataTable.defaults.columns = {
		/**
		 * Allows a column's sorting to take multiple columns into account when 
		 * doing a sort. For example first name / last name columns make sense to 
		 * do a multi-column sort over the two columns.
		 *  @type array
		 *  @default null <i>Takes the value of the column index automatically</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "aDataSort": [ 0, 1 ], "aTargets": [ 0 ] },
		 *          { "aDataSort": [ 1, 0 ], "aTargets": [ 1 ] },
		 *          { "aDataSort": [ 2, 3, 4 ], "aTargets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          { "aDataSort": [ 0, 1 ] },
		 *          { "aDataSort": [ 1, 0 ] },
		 *          { "aDataSort": [ 2, 3, 4 ] },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"aDataSort": null,


		/**
		 * You can control the default sorting direction, and even alter the behaviour
		 * of the sort handler (i.e. only allow ascending sorting etc) using this
		 * parameter.
		 *  @type array
		 *  @default [ 'asc', 'desc' ]
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "asSorting": [ "asc" ], "aTargets": [ 1 ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ], "aTargets": [ 2 ] },
		 *          { "asSorting": [ "desc" ], "aTargets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          { "asSorting": [ "asc" ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ] },
		 *          { "asSorting": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"asSorting": ['asc', 'desc'],


		/**
		 * Enable or disable filtering on the data in this column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSearchable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSearchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSearchable": true,


		/**
		 * Enable or disable sorting on this column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSortable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSortable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSortable": true,


		/**
		 * When using fnRender() for a column, you may wish to use the original data
		 * (before rendering) for sorting and filtering (the default is to used the
		 * rendered data that the user can see). This may be useful for dates etc.
		 * 
		 * *NOTE* This property is now deprecated, and it is suggested that you use
		 * mData and / or mRender to render data for the DataTable.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 *  @deprecated
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "fnRender": function ( oObj ) {
		 *              return oObj.aData[0] +' '+ oObj.aData[3];
		 *            },
		 *            "bUseRendered": false,
		 *            "aTargets": [ 0 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          {
		 *            "fnRender": function ( oObj ) {
		 *              return oObj.aData[0] +' '+ oObj.aData[3];
		 *            },
		 *            "bUseRendered": false
		 *          },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"bUseRendered": true,


		/**
		 * Enable or disable the display of this column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bVisible": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bVisible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bVisible": true,


		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to fnRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available (since it is not when fnRender is called).
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @param {int} iCol The column index for aoColumns
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [3],
		 *          "fnCreatedCell": function (nTd, sData, oData, iRow, iCol) {
		 *            if ( sData == "1.7" ) {
		 *              $(nTd).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
		 */
		"fnCreatedCell": null,


		/**
		 * Custom display function that will be called for the display of each cell in
		 * this column.
		 *  @type function
		 *  @param {object} o Object with the following parameters:
		 *  @param {int}    o.iDataRow The row in aoData
		 *  @param {int}    o.iDataColumn The column in question
		 *  @param {array}  o.aData The data for the row in question
		 *  @param {object} o.oSettings The settings object for this DataTables instance
		 *  @param {object} o.mDataProp The data property used for this column
		 *  @param {*}      val The current cell value
		 *  @returns {string} The string you which to use in the display
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "fnRender": function ( o, val ) {
		 *              return o.aData[0] +' '+ o.aData[3];
		 *            },
		 *            "aTargets": [ 0 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "fnRender": function ( o, val ) {
		 *            return o.aData[0] +' '+ o.aData[3];
		 *          } },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"fnRender": null,


		/**
		 * The column index (starting from 0!) that you wish a sort to be performed
		 * upon when this column is selected for sorting. This can be used for sorting
		 * on hidden columns for example.
		 *  @type int
		 *  @default -1 <i>Use automatically calculated column index</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "iDataSort": 1, "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "iDataSort": 1 },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"iDataSort": -1,


		/**
		 * This parameter has been replaced by mData in DataTables to ensure naming
		 * consistency. mDataProp can still be used, as there is backwards compatibility
		 * in DataTables for this option, but it is strongly recommended that you use
		 * mData in preference to mDataProp.
		 *  @name DataTable.defaults.columns.mDataProp
		 */


		/**
		 * This property can be used to read data from any JSON data source property,
		 * including deeply nested objects / properties. mData can be given in a
		 * number of different ways which effect its behaviour:
		 *   <ul>
		 *     <li>integer - treated as an array index for the data source. This is the
		 *       default that DataTables uses (incrementally increased for each column).</li>
		 *     <li>string - read an object property from the data source. Note that you can
		 *       use Javascript dotted notation to read deep properties / arrays from the
		 *       data source.</li>
		 *     <li>null - the sDefaultContent option will be used for the cell (null
		 *       by default, so you will need to specify the default content you want -
		 *       typically an empty string). This can be useful on generated columns such 
		 *       as edit / delete action columns.</li>
		 *     <li>function - the function given will be executed whenever DataTables 
		 *       needs to set or get the data for a cell in the column. The function 
		 *       takes three parameters:
		 *       <ul>
		 *         <li>{array|object} The data source for the row</li>
		 *         <li>{string} The type call data requested - this will be 'set' when
		 *           setting data or 'filter', 'display', 'type', 'sort' or undefined when 
		 *           gathering data. Note that when <i>undefined</i> is given for the type
		 *           DataTables expects to get the raw data for the object back</li>
		 *         <li>{*} Data to set when the second parameter is 'set'.</li>
		 *       </ul>
		 *       The return value from the function is not required when 'set' is the type
		 *       of call, but otherwise the return is what will be used for the data
		 *       requested.</li>
		 *    </ul>
		 *
		 * Note that prior to DataTables 1.9.2 mData was called mDataProp. The name change
		 * reflects the flexibility of this property and is consistent with the naming of
		 * mRender. If 'mDataProp' is given, then it will still be used by DataTables, as
		 * it automatically maps the old name to the new if required.
		 *  @type string|int|function|null
		 *  @default null <i>Use automatically calculated column index</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Read table data from objects
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/deep.txt",
		 *        "aoColumns": [
		 *          { "mData": "engine" },
		 *          { "mData": "browser" },
		 *          { "mData": "platform.inner" },
		 *          { "mData": "platform.details.0" },
		 *          { "mData": "platform.details.1" }
		 *        ]
		 *      } );
		 *    } );
		 * 
		 *  @example
		 *    // Using mData as a function to provide different information for
		 *    // sorting, filtering and display. In this case, currency (price)
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [ 0 ],
		 *          "mData": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed dislay and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort', 'type' and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 */
		"mData": null,


		/**
		 * This property is the rendering partner to mData and it is suggested that
		 * when you want to manipulate data for display (including filtering, sorting etc)
		 * but not altering the underlying data for the table, use this property. mData
		 * can actually do everything this property can and more, but this parameter is
		 * easier to use since there is no 'set' option. Like mData is can be given
		 * in a number of different ways to effect its behaviour, with the addition of 
		 * supporting array syntax for easy outputting of arrays (including arrays of
		 * objects):
		 *   <ul>
		 *     <li>integer - treated as an array index for the data source. This is the
		 *       default that DataTables uses (incrementally increased for each column).</li>
		 *     <li>string - read an object property from the data source. Note that you can
		 *       use Javascript dotted notation to read deep properties / arrays from the
		 *       data source and also array brackets to indicate that the data reader should
		 *       loop over the data source array. When characters are given between the array
		 *       brackets, these characters are used to join the data source array together.
		 *       For example: "accounts[, ].name" would result in a comma separated list with
		 *       the 'name' value from the 'accounts' array of objects.</li>
		 *     <li>function - the function given will be executed whenever DataTables 
		 *       needs to set or get the data for a cell in the column. The function 
		 *       takes three parameters:
		 *       <ul>
		 *         <li>{array|object} The data source for the row (based on mData)</li>
		 *         <li>{string} The type call data requested - this will be 'filter', 'display', 
		 *           'type' or 'sort'.</li>
		 *         <li>{array|object} The full data source for the row (not based on mData)</li>
		 *       </ul>
		 *       The return value from the function is what will be used for the data
		 *       requested.</li>
		 *    </ul>
		 *  @type string|int|function|null
		 *  @default null <i>Use mData</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Create a comma separated list from an array of objects
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/deep.txt",
		 *        "aoColumns": [
		 *          { "mData": "engine" },
		 *          { "mData": "browser" },
		 *          {
		 *            "mData": "platform",
		 *            "mRender": "[, ].name"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 * 
		 *  @example
		 *    // Use as a function to create a link from the data source
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *        {
		 *          "aTargets": [ 0 ],
		 *          "mData": "download_link",
		 *          "mRender": function ( data, type, full ) {
		 *            return '<a href="'+data+'">Download</a>';
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"mRender": null,


		/**
		 * Change the cell type created for the column - either TD cells or TH cells. This
		 * can be useful as TH cells have semantic meaning in the table body, allowing them
		 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
		 *  @type string
		 *  @default td
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Make the first column use TH cells
		 *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [ 0 ],
		 *          "sCellType": "th"
		 *        } ]
		 *      } );
		 *    } );
		 */
		"sCellType": "td",


		/**
		 * Class to give to each cell in this column.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sClass": "my_class", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sClass": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sClass": "",

		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer 
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 * Generally you shouldn't need this, and it is not documented on the 
		 * general DataTables.net documentation
		 *  @type string
		 *  @default <i>Empty string<i>
		 *  @dtopt Columns
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "sContentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sContentPadding": "",


		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mData
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "mData": null,
		 *            "sDefaultContent": "Edit",
		 *            "aTargets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "mData": null,
		 *            "sDefaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sDefaultContent": null,


		/**
		 * This parameter is only used in DataTables' server-side processing. It can
		 * be exceptionally useful to know what columns are being displayed on the
		 * client side, and to map these to database fields. When defined, the names
		 * also allow DataTables to reorder information from the server if it comes
		 * back in an unexpected order (i.e. if you switch your columns around on the
		 * client-side, your server-side code does not also need updating).
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sName": "engine", "aTargets": [ 0 ] },
		 *          { "sName": "browser", "aTargets": [ 1 ] },
		 *          { "sName": "platform", "aTargets": [ 2 ] },
		 *          { "sName": "version", "aTargets": [ 3 ] },
		 *          { "sName": "grade", "aTargets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sName": "engine" },
		 *          { "sName": "browser" },
		 *          { "sName": "platform" },
		 *          { "sName": "version" },
		 *          { "sName": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sName": "",


		/**
		 * Defines a data source type for the sorting which can be used to read
		 * real-time information from the table (updating the internally cached
		 * version) prior to sorting. This allows sorting to occur on user editable
		 * elements such as form inputs.
		 *  @type string
		 *  @default std
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "sSortDataType": "dom-text", "aTargets": [ 2, 3 ] },
		 *          { "sType": "numeric", "aTargets": [ 3 ] },
		 *          { "sSortDataType": "dom-select", "aTargets": [ 4 ] },
		 *          { "sSortDataType": "dom-checkbox", "aTargets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          null,
		 *          { "sSortDataType": "dom-text" },
		 *          { "sSortDataType": "dom-text", "sType": "numeric" },
		 *          { "sSortDataType": "dom-select" },
		 *          { "sSortDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sSortDataType": "std",


		/**
		 * The title of this column.
		 *  @type string
		 *  @default null <i>Derived from the 'TH' value for this column in the 
		 *    original HTML table.</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sTitle": "My column title", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sTitle": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sTitle": null,


		/**
		 * The type allows you to specify how the data for this column will be sorted.
		 * Four types (string, numeric, date and html (which will strip HTML tags
		 * before sorting)) are currently available. Note that only date formats
		 * understood by Javascript's Date() object will be accepted as type date. For
		 * example: "Mar 26, 2008 5:03 PM". May take the values: 'string', 'numeric',
		 * 'date' or 'html' (by default). Further types can be adding through
		 * plug-ins.
		 *  @type string
		 *  @default null <i>Auto-detected from raw data</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sType": "html", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sType": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sType": null,


		/**
		 * Defining the width of the column, this parameter may take any CSS value
		 * (3em, 20px etc). DataTables apples 'smart' widths to columns which have not
		 * been given a specific width through this interface ensuring that the table
		 * remains readable.
		 *  @type string
		 *  @default null <i>Automatic</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sWidth": "20%", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sWidth": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sWidth": null
	};



	/**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable "class" are created on-the-fly as needed (typically by a 
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 * 
	 * Note that this object is related to {@link DataTable.defaults} but this 
	 * one is the internal data store for DataTables's cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don't need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant 
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
	DataTable.models.oSettings = {
		/**
		 * Primary features of DataTables and their enablement state.
		 *  @namespace
		 */
		"oFeatures": {

			/**
			 * Flag to say if DataTables should automatically try to calculate the
			 * optimum table and columns widths (true) or not (false).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoWidth": null,

			/**
			 * Delay the creation of TR and TD elements until they are actually
			 * needed by a driven page draw. This can give a significant speed
			 * increase for Ajax source and Javascript source data, but makes no
			 * difference at all fro DOM and server-side processing tables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bDeferRender": null,

			/**
			 * Enable filtering on the table or not. Note that if this is disabled
			 * then there is no filtering at all on the table, including fnFilter.
			 * To just remove the filtering input use sDom and remove the 'f' option.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bFilter": null,

			/**
			 * Table information element (the 'Showing x of y records' div) enable
			 * flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfo": null,

			/**
			 * Present a user control allowing the end user to change the page size
			 * when pagination is enabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bLengthChange": null,

			/**
			 * Pagination enabled or not. Note that if this is disabled then length
			 * changing must also be disabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bPaginate": null,

			/**
			 * Processing indicator enable flag whenever DataTables is enacting a
			 * user request - typically an Ajax request for server-side processing.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bProcessing": null,

			/**
			 * Server-side processing enabled flag - when enabled DataTables will
			 * get all data from the server for every draw - there is no filtering,
			 * sorting or paging done on the client-side.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bServerSide": null,

			/**
			 * Sorting enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSort": null,

			/**
			 * Apply a class to the columns which are being sorted to provide a
			 * visual highlight or not. This can slow things down when enabled since
			 * there is a lot of DOM interaction.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortClasses": null,

			/**
			 * State saving enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bStateSave": null
		},


		/**
		 * Scrolling settings for a table.
		 *  @namespace
		 */
		"oScroll": {
			/**
			 * Indicate if DataTables should be allowed to set the padding / margin
			 * etc for the scrolling header elements or not. Typically you will want
			 * this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoCss": null,

			/**
			 * When the table is shorter in height than sScrollY, collapse the
			 * table container down to the height of the table (when true).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bCollapse": null,

			/**
			 * Infinite scrolling enablement flag. Now deprecated in favour of
			 * using the Scroller plug-in.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfinite": null,

			/**
			 * Width of the scrollbar for the web-browser's platform. Calculated
			 * during table initialisation.
			 *  @type int
			 *  @default 0
			 */
			"iBarWidth": 0,

			/**
			 * Space (in pixels) between the bottom of the scrolling container and 
			 * the bottom of the scrolling viewport before the next page is loaded
			 * when using infinite scrolling.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type int
			 */
			"iLoadGap": null,

			/**
			 * Viewport width for horizontal scrolling. Horizontal scrolling is 
			 * disabled if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sX": null,

			/**
			 * Width to expand the table to when using x-scrolling. Typically you
			 * should not need to use this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @deprecated
			 */
			"sXInner": null,

			/**
			 * Viewport height for vertical scrolling. Vertical scrolling is disabled
			 * if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sY": null
		},

		/**
		 * Language information for the table.
		 *  @namespace
		 *  @extends DataTable.defaults.oLanguage
		 */
		"oLanguage": {
			/**
			 * Information callback function. See 
			 * {@link DataTable.defaults.fnInfoCallback}
			 *  @type function
			 *  @default null
			 */
			"fnInfoCallback": null
		},

		/**
		 * Browser support parameters
		 *  @namespace
		 */
		"oBrowser": {
			/**
			 * Indicate if the browser incorrectly calculates width:100% inside a
			 * scrolling element (IE6/7)
			 *  @type boolean
			 *  @default false
			 */
			"bScrollOversize": false
		},

		/**
		 * Array referencing the nodes which are used for the features. The 
		 * parameters of this object match what is allowed by sDom - i.e.
		 *   <ul>
		 *     <li>'l' - Length changing</li>
		 *     <li>'f' - Filtering input</li>
		 *     <li>'t' - The table!</li>
		 *     <li>'i' - Information</li>
		 *     <li>'p' - Pagination</li>
		 *     <li>'r' - pRocessing</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aanFeatures": [],

		/**
		 * Store data information - see {@link DataTable.models.oRow} for detailed
		 * information.
		 *  @type array
		 *  @default []
		 */
		"aoData": [],

		/**
		 * Array of indexes which are in the current display (after filtering etc)
		 *  @type array
		 *  @default []
		 */
		"aiDisplay": [],

		/**
		 * Array of indexes for display - no filtering
		 *  @type array
		 *  @default []
		 */
		"aiDisplayMaster": [],

		/**
		 * Store information about each column that is in use
		 *  @type array
		 *  @default []
		 */
		"aoColumns": [],

		/**
		 * Store information about the table's header
		 *  @type array
		 *  @default []
		 */
		"aoHeader": [],

		/**
		 * Store information about the table's footer
		 *  @type array
		 *  @default []
		 */
		"aoFooter": [],

		/**
		 * Search data array for regular expression searching
		 *  @type array
		 *  @default []
		 */
		"asDataSearch": [],

		/**
		 * Store the applied global search information in case we want to force a 
		 * research or compare the old search to a new one.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 */
		"oPreviousSearch": {},

		/**
		 * Store the applied search for each column - see 
		 * {@link DataTable.models.oSearch} for the format that is used for the
		 * filtering information for each column.
		 *  @type array
		 *  @default []
		 */
		"aoPreSearchCols": [],

		/**
		 * Sorting that is applied to the table. Note that the inner arrays are
		 * used in the following manner:
		 * <ul>
		 *   <li>Index 0 - column number</li>
		 *   <li>Index 1 - current sorting direction</li>
		 *   <li>Index 2 - index of asSorting for this column</li>
		 * </ul>
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @todo These inner arrays should really be objects
		 */
		"aaSorting": null,

		/**
		 * Sorting that is always applied to the table (i.e. prefixed in front of
		 * aaSorting).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array|null
		 *  @default null
		 */
		"aaSortingFixed": null,

		/**
		 * Classes to use for the striping of a table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"asStripeClasses": null,

		/**
		 * If restoring a table - we should restore its striping classes as well
		 *  @type array
		 *  @default []
		 */
		"asDestroyStripes": [],

		/**
		 * If restoring a table - we should restore its width 
		 *  @type int
		 *  @default 0
		 */
		"sDestroyWidth": 0,

		/**
		 * Callback functions array for every time a row is inserted (i.e. on a draw).
		 *  @type array
		 *  @default []
		 */
		"aoRowCallback": [],

		/**
		 * Callback functions for the header on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoHeaderCallback": [],

		/**
		 * Callback function for the footer on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoFooterCallback": [],

		/**
		 * Array of callback functions for draw callback functions
		 *  @type array
		 *  @default []
		 */
		"aoDrawCallback": [],

		/**
		 * Array of callback functions for row created function
		 *  @type array
		 *  @default []
		 */
		"aoRowCreatedCallback": [],

		/**
		 * Callback functions for just before the table is redrawn. A return of 
		 * false will be used to cancel the draw.
		 *  @type array
		 *  @default []
		 */
		"aoPreDrawCallback": [],

		/**
		 * Callback functions for when the table has been initialised.
		 *  @type array
		 *  @default []
		 */
		"aoInitComplete": [],


		/**
		 * Callbacks for modifying the settings to be stored for state saving, prior to
		 * saving state.
		 *  @type array
		 *  @default []
		 */
		"aoStateSaveParams": [],

		/**
		 * Callbacks for modifying the settings that have been stored for state saving
		 * prior to using the stored values to restore the state.
		 *  @type array
		 *  @default []
		 */
		"aoStateLoadParams": [],

		/**
		 * Callbacks for operating on the settings object once the saved state has been
		 * loaded
		 *  @type array
		 *  @default []
		 */
		"aoStateLoaded": [],

		/**
		 * Cache the table ID for quick access
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sTableId": "",

		/**
		 * The TABLE node for the main table
		 *  @type node
		 *  @default null
		 */
		"nTable": null,

		/**
		 * Permanent ref to the thead element
		 *  @type node
		 *  @default null
		 */
		"nTHead": null,

		/**
		 * Permanent ref to the tfoot element - if it exists
		 *  @type node
		 *  @default null
		 */
		"nTFoot": null,

		/**
		 * Permanent ref to the tbody element
		 *  @type node
		 *  @default null
		 */
		"nTBody": null,

		/**
		 * Cache the wrapper node (contains all DataTables controlled elements)
		 *  @type node
		 *  @default null
		 */
		"nTableWrapper": null,

		/**
		 * Indicate if when using server-side processing the loading of data 
		 * should be deferred until the second draw.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 *  @default false
		 */
		"bDeferLoading": false,

		/**
		 * Indicate if all required information has been read in
		 *  @type boolean
		 *  @default false
		 */
		"bInitialised": false,

		/**
		 * Information about open rows. Each object in the array has the parameters
		 * 'nTr' and 'nParent'
		 *  @type array
		 *  @default []
		 */
		"aoOpenRows": [],

		/**
		 * Dictate the positioning of DataTables' control elements - see
		 * {@link DataTable.model.oInit.sDom}.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sDom": null,

		/**
		 * Which type of pagination should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string 
		 *  @default two_button
		 */
		"sPaginationType": "two_button",

		/**
		 * The cookie duration (for bStateSave) in seconds.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type int
		 *  @default 0
		 */
		"iCookieDuration": 0,

		/**
		 * The cookie name prefix.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sCookiePrefix": "",

		/**
		 * Callback function for cookie creation.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 *  @default null
		 */
		"fnCookieCallback": null,

		/**
		 * Array of callback functions for state saving. Each array element is an 
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the JSON string to save that has been thus far created. Returns
		 *       a JSON string to be inserted into a json object 
		 *       (i.e. '"param": [ 0, 1, 2]')</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateSave": [],

		/**
		 * Array of callback functions for state loading. Each array element is an 
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings 
		 *       and the object stored. May return false to cancel state loading</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateLoad": [],

		/**
		 * State that was loaded from the cookie. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oLoadedState": null,

		/**
		 * Source url for AJAX data for the table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sAjaxSource": null,

		/**
		 * Property from a given object from which to read the table data from. This
		 * can be an empty string (when not server-side processing), in which case 
		 * it is  assumed an an array is given directly.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sAjaxDataProp": null,

		/**
		 * Note if draw should be blocked while getting data
		 *  @type boolean
		 *  @default true
		 */
		"bAjaxDataGet": true,

		/**
		 * The last jQuery XHR object that was used for server-side data gathering. 
		 * This can be used for working with the XHR information in one of the 
		 * callbacks
		 *  @type object
		 *  @default null
		 */
		"jqXHR": null,

		/**
		 * Function to get the server-side data.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnServerData": null,

		/**
		 * Functions which are called prior to sending an Ajax request so extra 
		 * parameters can easily be sent to the server
		 *  @type array
		 *  @default []
		 */
		"aoServerParams": [],

		/**
		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if 
		 * required).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sServerMethod": null,

		/**
		 * Format numbers for display.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnFormatNumber": null,

		/**
		 * List of options that can be used for the user selectable length menu.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aLengthMenu": null,

		/**
		 * Counter for the draws that the table does. Also used as a tracker for
		 * server-side processing
		 *  @type int
		 *  @default 0
		 */
		"iDraw": 0,

		/**
		 * Indicate if a redraw is being done - useful for Ajax
		 *  @type boolean
		 *  @default false
		 */
		"bDrawing": false,

		/**
		 * Draw index (iDraw) of the last error when parsing the returned data
		 *  @type int
		 *  @default -1
		 */
		"iDrawError": -1,

		/**
		 * Paging display length
		 *  @type int
		 *  @default 10
		 */
		"_iDisplayLength": 10,

		/**
		 * Paging start point - aiDisplay index
		 *  @type int
		 *  @default 0
		 */
		"_iDisplayStart": 0,

		/**
		 * Paging end point - aiDisplay index. Use fnDisplayEnd rather than
		 * this property to get the end point
		 *  @type int
		 *  @default 10
		 *  @private
		 */
		"_iDisplayEnd": 10,

		/**
		 * Server-side processing - number of records in the result set
		 * (i.e. before filtering), Use fnRecordsTotal rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type int
		 *  @default 0
		 *  @private
		 */
		"_iRecordsTotal": 0,

		/**
		 * Server-side processing - number of records in the current display set
		 * (i.e. after filtering). Use fnRecordsDisplay rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type boolean
		 *  @default 0
		 *  @private
		 */
		"_iRecordsDisplay": 0,

		/**
		 * Flag to indicate if jQuery UI marking and classes should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bJUI": null,

		/**
		 * The classes to use for the table
		 *  @type object
		 *  @default {}
		 */
		"oClasses": {},

		/**
		 * Flag attached to the settings object so you can check in the draw 
		 * callback if filtering has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bFiltered": false,

		/**
		 * Flag attached to the settings object so you can check in the draw 
		 * callback if sorting has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bSorted": false,

		/**
		 * Indicate that if multiple rows are in the header and there is more than 
		 * one unique cell per column, if the top one (true) or bottom one (false) 
		 * should be used for sorting / title by DataTables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bSortCellsTop": null,

		/**
		 * Initialisation object that is used for the table
		 *  @type object
		 *  @default null
		 */
		"oInit": null,

		/**
		 * Destroy callback functions - for plug-ins to attach themselves to the
		 * destroy so they can clean up markup and events.
		 *  @type array
		 *  @default []
		 */
		"aoDestroyCallback": [],


		/**
		 * Get the number of records in the current record set, before filtering
		 *  @type function
		 */
		"fnRecordsTotal": function () {
			if (this.oFeatures.bServerSide) {
				return parseInt(this._iRecordsTotal, 10);
			} else {
				return this.aiDisplayMaster.length;
			}
		},

		/**
		 * Get the number of records in the current record set, after filtering
		 *  @type function
		 */
		"fnRecordsDisplay": function () {
			if (this.oFeatures.bServerSide) {
				return parseInt(this._iRecordsDisplay, 10);
			} else {
				return this.aiDisplay.length;
			}
		},

		/**
		 * Set the display end point - aiDisplay index
		 *  @type function
		 *  @todo Should do away with _iDisplayEnd and calculate it on-the-fly here
		 */
		"fnDisplayEnd": function () {
			if (this.oFeatures.bServerSide) {
				if (this.oFeatures.bPaginate === false || this._iDisplayLength == -1) {
					return this._iDisplayStart + this.aiDisplay.length;
				} else {
					return Math.min(this._iDisplayStart + this._iDisplayLength,
						this._iRecordsDisplay);
				}
			} else {
				return this._iDisplayEnd;
			}
		},

		/**
		 * The DataTables object for this table
		 *  @type object
		 *  @default null
		 */
		"oInstance": null,

		/**
		 * Unique identifier for each instance of the DataTables object. If there
		 * is an ID on the table node, then it takes that value, otherwise an
		 * incrementing internal counter is used.
		 *  @type string
		 *  @default null
		 */
		"sInstance": null,

		/**
		 * tabindex attribute value that is added to DataTables control elements, allowing
		 * keyboard navigation of the table and its controls.
		 */
		"iTabIndex": 0,

		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollHead": null,

		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollFoot": null
	};

	/**
	 * Extension object for DataTables that is used to provide all extension options.
	 * 
	 * Note that the <i>DataTable.ext</i> object is available through
	 * <i>jQuery.fn.dataTable.ext</i> where it may be accessed and manipulated. It is
	 * also aliased to <i>jQuery.fn.dataTableExt</i> for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
	DataTable.ext = $.extend(true, {}, DataTable.models.ext);

	$.extend(DataTable.ext.oStdClasses, {
		"sTable": "dataTable",

		/* Two buttons buttons */
		"sPagePrevEnabled": "paginate_enabled_previous",
		"sPagePrevDisabled": "paginate_disabled_previous",
		"sPageNextEnabled": "paginate_enabled_next",
		"sPageNextDisabled": "paginate_disabled_next",
		"sPageJUINext": "",
		"sPageJUIPrev": "",

		/* Full numbers paging buttons */
		"sPageButton": "paginate_button",
		"sPageButtonActive": "paginate_active",
		"sPageButtonStaticDisabled": "paginate_button paginate_button_disabled",
		"sPageFirst": "first",
		"sPagePrevious": "previous",
		"sPageNext": "next",
		"sPageLast": "last",

		/* Striping classes */
		"sStripeOdd": "odd",
		"sStripeEven": "even",

		/* Empty row */
		"sRowEmpty": "dataTables_empty",

		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",

		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_asc_disabled",
		"sSortableDesc": "sorting_desc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		"sSortIcon": "",

		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",

		/* Misc */
		"sFooterTH": "",
		"sJUIHeader": "",
		"sJUIFooter": ""
	});


	$.extend(DataTable.ext.oJUIClasses, DataTable.ext.oStdClasses, {
		/* Two buttons buttons */
		"sPagePrevEnabled": "fg-button ui-button ui-state-default ui-corner-left",
		"sPagePrevDisabled": "fg-button ui-button ui-state-default ui-corner-left ui-state-disabled",
		"sPageNextEnabled": "fg-button ui-button ui-state-default ui-corner-right",
		"sPageNextDisabled": "fg-button ui-button ui-state-default ui-corner-right ui-state-disabled",
		"sPageJUINext": "ui-icon ui-icon-circle-arrow-e",
		"sPageJUIPrev": "ui-icon ui-icon-circle-arrow-w",

		/* Full numbers paging buttons */
		"sPageButton": "fg-button ui-button ui-state-default",
		"sPageButtonActive": "fg-button ui-button ui-state-default ui-state-disabled",
		"sPageButtonStaticDisabled": "fg-button ui-button ui-state-default ui-state-disabled",
		"sPageFirst": "first ui-corner-tl ui-corner-bl",
		"sPageLast": "last ui-corner-tr ui-corner-br",

		/* Features */
		"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi " +
			"ui-buttonset-multi paging_", /* Note that the type is postfixed */

		/* Sorting */
		"sSortAsc": "ui-state-default",
		"sSortDesc": "ui-state-default",
		"sSortable": "ui-state-default",
		"sSortableAsc": "ui-state-default",
		"sSortableDesc": "ui-state-default",
		"sSortableNone": "ui-state-default",
		"sSortJUIAsc": "css_right ui-icon ui-icon-triangle-1-n",
		"sSortJUIDesc": "css_right ui-icon ui-icon-triangle-1-s",
		"sSortJUI": "css_right ui-icon ui-icon-carat-2-n-s",
		"sSortJUIAscAllowed": "css_right ui-icon ui-icon-carat-1-n",
		"sSortJUIDescAllowed": "css_right ui-icon ui-icon-carat-1-s",
		"sSortJUIWrapper": "DataTables_sort_wrapper",
		"sSortIcon": "DataTables_sort_icon",

		/* Scrolling */
		"sScrollHead": "dataTables_scrollHead ui-state-default",
		"sScrollFoot": "dataTables_scrollFoot ui-state-default",

		/* Misc */
		"sFooterTH": "ui-state-default",
		"sJUIHeader": "fg-toolbar ui-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix",
		"sJUIFooter": "fg-toolbar ui-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix"
	});


	/*
	 * Variable: oPagination
	 * Purpose:  
	 * Scope:    jQuery.fn.dataTableExt
	 */
	$.extend(DataTable.ext.oPagination, {
		/*
		 * Variable: two_button
		 * Purpose:  Standard two button (forward/back) pagination
		 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"two_button": {
			/*
			 * Function: oPagination.two_button.fnInit
			 * Purpose:  Initialise dom elements required for pagination with forward/back buttons only
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           node:nPaging - the DIV which contains this pagination control
			 *           function:fnCallbackDraw - draw function which must be called on update
			 */
			"fnInit": function (oSettings, nPaging, fnCallbackDraw) {
				var oLang = oSettings.oLanguage.oPaginate;
				var oClasses = oSettings.oClasses;
				var fnClickHandler = function (e) {
					if (oSettings.oApi._fnPageChange(oSettings, e.data.action)) {
						fnCallbackDraw(oSettings);
					}
				};

				var sAppend = (!oSettings.bJUI) ?
					'<a class="' + oSettings.oClasses.sPagePrevDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button">' + oLang.sPrevious + '</a>' +
					'<a class="' + oSettings.oClasses.sPageNextDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button">' + oLang.sNext + '</a>'
					:
					'<a class="' + oSettings.oClasses.sPagePrevDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button"><span class="' + oSettings.oClasses.sPageJUIPrev + '"></span></a>' +
					'<a class="' + oSettings.oClasses.sPageNextDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button"><span class="' + oSettings.oClasses.sPageJUINext + '"></span></a>';
				$(nPaging).append(sAppend);

				var els = $('a', nPaging);
				var nPrevious = els[0],
					nNext = els[1];

				oSettings.oApi._fnBindAction(nPrevious, { action: "previous" }, fnClickHandler);
				oSettings.oApi._fnBindAction(nNext, { action: "next" }, fnClickHandler);

				/* ID the first elements only */
				if (!oSettings.aanFeatures.p) {
					nPaging.id = oSettings.sTableId + '_paginate';
					nPrevious.id = oSettings.sTableId + '_previous';
					nNext.id = oSettings.sTableId + '_next';

					nPrevious.setAttribute('aria-controls', oSettings.sTableId);
					nNext.setAttribute('aria-controls', oSettings.sTableId);
				}
			},

			/*
			 * Function: oPagination.two_button.fnUpdate
			 * Purpose:  Update the two button pagination at the end of the draw
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           function:fnCallbackDraw - draw function to call on page change
			 */
			"fnUpdate": function (oSettings, fnCallbackDraw) {
				if (!oSettings.aanFeatures.p) {
					return;
				}

				var oClasses = oSettings.oClasses;
				var an = oSettings.aanFeatures.p;

				/* Loop over each instance of the pager */
				for (var i = 0, iLen = an.length; i < iLen; i++) {
					if (an[i].childNodes.length !== 0) {
						an[i].childNodes[0].className = (oSettings._iDisplayStart === 0) ?
							oClasses.sPagePrevDisabled : oClasses.sPagePrevEnabled;

						an[i].childNodes[1].className = (oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay()) ?
							oClasses.sPageNextDisabled : oClasses.sPageNextEnabled;
					}
				}
			}
		},


		/*
		 * Variable: iFullNumbersShowPages
		 * Purpose:  Change the number of pages which can be seen
		 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"iFullNumbersShowPages": 5,

		/*
		 * Variable: full_numbers
		 * Purpose:  Full numbers pagination
		 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"full_numbers": {
			/*
			 * Function: oPagination.full_numbers.fnInit
			 * Purpose:  Initialise dom elements required for pagination with a list of the pages
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           node:nPaging - the DIV which contains this pagination control
			 *           function:fnCallbackDraw - draw function which must be called on update
			 */
			"fnInit": function (oSettings, nPaging, fnCallbackDraw) {
				var oLang = oSettings.oLanguage.oPaginate;
				var oClasses = oSettings.oClasses;
				var fnClickHandler = function (e) {
					if (oSettings.oApi._fnPageChange(oSettings, e.data.action)) {
						fnCallbackDraw(oSettings);
					}
				};

				$(nPaging).append(
					'<a  tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPageFirst + '">' + oLang.sFirst + '</a>' +
					'<a  tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPagePrevious + '">' + oLang.sPrevious + '</a>' +
					'<span></span>' +
					'<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPageNext + '">' + oLang.sNext + '</a>' +
					'<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPageLast + '">' + oLang.sLast + '</a>'
				);
				var els = $('a', nPaging);
				var nFirst = els[0],
					nPrev = els[1],
					nNext = els[2],
					nLast = els[3];

				oSettings.oApi._fnBindAction(nFirst, { action: "first" }, fnClickHandler);
				oSettings.oApi._fnBindAction(nPrev, { action: "previous" }, fnClickHandler);
				oSettings.oApi._fnBindAction(nNext, { action: "next" }, fnClickHandler);
				oSettings.oApi._fnBindAction(nLast, { action: "last" }, fnClickHandler);

				/* ID the first elements only */
				if (!oSettings.aanFeatures.p) {
					nPaging.id = oSettings.sTableId + '_paginate';
					nFirst.id = oSettings.sTableId + '_first';
					nPrev.id = oSettings.sTableId + '_previous';
					nNext.id = oSettings.sTableId + '_next';
					nLast.id = oSettings.sTableId + '_last';
				}
			},

			/*
			 * Function: oPagination.full_numbers.fnUpdate
			 * Purpose:  Update the list of page buttons shows
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           function:fnCallbackDraw - draw function to call on page change
			 */
			"fnUpdate": function (oSettings, fnCallbackDraw) {
				if (!oSettings.aanFeatures.p) {
					return;
				}

				var iPageCount = DataTable.ext.oPagination.iFullNumbersShowPages;
				var iPageCountHalf = Math.floor(iPageCount / 2);
				var iPages = Math.ceil((oSettings.fnRecordsDisplay()) / oSettings._iDisplayLength);
				var iCurrentPage = Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength) + 1;
				var sList = "";
				var iStartButton, iEndButton, i, iLen;
				var oClasses = oSettings.oClasses;
				var anButtons, anStatic, nPaginateList;
				var an = oSettings.aanFeatures.p;
				var fnBind = function (j) {
					oSettings.oApi._fnBindAction(this, { "page": j + iStartButton - 1 }, function (e) {
						/* Use the information in the element to jump to the required page */
						oSettings.oApi._fnPageChange(oSettings, e.data.page);
						fnCallbackDraw(oSettings);
						e.preventDefault();
					});
				};

				/* Pages calculation */
				if (oSettings._iDisplayLength === -1) {
					iStartButton = 1;
					iEndButton = 1;
					iCurrentPage = 1;
				}
				else if (iPages < iPageCount) {
					iStartButton = 1;
					iEndButton = iPages;
				}
				else if (iCurrentPage <= iPageCountHalf) {
					iStartButton = 1;
					iEndButton = iPageCount;
				}
				else if (iCurrentPage >= (iPages - iPageCountHalf)) {
					iStartButton = iPages - iPageCount + 1;
					iEndButton = iPages;
				}
				else {
					iStartButton = iCurrentPage - Math.ceil(iPageCount / 2) + 1;
					iEndButton = iStartButton + iPageCount - 1;
				}


				/* Build the dynamic list */
				for (i = iStartButton; i <= iEndButton; i++) {
					sList += (iCurrentPage !== i) ?
						'<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + '">' + oSettings.fnFormatNumber(i) + '</a>' :
						'<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButtonActive + '">' + oSettings.fnFormatNumber(i) + '</a>';
				}

				/* Loop over each instance of the pager */
				for (i = 0, iLen = an.length; i < iLen; i++) {
					if (an[i].childNodes.length === 0) {
						continue;
					}

					/* Build up the dynamic list first - html and listeners */
					$('span:eq(0)', an[i])
						.html(sList)
						.children('a').each(fnBind);

					/* Update the permanent button's classes */
					anButtons = an[i].getElementsByTagName('a');
					anStatic = [
						anButtons[0], anButtons[1],
						anButtons[anButtons.length - 2], anButtons[anButtons.length - 1]
					];

					$(anStatic).removeClass(oClasses.sPageButton + " " + oClasses.sPageButtonActive + " " + oClasses.sPageButtonStaticDisabled);
					$([anStatic[0], anStatic[1]]).addClass(
						(iCurrentPage == 1) ?
							oClasses.sPageButtonStaticDisabled :
							oClasses.sPageButton
					);
					$([anStatic[2], anStatic[3]]).addClass(
						(iPages === 0 || iCurrentPage === iPages || oSettings._iDisplayLength === -1) ?
							oClasses.sPageButtonStaticDisabled :
							oClasses.sPageButton
					);
				}
			}
		}
	});

	$.extend(DataTable.ext.oSort, {
		/*
		 * text sorting
		 */
		"string-pre": function (a) {
			if (typeof a != 'string') {
				a = (a !== null && a.toString) ? a.toString() : '';
			}
			return a.toLowerCase();
		},

		"string-asc": function (x, y) {
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},

		"string-desc": function (x, y) {
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		},


		/*
		 * html sorting (ignore html tags)
		 */
		"html-pre": function (a) {
			return a.replace(/<.*?>/g, "").toLowerCase();
		},

		"html-asc": function (x, y) {
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},

		"html-desc": function (x, y) {
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		},


		/*
		 * date sorting
		 */
		"date-pre": function (a) {
			var x = Date.parse(a);

			if (isNaN(x) || x === "") {
				x = Date.parse("01/01/1970 00:00:00");
			}
			return x;
		},

		"date-asc": function (x, y) {
			return x - y;
		},

		"date-desc": function (x, y) {
			return y - x;
		},


		/*
		 * numerical sorting
		 */
		"numeric-pre": function (a) {
			return (a == "-" || a === "") ? 0 : a * 1;
		},

		"numeric-asc": function (x, y) {
			return x - y;
		},

		"numeric-desc": function (x, y) {
			return y - x;
		}
	});


	$.extend(DataTable.ext.aTypes, [
		/*
		 * Function: -
		 * Purpose:  Check to see if a string is numeric
		 * Returns:  string:'numeric' or null
		 * Inputs:   mixed:sText - string to check
		 */
		function (sData) {
			/* Allow zero length strings as a number */
			if (typeof sData === 'number') {
				return 'numeric';
			}
			else if (typeof sData !== 'string') {
				return null;
			}

			var sValidFirstChars = "0123456789-";
			var sValidChars = "0123456789.";
			var Char;
			var bDecimal = false;

			/* Check for a valid first char (no period and allow negatives) */
			Char = sData.charAt(0);
			if (sValidFirstChars.indexOf(Char) == -1) {
				return null;
			}

			/* Check all the other characters are valid */
			for (var i = 1; i < sData.length; i++) {
				Char = sData.charAt(i);
				if (sValidChars.indexOf(Char) == -1) {
					return null;
				}

				/* Only allowed one decimal place... */
				if (Char == ".") {
					if (bDecimal) {
						return null;
					}
					bDecimal = true;
				}
			}

			return 'numeric';
		},

		/*
		 * Function: -
		 * Purpose:  Check to see if a string is actually a formatted date
		 * Returns:  string:'date' or null
		 * Inputs:   string:sText - string to check
		 */
		function (sData) {
			var iParse = Date.parse(sData);
			if ((iParse !== null && !isNaN(iParse)) || (typeof sData === 'string' && sData.length === 0)) {
				return 'date';
			}
			return null;
		},

		/*
		 * Function: -
		 * Purpose:  Check to see if a string should be treated as an HTML string
		 * Returns:  string:'html' or null
		 * Inputs:   string:sText - string to check
		 */
		function (sData) {
			if (typeof sData === 'string' && sData.indexOf('<') != -1 && sData.indexOf('>') != -1) {
				return 'html';
			}
			return null;
		}
	]);


	// jQuery aliases
	$.fn.DataTable = DataTable;
	$.fn.dataTable = DataTable;
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;


	// Information about events fired by DataTables - for documentation.
	/**
	 * Draw event, fired whenever the table is redrawn on the page, at the same point as
	 * fnDrawCallback. This may be useful for binding events or performing calculations when
	 * the table is altered at all.
	 *  @name DataTable#draw
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Filter event, fired when the filtering applied to the table (using the build in global
	 * global filter, or column filters) is altered.
	 *  @name DataTable#filter
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page change event, fired when the paging of the table is altered.
	 *  @name DataTable#page
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Sort event, fired when the sorting applied to the table is altered.
	 *  @name DataTable#sort
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * DataTables initialisation complete event, fired when the table is fully drawn,
	 * including Ajax data loaded, if Ajax data is required.
	 *  @name DataTable#init
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The JSON object request from the server - only
	 *    present if client-side Ajax sourced data is used</li></ol>
	 */

	/**
	 * State save event, fired when the table has changed state a new state save is required.
	 * This method allows modification of the state saving object prior to actually doing the
	 * save, including addition or other state properties (for plug-ins) or modification
	 * of a DataTables core property.
	 *  @name DataTable#stateSaveParams
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The state information to be saved
	 */

	/**
	 * State load event, fired when the table is loading state from the stored data, but
	 * prior to the settings object being modified by the saved state - allowing modification
	 * of the saved state is required or loading of state for a plug-in.
	 *  @name DataTable#stateLoadParams
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * State loaded event, fired when state has been loaded from stored data and the settings
	 * object has been modified by the loaded data.
	 *  @name DataTable#stateLoaded
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * Processing event, fired when DataTables is doing some kind of processing (be it,
	 * sort, filter or anything else). Can be used to indicate to the end user that
	 * there is something happening, or that something has finished.
	 *  @name DataTable#processing
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	 */

	/**
	 * Ajax (XHR) event, fired whenever an Ajax request is completed from a request to 
	 * made to the server for new data (note that this trigger is called in fnServerData,
	 * if you override fnServerData and which to use this event, you need to trigger it in
	 * you success function).
	 *  @name DataTable#xhr
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {object} json JSON returned from the server
	 */

	/**
	 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy or passing
	 * the bDestroy:true parameter in the initialisation object. This can be used to remove
	 * bound events, added DOM nodes, etc.
	 *  @name DataTable#destroy
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
}(jQuery, window, document, undefined));
/* Default class modification */
$.extend($.fn.dataTableExt.oStdClasses, {
	"sWrapper": "dataTables_wrapper form-inline"
});

/* API method to get paging information */
$.fn.dataTableExt.oApi.fnPagingInfo = function (oSettings) {
	return {
		"iStart": oSettings._iDisplayStart,
		"iEnd": oSettings.fnDisplayEnd(),
		"iLength": oSettings._iDisplayLength,
		"iTotal": oSettings.fnRecordsTotal(),
		"iFilteredTotal": oSettings.fnRecordsDisplay(),
		"iPage": Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength),
		"iTotalPages": Math.ceil(oSettings.fnRecordsDisplay() / oSettings._iDisplayLength)
	};
};

/* Bootstrap style pagination control */
$.extend($.fn.dataTableExt.oPagination, {
	"bootstrap": {
		"fnInit": function (oSettings, nPaging, fnDraw) {
			var oLang = oSettings.oLanguage.oPaginate;
			var fnClickHandler = function (e) {
				e.preventDefault();
				if (oSettings.oApi._fnPageChange(oSettings, e.data.action)) {
					fnDraw(oSettings);
				}
			};

			$(nPaging).addClass('pagination').append(
				'<ul>' +
				'<li class="prev disabled"><a href="#">&larr; ' + oLang.sPrevious + '</a></li>' +
				'<li class="next disabled"><a href="#">' + oLang.sNext + ' &rarr; </a></li>' +
				'</ul>'
			);
			var els = $('a', nPaging);
			$(els[0]).bind('click.DT', { action: "previous" }, fnClickHandler);
			$(els[1]).bind('click.DT', { action: "next" }, fnClickHandler);
		},

		"fnUpdate": function (oSettings, fnDraw) {
			var iListLength = 5;
			var oPaging = oSettings.oInstance.fnPagingInfo();
			var an = oSettings.aanFeatures.p;
			var i, j, sClass, iStart, iEnd, iHalf = Math.floor(iListLength / 2);

			if (oPaging.iTotalPages < iListLength) {
				iStart = 1;
				iEnd = oPaging.iTotalPages;
			}
			else if (oPaging.iPage <= iHalf) {
				iStart = 1;
				iEnd = iListLength;
			} else if (oPaging.iPage >= (oPaging.iTotalPages - iHalf)) {
				iStart = oPaging.iTotalPages - iListLength + 1;
				iEnd = oPaging.iTotalPages;
			} else {
				iStart = oPaging.iPage - iHalf + 1;
				iEnd = iStart + iListLength - 1;
			}

			for (i = 0, iLen = an.length; i < iLen; i++) {
				// Remove the middle elements
				$('li:gt(0)', an[i]).filter(':not(:last)').remove();

				// Add the new list items and their event handlers
				for (j = iStart; j <= iEnd; j++) {
					sClass = (j == oPaging.iPage + 1) ? 'class="active"' : '';
					$('<li ' + sClass + '><a href="#">' + j + '</a></li>')
						.insertBefore($('li:last', an[i])[0])
						.bind('click', function (e) {
							e.preventDefault();
							oSettings._iDisplayStart = (parseInt($('a', this).text(), 10) - 1) * oPaging.iLength;
							fnDraw(oSettings);
						});
				}

				// Add / remove disabled classes from the static elements
				if (oPaging.iPage === 0) {
					$('li:first', an[i]).addClass('disabled');
				} else {
					$('li:first', an[i]).removeClass('disabled');
				}

				if (oPaging.iPage === oPaging.iTotalPages - 1 || oPaging.iTotalPages === 0) {
					$('li:last', an[i]).addClass('disabled');
				} else {
					$('li:last', an[i]).removeClass('disabled');
				}
			}
		}
	}
});

/* Table initialisation */
$(document).ready(function () {
	$('#latest').dataTable({
		"sDom": "<'row'<><>r>t<'row'<><>>",
		"sPaginationType": "bootstrap",
		"iDisplayLength": -1,
		"aaSorting": [[0, 'desc']],
		"bAutoWidth": false,
		"aoColumns": [
			{ "sWidth": "5%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "0%" },
			{ "sWidth": "2%" },
			{ "sWidth": "66%" },
			{ "sWidth": "10%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "0%" },
			{ "sWidth": "15%" },
			{ "sWidth": "2%", "asSorting": [] }
		]
	});
	$('#people').dataTable({
		"sDom": "<'row'<><>r>t<'row'<><>>",
		"sPaginationType": "bootstrap",
		"iDisplayLength": -1,
		"aaSorting": [[5, 'desc']],
		"bAutoWidth": false,
		"aoColumns": [
			{ "sWidth": "5%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "0%" },
			{ "sWidth": "2%" },
			{ "sWidth": "66%" },
			{ "sWidth": "10%" },
			{ "sWidth": "0%" },
			{ "sWidth": "15%" },
			{ "sWidth": "2%", "asSorting": [] }
		]
	});

	$('#sight').dataTable({
		"sDom": "<'row'<'span12'f>r>t<'row'>",
		"sPaginationType": "bootstrap",
		"iDisplayLength": -1,
		//"aaSorting": [[6,'desc']],
		"bAutoWidth": false,

		"aoColumns": [
			{ "sWidth": "0%", "asSorting": [] },
			{ "sWidth": "8%", "asSorting": [] },
			{ "sWidth": "3%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "53%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "20%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "0%", "asSorting": [] },
			{ "sWidth": "10%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "0%", "asSorting": [] },
			{ "sWidth": "3%", "asSorting": [] }
			// { "sWidth": "3%", "asSorting": [] }
		]
	});
	$('#range').dataTable({
		"sDom": "<'row'<><>r>t<'row'<><>>",
		"sPaginationType": "bootstrap",
		"iDisplayLength": -1,
		"aaSorting": [[5, 'desc']],
		"bAutoWidth": false,
		"aoColumns": [
			{ "sWidth": "10%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "0%" },
			{ "sWidth": "2%" },
			{ "sWidth": "61%" },
			{ "sWidth": "10%", "asSorting": ["desc", "asc"] },
			{ "sWidth": "0%" },
			{ "sWidth": "15%" },
			{ "sWidth": "2%", "asSorting": [] }
		]
	});

});/**
  * PowerTip
  *
  * @fileoverview jQuery plugin that creates hover tooltips.
  * @link http://stevenbenner.github.com/jquery-powertip/
  * @author Steven Benner (http://stevenbenner.com/)
  * @version 1.1.0
  * @requires jQuery 1.7+
  *
  * @license jQuery PowerTip Plugin v1.1.0
  * http://stevenbenner.github.com/jquery-powertip/
  * Copyright 2012 Steven Benner (http://stevenbenner.com/)
  * Released under the MIT license.
  * <https://raw.github.com/stevenbenner/jquery-powertip/master/LICENSE.txt>
  */

(function ($) {
	'use strict';

	// useful private variables
	var $document = $(document),
		$window = $(window),
		$body = $('body');

	/**
	* Session data
	* Private properties global to all powerTip instances
	* @type Object
	*/
	var session = {
		isPopOpen: false,
		isFixedPopOpen: false,
		isClosing: false,
		popOpenImminent: false,
		activeHover: null,
		currentX: 0,
		currentY: 0,
		previousX: 0,
		previousY: 0,
		desyncTimeout: null,
		mouseTrackingActive: false
	};

	/**
	* Display hover tooltips on the matched elements.
	* @param {Object} opts The options object to use for the plugin.
	* @return {Object} jQuery object for the matched selectors.
	*/
	$.fn.powerTip = function (opts) {

		// don't do any work if there were no matched elements
		if (!this.length) {
			return this;
		}

		// extend options
		var options = $.extend({}, $.fn.powerTip.defaults, opts),
			tipController = new TooltipController(options);

		// hook mouse tracking
		initMouseTracking();

		// setup the elements
		this.each(function () {
			var $this = $(this),
				dataPowertip = $this.data('powertip'),
				dataElem = $this.data('powertipjq'),
				dataTarget = $this.data('powertiptarget'),
				title = $this.attr('title');


			// attempt to use title attribute text if there is no data-powertip,
			// data-powertipjq or data-powertiptarget. If we do use the title
			// attribute, delete the attribute so the browser will not show it
			if (!dataPowertip && !dataTarget && !dataElem && title) {
				$this.data('powertip', title);
				$this.removeAttr('title');
			}

			// create hover controllers for each element
			$this.data(
				'displayController',
				new DisplayController($this, options, tipController)
			);
		});

		// attach hover events to all matched elements
		return this.on({
			// mouse events
			mouseenter: function (event) {
				trackMouse(event);
				session.previousX = event.pageX;
				session.previousY = event.pageY;
				$(this).data('displayController').show();
			},
			mouseleave: function () {
				$(this).data('displayController').hide();
			},

			// keyboard events
			focus: function () {
				var element = $(this);
				if (!isMouseOver(element)) {
					element.data('displayController').show(true);
				}
			},
			blur: function () {
				$(this).data('displayController').hide(true);
			}
		});

	};

	/**
	* Default options for the powerTip plugin.
	* @type Object
	*/
	$.fn.powerTip.defaults = {
		fadeInTime: 200,
		fadeOutTime: 100,
		followMouse: false,
		popupId: 'powerTip',
		intentSensitivity: 7,
		intentPollInterval: 100,
		closeDelay: 100,
		placement: 'n',
		smartPlacement: false,
		offset: 10,
		mouseOnToPopup: false
	};

	/**
	* Default smart placement priority lists.
	* The first item in the array is the highest priority, the last is the
	* lowest. The last item is also the default, which will be used if all
	* previous options do not fit.
	* @type Object
	*/
	$.fn.powerTip.smartPlacementLists = {
		n: ['n', 'ne', 'nw', 's'],
		e: ['e', 'ne', 'se', 'w', 'nw', 'sw', 'n', 's', 'e'],
		s: ['s', 'se', 'sw', 'n'],
		w: ['w', 'nw', 'sw', 'e', 'ne', 'se', 'n', 's', 'w'],
		nw: ['nw', 'w', 'sw', 'n', 's', 'se', 'nw'],
		ne: ['ne', 'e', 'se', 'n', 's', 'sw', 'ne'],
		sw: ['sw', 'w', 'nw', 's', 'n', 'ne', 'sw'],
		se: ['se', 'e', 'ne', 's', 'n', 'nw', 'se']
	};

	/**
	* Public API
	* @type Object
	*/
	$.powerTip = {

		/**
		* Attempts to show the tooltip for the specified element.
		* @public
		* @param {Object} element The element that the tooltip should for.
		*/
		showTip: function (element) {
			// close any open tooltip
			$.powerTip.closeTip();
			// grab only the first matched element and ask it to show its tip
			element = element.first();
			if (!isMouseOver(element)) {
				element.data('displayController').show(true, true);
			}
		},

		/**
		* Attempts to close any open tooltips.
		* @public
		*/
		closeTip: function () {
			$document.triggerHandler('closePowerTip');
		}

	};

	/**
	* Creates a new tooltip display controller.
	* @private
	* @constructor
	* @param {Object} element The element that this controller will handle.
	* @param {Object} options Options object containing settings.
	* @param {TooltipController} tipController The TooltipController for this instance.
	*/
	function DisplayController(element, options, tipController) {
		var hoverTimer = null;

		/**
		* Begins the process of showing a tooltip.
		* @private
		* @param {Boolean=} immediate Skip intent testing (optional).
		* @param {Boolean=} forceOpen Ignore cursor position and force tooltip to open (optional).
		*/
		function openTooltip(immediate, forceOpen) {
			cancelTimer();
			if (!element.data('hasActiveHover')) {
				if (!immediate) {
					session.popOpenImminent = true;
					hoverTimer = setTimeout(
						function () {
							hoverTimer = null;
							checkForIntent(element);
						},
						options.intentPollInterval
					);
				} else {
					if (forceOpen) {
						element.data('forcedOpen', true);
					}
					tipController.showTip(element);
				}
			}
		}

		/**
		* Begins the process of closing a tooltip.
		* @private
		* @param {Boolean=} disableDelay Disable close delay (optional).
		*/
		function closeTooltip(disableDelay) {
			cancelTimer();
			if (element.data('hasActiveHover')) {
				session.popOpenImminent = false;
				element.data('forcedOpen', false);
				if (!disableDelay) {
					hoverTimer = setTimeout(
						function () {
							hoverTimer = null;
							tipController.hideTip(element);
						},
						options.closeDelay
					);
				} else {
					tipController.hideTip(element);
				}
			}
		}

		/**
		* Checks mouse position to make sure that the user intended to hover
		* on the specified element before showing the tooltip.
		* @private
		*/
		function checkForIntent() {
			// calculate mouse position difference
			var xDifference = Math.abs(session.previousX - session.currentX),
				yDifference = Math.abs(session.previousY - session.currentY),
				totalDifference = xDifference + yDifference;

			// check if difference has passed the sensitivity threshold
			if (totalDifference < options.intentSensitivity) {
				tipController.showTip(element);
			} else {
				// try again
				session.previousX = session.currentX;
				session.previousY = session.currentY;
				openTooltip();
			}
		}

		/**
		* Cancels active hover timer.
		* @private
		*/
		function cancelTimer() {
			hoverTimer = clearTimeout(hoverTimer);
		}

		// expose the methods
		return {
			show: openTooltip,
			hide: closeTooltip,
			cancel: cancelTimer
		};
	}

	/**
	* Creates a new tooltip controller.
	* @private
	* @constructor
	* @param {Object} options Options object containing settings.
	*/
	function TooltipController(options) {

		// build and append popup div if it does not already exist
		var tipElement = $('#' + options.popupId);
		if (tipElement.length === 0) {
			tipElement = $('<div></div>', { id: options.popupId });
			// grab body element if it was not populated when the script loaded
			// this hack exists solely for jsfiddle support
			if ($body.length === 0) {
				$body = $('body');
			}
			$body.append(tipElement);
		}

		// hook mousemove for cursor follow tooltips
		if (options.followMouse) {
			// only one positionTipOnCursor hook per popup element, please
			if (!tipElement.data('hasMouseMove')) {
				$document.on({
					mousemove: positionTipOnCursor,
					scroll: positionTipOnCursor
				});
			}
			tipElement.data('hasMouseMove', true);
		}

		// if we want to be able to mouse onto the popup then we need to attach
		// hover events to the popup that will cancel a close request on hover
		// and start a new close request on mouseleave
		if (options.followMouse || options.mouseOnToPopup) {
			tipElement.on({
				mouseenter: function () {
					if (tipElement.data('followMouse') || tipElement.data('mouseOnToPopup')) {
						// check activeHover in case the mouse cursor entered
						// the tooltip during the fadeOut and close cycle
						if (session.activeHover) {
							session.activeHover.data('displayController').cancel();
						}
					}
				},
				mouseleave: function () {
					if (tipElement.data('mouseOnToPopup')) {
						// check activeHover in case the mouse cursor entered
						// the tooltip during the fadeOut and close cycle
						if (session.activeHover) {
							session.activeHover.data('displayController').hide();
						}
					}
				}
			});
		}

		/**
		* Gives the specified element the active-hover state and queues up
		* the showTip function.
		* @private
		* @param {Object} element The element that the tooltip should target.
		*/
		function beginShowTip(element) {
			element.data('hasActiveHover', true);
			// show popup, asap
			tipElement.queue(function (next) {
				showTip(element);
				next();
			});
		}

		/**
		* Shows the tooltip popup, as soon as possible.
		* @private
		* @param {Object} element The element that the popup should target.
		*/
		function showTip(element) {
			// it is possible, especially with keyboard navigation, to move on
			// to another element with a tooltip during the queue to get to
			// this point in the code. if that happens then we need to not
			// proceed or we may have the fadeout callback for the last tooltip
			// execute immediately after this code runs, causing bugs.
			if (!element.data('hasActiveHover')) {
				return;
			}

			// if the popup is open and we got asked to open another one then
			// the old one is still in its fadeOut cycle, so wait and try again
			if (session.isPopOpen) {
				if (!session.isClosing) {
					hideTip(session.activeHover);
				}
				tipElement.delay(100).queue(function (next) {
					showTip(element);
					next();
				});
				return;
			}

			// trigger powerTipPreRender event
			element.trigger('powerTipPreRender');

			var tipText = element.data('powertip'),
				tipTarget = element.data('powertiptarget'),
				tipElem = element.data('powertipjq'),
				tipContent = tipTarget ? $('#' + tipTarget) : [];

			// set popup content
			if (tipText) {
				tipElement.html(tipText);
			} else if (tipElem && tipElem.length > 0) {
				tipElement.empty();
				tipElem.clone(true, true).appendTo(tipElement);
			} else if (tipContent && tipContent.length > 0) {
				tipElement.html($('#' + tipTarget).html());
			} else {
				// we have no content to display, give up
				return;
			}

			// trigger powerTipRender event
			element.trigger('powerTipRender');

			// hook close event for triggering from the api
			$document.on('closePowerTip', function () {
				element.data('displayController').hide(true);
			});

			session.activeHover = element;
			session.isPopOpen = true;

			tipElement.data('followMouse', options.followMouse);
			tipElement.data('mouseOnToPopup', options.mouseOnToPopup);

			// set popup position
			if (!options.followMouse) {
				positionTipOnElement(element);
				session.isFixedPopOpen = true;
			} else {
				positionTipOnCursor();
			}

			// fadein
			tipElement.fadeIn(options.fadeInTime, function () {
				// start desync polling
				if (!session.desyncTimeout) {
					session.desyncTimeout = setInterval(closeDesyncedTip, 500);
				}

				// trigger powerTipOpen event
				element.trigger('powerTipOpen');
			});
		}

		/**
		* Hides the tooltip popup, immediately.
		* @private
		* @param {Object} element The element that the popup should target.
		*/
		function hideTip(element) {
			session.isClosing = true;
			element.data('hasActiveHover', false);
			element.data('forcedOpen', false);
			// reset session
			session.activeHover = null;
			session.isPopOpen = false;
			// stop desync polling
			session.desyncTimeout = clearInterval(session.desyncTimeout);
			// unhook close event api listener
			$document.off('closePowerTip');
			// fade out
			tipElement.fadeOut(options.fadeOutTime, function () {
				session.isClosing = false;
				session.isFixedPopOpen = false;
				tipElement.removeClass();
				// support mouse-follow and fixed position pops at the same
				// time by moving the popup to the last known cursor location
				// after it is hidden
				setTipPosition(
					session.currentX + options.offset,
					session.currentY + options.offset
				);

				// trigger powerTipClose event
				element.trigger('powerTipClose');
			});
		}

		/**
		* Checks for a tooltip desync and closes the tooltip if one occurs.
		* @private
		*/
		function closeDesyncedTip() {
			// It is possible for the mouse cursor to leave an element without
			// firing the mouseleave event. This seems to happen (in FF) if the
			// element is disabled under mouse cursor, the element is moved out
			// from under the mouse cursor (such as a slideDown() occurring
			// above it), or if the browser is resized by code moving the
			// element from under the mouse cursor. If this happens it will
			// result in a desynced tooltip because we wait for any exiting
			// open tooltips to close before opening a new one. So we should
			// periodically check for a desync situation and close the tip if
			// such a situation arises.
			if (session.isPopOpen && !session.isClosing) {
				var isDesynced = false;

				// case 1: user already moused onto another tip - easy test
				if (session.activeHover.data('hasActiveHover') === false) {
					isDesynced = true;
				} else {
					// case 2: hanging tip - have to test if mouse position is
					// not over the active hover and not over a tooltip set to
					// let the user interact with it.
					// for keyboard navigation, this only counts if the element
					// does not have focus.
					// for tooltips opened via the api we need to check if it
					// has the forcedOpen flag.
					if (!isMouseOver(session.activeHover) && !session.activeHover.is(":focus") && !session.activeHover.data('forcedOpen')) {
						if (tipElement.data('mouseOnToPopup')) {
							if (!isMouseOver(tipElement)) {
								isDesynced = true;
							}
						} else {
							isDesynced = true;
						}
					}
				}

				if (isDesynced) {
					// close the desynced tip
					hideTip(session.activeHover);
				}
			}
		}

		/**
		* Moves the tooltip popup to the users mouse cursor.
		* @private
		*/
		function positionTipOnCursor() {
			// to support having fixed powertips on the same page as cursor
			// powertips, where both instances are referencing the same popup
			// element, we need to keep track of the mouse position constantly,
			// but we should only set the pop location if a fixed pop is not
			// currently open, a pop open is imminent or active, and the popup
			// element in question does have a mouse-follow using it.
			if ((session.isPopOpen && !session.isFixedPopOpen) || (session.popOpenImminent && !session.isFixedPopOpen && tipElement.data('hasMouseMove'))) {
				// grab measurements
				var scrollTop = $window.scrollTop(),
					windowWidth = $window.width(),
					windowHeight = $window.height(),
					popWidth = tipElement.outerWidth(),
					popHeight = tipElement.outerHeight(),
					x = 0,
					y = 0;

				// constrain pop to browser viewport
				if ((popWidth + session.currentX + options.offset) < windowWidth) {
					x = session.currentX + options.offset;
				} else {
					x = windowWidth - popWidth;
				}
				if ((popHeight + session.currentY + options.offset) < (scrollTop + windowHeight)) {
					y = session.currentY + options.offset;
				} else {
					y = scrollTop + windowHeight - popHeight;
				}

				// position the tooltip
				setTipPosition(x, y);
			}
		}

		/**
		* Sets the tooltip popup too the correct position relative to the
		* specified target element. Based on options settings.
		* @private
		* @param {Object} element The element that the popup should target.
		*/
		function positionTipOnElement(element) {
			var tipWidth = tipElement.outerWidth(),
				tipHeight = tipElement.outerHeight(),
				priorityList,
				placementCoords,
				finalPlacement,
				collisions;

			// with smart placement we will try a series of placement
			// options and use the first one that does not collide with the
			// browser view port boundaries.
			if (options.smartPlacement) {

				// grab the placement priority list
				priorityList = $.fn.powerTip.smartPlacementLists[options.placement];

				// iterate over the priority list and use the first placement
				// option that does not collide with the viewport. if they all
				// collide then the last placement in the list will be used.
				$.each(priorityList, function (idx, pos) {
					// get placement coordinates
					placementCoords = computePlacementCoords(
						element,
						pos,
						tipWidth,
						tipHeight
					);
					finalPlacement = pos;

					// find collisions
					collisions = getViewportCollisions(
						placementCoords,
						tipWidth,
						tipHeight
					);

					// break if there were no collisions
					if (collisions.length === 0) {
						return false;
					}
				});

			} else {

				// if we're not going to use the smart placement feature then
				// just compute the coordinates and do it
				placementCoords = computePlacementCoords(
					element,
					options.placement,
					tipWidth,
					tipHeight
				);
				finalPlacement = options.placement;

			}

			// add placement as class for CSS arrows
			tipElement.addClass(finalPlacement);

			// position the tooltip
			setTipPosition(placementCoords.x, placementCoords.y);
		}

		/**
		* Compute the top/left coordinates to display the tooltip at the
		* specified placement relative to the specified element.
		* @private
		* @param {Object} element The element that the tooltip should target.
		* @param {String} placement The placement for the tooltip.
		* @param {Number} popWidth Width of the tooltip element in pixels.
		* @param {Number} popHeight Height of the tooltip element in pixels.
		* @retun {Object} An object with the x and y coordinates.
		*/
		function computePlacementCoords(element, placement, popWidth, popHeight) {
			// grab measurements
			var objectOffset = element.offset(),
				objectWidth = element.outerWidth(),
				objectHeight = element.outerHeight(),
				x = 0,
				y = 0;

			// calculate the appropriate x and y position in the document
			switch (placement) {
				case 'n':
					x = (objectOffset.left + (objectWidth / 2)) - (popWidth / 2);
					y = objectOffset.top - popHeight - options.offset;
					break;
				case 'e':
					x = objectOffset.left + objectWidth + options.offset;
					y = (objectOffset.top + (objectHeight / 2)) - (popHeight / 2);
					break;
				case 's':
					x = (objectOffset.left + (objectWidth / 2)) - (popWidth / 2);
					y = objectOffset.top + objectHeight + options.offset;
					break;
				case 'w':
					x = objectOffset.left - popWidth - options.offset;
					y = (objectOffset.top + (objectHeight / 2)) - (popHeight / 2);
					break;
				case 'nw':
					x = (objectOffset.left - popWidth) + 20;
					y = objectOffset.top - popHeight - options.offset;
					break;
				case 'ne':
					x = (objectOffset.left + objectWidth) - 20;
					y = objectOffset.top - popHeight - options.offset;
					break;
				case 'sw':
					x = (objectOffset.left - popWidth) + 20;
					y = objectOffset.top + objectHeight + options.offset;
					break;
				case 'se':
					x = (objectOffset.left + objectWidth) - 20;
					y = objectOffset.top + objectHeight + options.offset;
					break;
			}

			return {
				x: Math.round(x),
				y: Math.round(y)
			};
		}

		/**
		* Sets the tooltip CSS position on the document.
		* @private
		* @param {Number} x Left position in pixels.
		* @param {Number} y Top position in pixels.
		*/
		function setTipPosition(x, y) {
			tipElement.css('left', x + 'px');
			tipElement.css('top', y + 'px');
		}

		// expose methods
		return {
			showTip: beginShowTip,
			hideTip: hideTip
		};
	}

	/**
	* Hooks mouse position tracking to mousemove and scroll events.
	* Prevents attaching the events more than once.
	* @private
	*/
	function initMouseTracking() {
		var lastScrollX = 0,
			lastScrollY = 0;

		if (!session.mouseTrackingActive) {
			session.mouseTrackingActive = true;

			// grab the current scroll position on load
			$(function () {
				lastScrollX = $document.scrollLeft();
				lastScrollY = $document.scrollTop();
			});

			// hook mouse position tracking
			$document.on({
				mousemove: trackMouse,
				scroll: function () {
					var x = $document.scrollLeft(),
						y = $document.scrollTop();
					if (x !== lastScrollX) {
						session.currentX += x - lastScrollX;
						lastScrollX = x;
					}
					if (y !== lastScrollY) {
						session.currentY += y - lastScrollY;
						lastScrollY = y;
					}
				}
			});
		}
	}

	/**
	* Saves the current mouse coordinates to the powerTip session object.
	* @private
	* @param {Object} event The mousemove event for the document.
	*/
	function trackMouse(event) {
		session.currentX = event.pageX;
		session.currentY = event.pageY;
	}

	/**
	* Tests if the mouse is currently over the specified element.
	* @private
	* @param {Object} element The element to check for hover.
	* @return {Boolean}
	*/
	function isMouseOver(element) {
		var elementPosition = element.offset();
		return session.currentX >= elementPosition.left &&
			session.currentX <= elementPosition.left + element.outerWidth() &&
			session.currentY >= elementPosition.top &&
			session.currentY <= elementPosition.top + element.outerHeight();
	}

	/**
	* Finds any viewport collisions that an element (the tooltip) would have
	* if it were absolutely positioned at the specified coordinates.
	* @private
	* @param {Object} coords Coordinates for the element. (e.g. {x: 123, y: 123})
	* @param {Number} elementWidth Width of the element in pixels.
	* @param {Number} elementHeight Height of the element in pixels.
	* @return {Array} Array of words representing directional collisions.
	*/
	function getViewportCollisions(coords, elementWidth, elementHeight) {
		var scrollLeft = $window.scrollLeft(),
			scrollTop = $window.scrollTop(),
			windowWidth = $window.width(),
			windowHeight = $window.height(),
			collisions = [];

		if (coords.y < scrollTop) {
			collisions.push('top');
		}
		if (coords.y + elementHeight > scrollTop + windowHeight) {
			collisions.push('bottom');
		}
		if (coords.x < scrollLeft) {
			collisions.push('left');
		}
		if (coords.x + elementWidth > scrollLeft + windowWidth) {
			collisions.push('right');
		}

		return collisions;
	}

}(jQuery));
//static.js
String.prototype.htmlEscape = function () {
	s = this;
	s = s.replace(/&/g, '&amp;');
	s = s.replace(/>/g, '&gt;');
	s = s.replace(/</g, '&lt;');
	return s;
}
String.prototype.encodeLatin = function () {
	var arr = [], hash;
	if (this.length == 0) return '';
	for (var i = 0, len = this.length; i < len; i++) {
		arr.push(this.charCodeAt(i));
	}
	hash = arr.join('@');
	return hash;
};

$(function () {
	$('#dropmenu').hover(
		function () {
			$('.dropdown').addClass('open');
		},
		function () {
			$('.dropdown').removeClass('open');
		}
	);
	$('ul.nav > li:first > a').prepend('<i class="icon-home icon-white"></i>');
	$('ul.nav > li:eq(1) > a').prepend('<i class="icon-share icon-white"></i>');
	$('ul.nav > li:eq(2) > a').prepend('<i class="icon-info-sign icon-white"></i>');
	$('li#link > a').prepend('<i class="icon-home"></i>');
	$('li#blog > a').prepend('<i class="icon-share"></i>');
	$('li#book > a').prepend('<i class="icon-star"></i>');
	$('li#info > a').prepend('<i class="icon-info-sign"></i>');
	$('ul#rank > li > a').prepend('<i class="icon-signal"></i>');

	$("div.pagination ul li:not(:has(a))").addClass('active').wrapInner("<a>");
	//bookmark setting
	$('#removeBook').click(function () {
		var flag = confirm('ブックマークを全て削除しますか？');
		if (flag) {
			$('.starOn').removeClass('starOn').addClass('starOff');
			var cMgr = new H_CookieManager();
			cMgr.setCookie("set[bookmark]", "", 3600 * 24 * 5000, '/');
		}
	});
	$('.starOff').click(function () {
		var limit = 1000;
		var id = this.id.replace(/bm_/, '');
		var cMgr = new H_CookieManager();
		var str = cMgr.getCookie('set[bookmark]');
		var arr;
		if (str) {
			arrlen = str.split('.').length;
			if (arrlen > limit) {
				$("#bmmsg").fadeIn("slow");
				setTimeout(function () { $("#bmmsg").fadeOut("slow"); }, 2500);
				return;
			}
			str = '.' + str + '.';
		}
		else {
			str = '.';
		}
		var reg = new RegExp('.' + id + '.');
		if (this.className == 'starOff') {
			$(this).removeClass('starOff').addClass('starOn');
			if (reg.test(str)) {
				return;
			}
			str = str + id + '.';
			str = str.slice(1, -1);
			cMgr.setCookie("set[bookmark]", str, 3600 * 24 * 5000, '/');
		}
		else if (this.className == 'starOn') {
			$(this).removeClass('starOn').addClass('starOff');
			if (reg.test(str)) {
				var reg = new RegExp('.' + id + '.');
				str = str.replace(reg, '.');
				str = str.slice(1, -1);
				cMgr.setCookie("set[bookmark]", str, 3600 * 24 * 5000, '/');
			}
		}
	});
	if ($('table').hasClass('bookmark')) {
		$('.starOff').removeClass('starOff').addClass('starOn');
	}


});

function xhr(xmlhttp) {
	var xmlhttp = false;
	if (typeof ActiveXObject != "undefined") { /* IE5, IE6 */
		try {
			xmlhttp = new ActiveXObject("Msxml2.XMLHTTP"); /* MSXML3 */
		}
		catch (e) {
			xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); /* MSXML2 */
		}
	}
	if (!xmlhttp && typeof XMLHttpRequest != "undefined") {
		xmlhttp = new XMLHttpRequest(); /* Firefox, Safari, IE7 */
		return xmlhttp;
	}

	if (!xmlhttp) {
		alert("XMLHttpRequest非対応ブラウザ");
		return false;
	}
}
function checkRss(xmlURL) {
	/* XMLHttpRequestオブジェクト作成 */
	var xmlhttp = false;
	xmlhttp = xhr(xmlhttp);
	/* レスポンスデータ処理 */
	xmlhttp.onreadystatechange = function () {
		if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
			/* ★レスポンスヘッダ取得 */
			var s = "";
			s += "Content-Type: " + xmlhttp.getResponseHeader('Content-Type');
			alert(s);
		}
	}
	/* HTTPリクエスト実行 */
	xmlhttp.open("GET", xmlURL, true);
	xmlhttp.send(null);

}

function getFile(url) {
	var req;
	if (window.XMLHttpRequest) {
		req = new XMLHttpRequest();
	} else if (window.ActiveXObject) {
		try {
			req = new ActiveXObject("MSXML2.XMLHTTP");
		}
		catch (e) {
			try {
				req = new ActiveXObject("Microsoft.XMLHTTP");
			}
			catch (e2) {
				return false;
			}
		}
	}
	req.open('GET', url, false);
	req.send('');
	return;
}

function execAjax(url) {

	jQuery.ajax({
		url: url,
		async: false,
		type: "POST",
		data: {
			history: str
		},
		dataType: "html",
		evalScript: true,
		error: function (jqXHR, textStatus, errorThrown) { },
		success: function (data, textStatus) {
			if (textStatus == 'success') {

				$("div#history").html(data);
				return;
			}
			// このスコープで処理を行う必要があれば実装する

		}
	});
	// resultに格納された結果を元に何かしらの処理を実装する

}

function initCookie(name, value) {
	var cMgr = new H_CookieManager();
	if (!cMgr.getCookie(name)) {
		if (window.localStorage) {
			var str = localStorage.getItem(name);
			if (str) {
				cMgr.setCookie(name, str, 3600 * 24 * 5000, '/');
			}
			else {
				cMgr.setCookie(name, value, 3600 * 24 * 5000, '/');
			}
		}
		else {
			cMgr.setCookie(name, value, 3600 * 24 * 5000, '/');
		}
	}
}
function removeCookie(name) {
	var cMgr = new H_CookieManager();
	if (cMgr.getCookie(name)) cMgr.setCookie(name, '', 3600 * 24 * 5000, '/');
	if (window.localStorage) localStorage.removeItem(name);
}
function reloadPage() {
	alert('設定をリセットしました');
	location.reload();
}
//--initilise display show or hide
function initDisp(bool) {
	var cMgr = new H_CookieManager();
	var sidVal = cMgr.getCookie("set[filter]");
	if (sidVal) {
		var reArrVal = sidVal.split(':');
		if (bool) {
			for (var i = 0, len = reArrVal.length; i < len; i++) {
				if (reArrVal[i] == '') continue;
				$('tbody > tr.sid_' + reArrVal[i]).addClass('sdn');
			}
		}
		else {
			for (var i = 0, len = reArrVal.length; i < len; i++) {
				if (reArrVal[i] == '') continue;
				$('tr#sid_' + reArrVal[i] + ' td:eq(1) button').removeClass('btn-primary').addClass('btn-inverse').text('表示OFF');
			}
		}
	}
}

function pp(obj) {
	var properties = '';
	for (var prop in obj) {
		properties += prop + "=" + obj[prop] + "\n";
	}
	alert(properties);
}
//set checkSwitch function
function checkSwitch(content, cookie, selector, classOn, classOff) {
	sid = content.parentNode;
	cMgr = new H_CookieManager();
	sidVal = cMgr.getCookie(cookie);
	sidC = sid.id;
	limit = 50;

	if (!sidVal) {
		cMgr.setCookie(cookie, " ", 3600 * 24 * 5000, '/');
		sidVal = cMgr.getCookie(cookie);
	}
	sidVal = $.trim(sidVal.toString());
	if (selector == 'filter') {
		sid = sid.className.match(/^sid_[0-9]+/i);
		$("tr." + sid + " > td." + selector).toggleClass(classOn).toggleClass(classOff);
	}
	if (selector == 'siteFilter') {
		sid = sid.id.match(/^sid_[0-9]+/i);
	}

	sid.str = sid.toString().match(/[0-9]+/);
	re = new RegExp(":" + sid.str + ":");
	if (!re.test(sidVal)) {
		sidVal += ":" + sid.str + ":";
	} else {
		sidVal = sidVal.replace(re, "");
	}
	cMgr.setCookie(cookie, sidVal, 3600 * 24 * 5000, '/');
}
//function setDetails
function setDetails(cookie, max, id) {
	var cMgr = new H_CookieManager();
	var num = cMgr.getCookie(cookie);
	if (0 <= num && num <= max) $('#' + id + ' > option:eq(' + num + ')').attr('selected', 'selected');
}

$(function () {
	//initialize Cookie and WebStorage
	initCookie('set[filter]', '');
	initCookie('set[top]', '0');
	initCookie('set[last]', '1');
	initCookie('set[trand]', '1');
	initCookie('set[dispSiteTable]', '0');
	initCookie('set[bookmark]', '');
	initCookie('set[ocmenu]', '1');
	if ($('#sight').size() > 0) {
		initDisp(false);
	}
	else {
		initDisp(true);
	}

	function changeChTable(num, value) {
		var cMgr = new H_CookieManager();
		var str = cMgr.getCookie('set[chTable]');
		var arr = str.split('.');
		arr[num] = value;
		str = arr.join('.');
	}

	$('#ad').toggle(
		function () {
			$(this).removeClass('btn-inverse').addClass('btn-primary').text('表示フィルタOFF');
			$("tr.sdn > td.filter").addClass("checkOn").removeClass("checkOff");
			$('tr.sdn').removeClass('sdn');
			if ($('#thFilter').hasClass('hide')) {
				changeChTable(7, 1);
				switchFilter(true);
			}
		},
		function () {
			$(this).removeClass('btn-primary').addClass('btn-inverse').text('表示フィルタ ＯＮ');
			initDisp(true);
		}
	);
	$('#sight tbody tr td button.btn').click(function () {
		if ($(this).hasClass('btn-primary')) {
			$(this).removeClass('btn-primary').addClass('btn-inverse').text('表示OFF');
		} else if ($(this).hasClass('btn-inverse')) {
			$(this).removeClass('btn-inverse').addClass('btn-primary').text('表示 O N');
		}
	});
	//--set Cookie 'filter'
	$('td.filter').click
		(
			function () {
				checkSwitch(this, "set[filter]", 'filter', 'checkOn', 'checkOff');
			}
		);
	$('td.siteFilter').click
		(
			function () {
				checkSwitch(this, "set[filter]", 'siteFilter', 'checkOn', 'checkOff');
			}
		);

	//--set Cookie 'feeds'

	//remove Cookie setting
	$('#rmFilter').click(function () {
		var flag = confirm('フィルターの設定をリセットしますか？');
		if (flag) {
			removeCookie('set[filter]');
			reloadPage();
		}
	});
	$('#rmDetails').click(function () {
		var flag = confirm('詳細設定をリセットしますか？');
		if (flag) {
			removeCookie('set[top]');
			removeCookie('set[last]');
			removeCookie('set[trand]');
			reloadPage();
		}
	});
	$('#rmAll').click(function () {
		var flag = confirm('すべての設定をリセットしますか？');
		if (flag) {
			removeCookie('set[filter]');
			removeCookie('set[top]');
			removeCookie('set[last]');
			removeCookie('set[trand]');
			removeCookie('set[bookmark');
			removeCookie('set[ocmenu]');
			removeCookie('set[chTable]');
			reloadPage();
		}
	});

	//set DetailsSetting
	setDetails("set[top]", 2, 'top');
	setDetails("set[last]", 5, 'last');
	setDetails("set[trand]", 5, 'trand');

	$('#setDetail').click(function () {
		var top = $('#top > option:selected').attr('value');
		var last = $('#last > option:selected').attr('value');
		var trand = $('#trand > option:selected').attr('value');
		var cMgr = new H_CookieManager();
		cMgr.setCookie("set[top]", top, 3600 * 24 * 5000, '/');
		cMgr.setCookie("set[last]", last, 3600 * 24 * 5000, '/');
		cMgr.setCookie("set[trand]", trand, 3600 * 24 * 5000, '/');
	});

	//css_setting
	$('th:not([class*="nosort"])').hover(
		function () {
			$(this).css({ backgroundColor: '#BCF0EE' });
		},
		function () {
			$(this).css({ backgroundColor: 'white' });
		}
	);
	//--jquery powertip setting　& alert message--
	$("td.filter").attr("title", "チェックされたブログは<br>次回から表示されません").powerTip({ placement: 'nw' });
	$("thead > tr > th").not(".nosort").attr("title", "クリックすると各項目ごとに<br>並べ替えできます").powerTip({ placement: "n" });
	$("#setDetail").click(function () {
		alert('表示設定を保存しました');
	});
	//jquery datepicker setting
	window.prettyPrint && prettyPrint();
	$('#dp1').datepicker({
		format: 'yyyy/mm/dd'
	});
	//check cookie enable
	if (!navigator.cookieEnabled) {
		$('#myTab').after('<div class="alert alert-error">Cookieが無効になっています。<br>有効にしないとサイトの機能を保存できません</div>');
	}

	//Close Menu
	$('#ocmenu').click(function () {
		var cMgr = new H_CookieManager();
		var str = cMgr.getCookie('set[ocmenu]');
		if (str == 1) {
			$(this).html('<div class="icon-chevron-up"></div>').next('div').fadeOut('fast');
			cMgr.setCookie("set[ocmenu]", '0', 3600 * 24 * 5000, '/');
		} else if (str == 0) {
			$(this).html('<div class="icon-chevron-down"></div>').next('div').fadeIn('fast');
			cMgr.setCookie("set[ocmenu]", '1', 3600 * 24 * 5000, '/');
		}
	});
	//display Table setting
	$('#chTable').toggle(
		function () {
			$('#navTable').fadeIn();
			$(this).removeClass('btn-inverse').addClass('btn-primary');
		},
		function () {
			$('#navTable').fadeOut();
			$(this).removeClass('btn-primary').addClass('btn-inverse');
		});
	$('#liDate,#liCat,#liHit,#liBlog,#liOver,#liHitHead,#liBlogTail,#liFilter').live('click', function () {
		var cMgr = new H_CookieManager();
		var str = cMgr.getCookie('set[chTable]');
		var arr = str.split('.');
		if (this.id == 'liDate') {
			if (arr[0] == 1) {
				$(this).removeClass('btn-info').addClass('btn-inverse').text('日時を非表示');
				$('#thDate,.tdDate').addClass('hide');
				arr[0] = 0;
			} else if (arr[0] == 0) {
				$(this).removeClass('btn-inverse').addClass('btn-info').text('日時を表示');
				$('#thDate,.tdDate').removeClass('hide');
				arr[0] = 1;
			}
		}
		if (this.id == 'liCat') {
			if (arr[1] == 1) {
				$(this).removeClass('btn-info').addClass('btn-inverse').text('カテゴリを非表示');
				$('#thCat,.tdCat').addClass('hide');
				arr[1] = 0;
			} else if (arr[1] == 0) {
				$(this).removeClass('btn-inverse').addClass('btn-info').text('カテゴリを表示');
				$('#thCat,.tdCat').removeClass('hide');
				arr[1] = 1;
			}
		}
		if (this.id == 'liHit') {
			if (arr[2] == 1) {
				$(this).removeClass('btn-info').addClass('btn-inverse').text('HITバーを非表示');
				$('#thHit,.tdHit').addClass('hide');
				arr[2] = 0;
			} else if (arr[2] == 0) {
				$(this).removeClass('btn-inverse').addClass('btn-info').text('HITバーを表示');
				$('#thHit,.tdHit').removeClass('hide');
				arr[2] = 1;
			}
		}
		if (this.id == 'liBlog') {
			if (arr[3] == 1) {
				$(this).removeClass('btn-info').addClass('btn-inverse').text('ブログを非表示');
				$('#thBlog,.tdBlog').addClass('hide');
				arr[3] = 0;
			} else if (arr[3] == 0) {
				$(this).removeClass('btn-inverse').addClass('btn-info').text('ブログを表示');
				$('#thBlog,.tdBlog').removeClass('hide');
				arr[3] = 1;
			}
		}
		if (this.id == 'liOver') {
			if (arr[4] == 0) {
				$(this).removeClass('btn-inverse').addClass('btn-info').text('記事を折り返す');
				$('td.tdLink a').addClass('ofoff');
				arr[4] = 1;
			} else if (arr[4] == 1) {
				$(this).removeClass('btn-info').addClass('btn-inverse').text('記事を折り返さない');
				$('td.tdLink a').removeClass('ofoff');
				arr[4] = 0;
			}
		}
		if (this.id == 'liHitHead') {
			if (arr[5] == 0) {
				switchHit(1);
				arr[5] = 1;
			} else if (arr[5] >= 1) {
				switchHit(0);
				arr[5] = 0;
			}
		}
		if (this.id == 'liBlogTail') {
			if (arr[6] == 0) {
				switchBlog();
				arr[6] = 1;
			} else if (arr[6] == 1) {
				$(this).removeClass('btn-info').addClass('btn-inverse').text('記事末尾にブログ名を非表示');
				$('span.spBlog').remove();
				arr[6] = 0;
			}
		}
		if (this.id == 'liFilter') {
			if (arr[7] == 1) {
				arr[7] = 0; //非表示にする
				switchFilter(false);
			} else {
				arr[7] = 1; //表示する
				switchFilter(true);
			}
		}

		str = arr.join('.');
		cMgr.setCookie("set[chTable]", str, 3600 * 24 * 5000, '/');

	});

	function switchFilter(bool) {
		if (bool) {
			$('#liFilter').removeClass('btn-inverse').addClass('btn-info').text('フィルター列を表示');
			$('#thFilter, .filter').removeClass('hide');
		} else {
			$('#liFilter').removeClass('btn-info').addClass('btn-inverse').text('フィルター列を非表示');
			$('#thFilter, .filter').addClass('hide');
		}
	}

	$('#liSmart').click(function () {
		var cMgr = new H_CookieManager();
		cMgr.setCookie("set[chTable]", '0.0.0.0.1.1.1.1', 3600 * 24 * 5000, '/');
		$('#liDate').removeClass('btn-info').addClass('btn-inverse').text('日時を非表示');
		$('#thDate,.tdDate').addClass('hide');
		$('#liCat').removeClass('btn-info').addClass('btn-inverse').text('カテゴリを非表示');
		$('#thCat,.tdCat').addClass('hide');
		$('#liHit').removeClass('btn-info').addClass('btn-inverse').text('HITバーを非表示');
		$('#thHit,.tdHit').addClass('hide');
		$('#liBlog').removeClass('btn-info').addClass('btn-inverse').text('ブログを非表示');
		$('#thBlog,.tdBlog').addClass('hide');
		$('#liOver').removeClass('btn-inverse').addClass('btn-info').text('記事を折り返す');
		$('td.tdLink a').addClass('ofoff');
		$('span.spBlog').remove();
		$('div.divHitTail').remove();
		switchHit(1);
		switchBlog();
		switchFilter(true);
	});
	$('#liReset').click(function () {
		var cMgr = new H_CookieManager();
		cMgr.setCookie("set[chTable]", '1.1.1.1.1.1.1.1', 3600 * 24 * 5000, '/');
		$('#liDate').removeClass('btn-inverse').addClass('btn-info').text('日時を表示');
		$('#thDate,.tdDate').removeClass('hide');
		$('#liCat').removeClass('btn-inverse').addClass('btn-info').text('カテゴリを表示');
		$('#thCat,.tdCat').removeClass('hide');
		$('#liHit').removeClass('btn-inverse').addClass('btn-info').text('HITバーを表示');
		$('#thHit,.tdHit').removeClass('hide');
		$('#liBlog').removeClass('btn-inverse').addClass('btn-info').text('ブログを表示');
		$('#thBlog,.tdBlog').removeClass('hide');
		$('#liOver').removeClass('btn-inverse').addClass('btn-info').text('記事を折り返す');
		$('td.tdLink a').addClass('ofoff');
		$('div.divHitTail').remove();
		switchHit(1);
		$('span.spBlog').remove();
		switchBlog();
		switchFilter(true);
		//$('#liBlogTail').removeClass('btn-inverse').addClass('btn-info').text('記事末尾にブログ名を表示');
		//$('span.spBlog').remove();
	});

});
function switchHit(sw) {
	switch (sw) {
		case 0:
			$('#liHitHead').removeClass('btn-info').addClass('btn-inverse').text('記事にHIT数を非表示');
			$('div.divHitTail').remove();
			break;

		case 1:
			$('#liHitHead').removeClass('btn-inverse').addClass('btn-info').text('記事にHIT数を表示');
			$('table#latest tbody tr,table#people tbody tr,table#range tbody tr').each(function (n) {
				$('td.tdLink:eq(' + n + ') a').after("<div class='divHitTail' style='display:inline;'><span class='num'>" + $('td.hbar:eq(' + n + ')').text() + "</span><span class='hit'>HIT</span></div>");
			});
			break;
	}
}
function switchBlog() {
	$('#liBlogTail').removeClass('btn-inverse').addClass('btn-info').text('記事末尾にブログ名を表示');
	$('table#latest tbody tr,table#people tbody tr,table#range tbody tr').each(function (n) {
		if ($('td.tdLink:eq(' + n + ') div').hasClass('divHitTail')) {
			$('td.tdLink:eq(' + n + ') div.divHitTail').after("<span class='spBlog'>" + $('td.tdBlog:eq(' + n + ') > a').text() + "</span>");
		} else {
			$('td.tdLink:eq(' + n + ') .tdDiv').append("<span class='spBlog'>" + $('td.tdBlog:eq(' + n + ') > a').text() + "</span>");
		}
	});
}


var cMgr = new H_CookieManager();
var str = cMgr.getCookie('set[chTable]');
if (str == undefined) {
	str = global_chTable
}
var arr = str.split('.');

if (arr[0] != 1) {
	$('#liDate').removeClass('btn-info').addClass('btn-inverse').text('日時を非表示');
	if (arr[0] == 0) $('#thDate,.tdDate').addClass('hide');
}
if (arr[1] != 1) {
	$('#liCat').removeClass('btn-info').addClass('btn-inverse').text('カテゴリを非表示');
	if (arr[1] == 0) $('#thCat,.tdCat').addClass('hide');
}
if (arr[2] != 1) {
	$('#liHit').removeClass('btn-info').addClass('btn-inverse').text('HITバーを非表示');
	if (arr[2] == 0) $('#thHit,.tdHit').addClass('hide');
}
if (arr[3] != 1) {
	$('#liBlog').removeClass('btn-info').addClass('btn-inverse').text('ブログを非表示');
	if (arr[3] == 0) $('#thBlog,.tdBlog').addClass('hide');
}
if (arr[4] != 1) {
	$('#liOver').removeClass('btn-info').addClass('btn-inverse').text('記事を折り返さない');
	if (arr[4] == 0) $('td.tdLink a').removeClass('ofoff');
}
if (!($('div').hasClass('divHit')) && !($('div').hasClass('divHitTail'))) {
	if (arr[5] >= 1) {
		switchHit(1);
	}
}
if (!($('span').hasClass('spBlog'))) {
	if (arr[6] == 1) {
		switchBlog();
	}
}
if (arr[7] != 1) {
	$('#liFilter').removeClass('btn-info').addClass('btn-inverse').text('フィルター列を非表示');
	if (arr[7] == 0) $('#thFilter, .filter').addClass('hide');
}